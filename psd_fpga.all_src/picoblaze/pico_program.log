Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2025-02-10T15:22:16
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 227
  Memory locations available: 3869
  Scratchpad size: 256


Assembly listing
----------------
                                        ;
000                                     ; Test program for our picoblaze
000                                     ; For starters just blink led connected to bit 0
000                                     ; of output port #0
                                        ;
000                                     ; Keep adding until is does everything we need!
                                        ;
000                                     ; 31-Oct-2024
                                        ;
000                                     ; Letâ€™s replace the adc test program with our
000                                     ; actual nuclear program
000                                     ; 31-Jan-2025
000                                     ; Initially make it essentially just do the adc_test

000                                     ; ********************************************
000                                     ; Output ports (we have 8 real output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast signals
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED0
000                                     ; 1		LED1 (also the busy bit!)

000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Board id
000                                     ; type = 10 ---> TDC data (lower 24 bits)
000                                     ; type = 11 ---> TDC data (upper 24 bits)

000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6		tdc_csb
000                                     ; 7		tdc_enable

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     constant MISC_OPORT, 07

000                                     ; --------------------------------
000                                     ; PORT 7 (Misc outputs)
000                                     ; --------------------------------
                                        ;
000                                     ; 0 	force_psd_reset
000                                     ; 1		veto_reset

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2		tdc_intb (interrupt signal from TDC7200)

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; We can use s0 - sd, se and sf are special
000                                     ; Give more desciptive names to some of our registers
000                                     ; The scratch registers get used but not restored!
000                                     ; Other regs tend to be saved on the stack!
                                        ;
000                                     namereg s0, op                 ; Output port register (scratch)
000                                     namereg s1, ip                 ; Input port register (scratch)
000                                     namereg s2, scr0               ; Scratchpad register 0 (scratch)
000                                     namereg s3, scr1               ; Scratchpad register 1 (scratch)
000                                     namereg s4, scr2               ; Scratchpad register 2 (scratch)
000                                     namereg s5, cnt                ; Used for counting "things"
000                                     namereg s6, dly_reg            ; Used in delay_1us routine
000                                     namereg s7, adc_reg            ; Used by adc routine
000                                     namereg s8, adc_clk_mask       ; Defines which adc clocks are to be used
000                                     namereg s9, adc_conv_mask      ; Defines which adc conv signals are to be used
000                                     namereg sa, psd_or_reg         ; Lower 2 bits keep track of PSD1 and PSD0 ORs
000                                     namereg sb, led_reg            ; Global variable that constains state of LEDs
000                                     namereg sc, tdc_ctl_reg        ; Used in tdc_ser
000                                     namereg sd, addr_reg           ; Holds PSD channel address

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Weâ€™ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; Register se is also special
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Read the board id port and store it in scratchpad memory

000                                     constant BOARD_ID, 00


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ;********************************************
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ;********************************************
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000

000  220CE â•­â”€â”€â”€â”€â”€â”€â¤™             origin: jump nuclear
           â”‚
001        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        â”‚                            ; Subroutine Name: init
           â”‚                            ;
001        â”‚                            ; Initialize the stack pointer, SP
001        â”‚                            ; Initialize registers and ports
001        â”‚                            ; Read board id and save
           â”‚                            ;
001        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
001        â”‚                      init:
           â”‚
001        â”‚                            ; Initialize the stack pointer
           â”‚
001  01F3F â•­â”€â”€â”€â”€â”€â”€â–¶                     load SP, 3f
           â”‚
002        â”‚                            ; Read the board id from port and save it to scratchpad memory location 0
           â”‚
002  09201 â”‚                            input scr0, BOARD_ID_PORT
003  2F200 â”‚                            store scr0, BOARD_ID
           â”‚
004        â”‚                            ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
004        â”‚                            ; To retreive the board id from scratchpad memory
004        â”‚                            ;			fetch		scr0, BOARD_ID
004        â”‚                            ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           â”‚
004        â”‚                            ; Clear the output port registers
           â”‚
004  01200 â”‚                            load scr0, 00
005  2D200 â”‚                            output scr0, LED_PORT
006  2D202 â”‚                            output scr0, DATA_TAG_PORT
007  2D203 â”‚                            output scr0, TDC_DATA_PORT
008  2D204 â”‚                            output scr0, TDC_CTL_PORT
           â”‚
009        â”‚                            ; Clear some registers
           â”‚
009  01000 â”‚                            load op, 00
00A  01100 â”‚                            load ip, 00
00B  01500 â”‚                            load cnt, 00
00C  01600 â”‚                            load dly_reg, 00
00D  01700 â”‚                            load adc_reg, 00
00E  01800 â”‚                            load adc_clk_mask, 00
00F  01900 â”‚                            load adc_conv_mask, 00
010  01C00 â”‚                            load tdc_ctl_reg, 00
011  01B00 â”‚                            load led_reg, 00
012  01A00 â”‚                            load psd_or_reg, 00
           â”‚
013        â”‚                            ; Need bit 6 (tdc_csb) of TDC_CTL_PORT to be high (inactive)
013        â”‚                            ; Also bit 7 (tdc_enable) should be high (active)
013        â”‚                            ; Bit 5 serial clk should also be high
           â”‚
013  05C20 â”‚                            or tdc_ctl_reg, 20             ; Set bit 5
014  05C40 â”‚                            or tdc_ctl_reg, 40             ; Set bit 6
015  05C80 â”‚                            or tdc_ctl_reg, 80             ; Set bit 7
016  2D204 â”‚                            output scr0, TDC_CTL_PORT
           â”‚
017        â”‚                            ; Reset the ADC shift registers
017        â”‚                            ; Bring reset bit high in adc_reg and then back low
017        â”‚                            ; Bit 7 of adc_reg is the reset adc registers bit
017        â”‚                            ; Clock and conv signals low
017        â”‚                            ; Mux selects (3â€™b000) choosing adc reg for PSD0 A integrator
017        â”‚                            ; Pulse the adc reg reset line
           â”‚
017  05780 â”‚                            or adc_reg, 80                 ; Set bit 7
018  2D701 â”‚                            output adc_reg, ADC_CTL_PORT
019  0377F â”‚                            and adc_reg, 7f                ; Clear bit 7
01A  2D701 â”‚                            output adc_reg, ADC_CTL_PORT
           â”‚
01B        â”‚                            ; Make sure that tokens into the PSD chips are HIGH (inactive)
01B        â”‚                            ; token_in for the PSD ports is bit 6
           â”‚
01B  01200 â”‚                            load scr0, 00
01C  05240 â”‚                            or scr0, 40                    ; Set bit 6
01D  2D205 â”‚                            output scr0, PSD0_OPORT
01E  2D206 â”‚                            output scr0, PSD1_OPORT
           â”‚
01F        â”‚                            ; Bring the force_reset and veto_reset pins low on both PSD chips
01F        â”‚                            ; force_reset is bit 0
01F        â”‚                            ; veto_reset is bit 1
           â”‚
01F  01200 â”‚                            load scr0, 00
020  2D207 â”‚                            output scr0, MISC_OPORT
           â”‚
021        â”‚                            ; Done so return
           â”‚
021  25000 â”‚                            return
           â”‚
022        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
022        â”‚                            ; Subroutine Name: tdc_ser
           â”‚                            ;
022        â”‚                            ; Routine to send and receive serial dataa
022        â”‚                            ; from TDC7200
           â”‚                            ;
022        â”‚                            ; When called cnt should contain the number
022        â”‚                            ; serial clock pulses we want
           â”‚                            ;
022        â”‚                            ; --------------------------------
022        â”‚                            ; PORT 4 (TDC register control)
022        â”‚                            ; --------------------------------
022        â”‚                            ; 0		tdc_reg_ld_0
022        â”‚                            ; 1		tdc_reg_ld_1
022        â”‚                            ; 2		tdc_reg_ld_2
022        â”‚                            ; 3		tdc_reg_rst
022        â”‚                            ; 4		tdc_reg_shift
022        â”‚                            ; 5		tdc_reg_sclk
022        â”‚                            ; 6		tdc_csb
022        â”‚                            ; 7		tdc_enable
           â”‚                            ;
022        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
022        â”‚                   tdc_ser:
           â”‚
022        â”‚                            ; Need to bring the tdc_csb line low
           â”‚
022  03CBF â”‚                            and tdc_ctl_reg, bf            ; Clear bit 6
023  2DC04 â”‚                            output tdc_ctl_reg, TDC_CTL_PORT
           â”‚
024        â”‚                            ; Apply the clock pulses
           â”‚
024  03CDF â”‚     â•­â–¶          .clk_loop: and tdc_ctl_reg, df            ; Clear bit 5
025  2DC04 â”‚     â”‚                      output tdc_ctl_reg, TDC_CTL_PORT
026  00EE0 â”‚     â”‚                      load se, se                    ; NOP
027  00EE0 â”‚     â”‚                      load se, se                    ; NOP
028  05C20 â”‚     â”‚                      or tdc_ctl_reg, 20             ; Set bit 5
029  2DC04 â”‚     â”‚                      output tdc_ctl_reg, TDC_CTL_PORT
02A  19501 â”‚     â”‚                      sub cnt, 01
02B  36024 â”‚     â•°â¤™                     jump NZ, .clk_loop
           â”‚
02C        â”‚                            ; Need to bring the tdc_csb line high
           â”‚
02C  05C40 â”‚                            or tdc_ctl_reg, 40             ; Set bit 6
02D  2DC04 â”‚                            output tdc_ctl_reg, TDC_CTL_PORT
           â”‚
02E  25000 â”‚                            return
           â”‚
02F        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
02F        â”‚                            ; Subroutine Name: tdc_reg_ld
           â”‚                            ;
02F        â”‚                            ; Used to load a byte into the tdc_reg
           â”‚                            ;
02F        â”‚                            ; --------------------------------
02F        â”‚                            ; PORT 4 (TDC register control)
02F        â”‚                            ; --------------------------------
02F        â”‚                            ; 0		tdc_reg_ld_0
02F        â”‚                            ; 1		tdc_reg_ld_1
02F        â”‚                            ; 2		tdc_reg_ld_2
02F        â”‚                            ; 3		tdc_reg_rst
02F        â”‚                            ; 4		tdc_reg_shift
02F        â”‚                            ; 5		tdc_reg_sclk
02F        â”‚                            ; 6		tdc_csb
02F        â”‚                            ; 7		tdc_enable
           â”‚                            ;
02F        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
02F        â”‚                tdc_reg_ld:
           â”‚
02F  25000 â”‚                            return
           â”‚
           â”‚
030        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
030        â”‚                            ; Subroutine Name: force_reset
           â”‚                            ;
030        â”‚                            ; This performs reset on PSD analog blocks
030        â”‚                            ; Veto reset is made low
           â”‚                            ;
030        â”‚                            ; Apply a 1 usec long (approx) force_reset pulse
030        â”‚                            ; Bit 0 of MISC_PORT
030        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
030  01000 â•­â”€â”€â”€â”€â”€â”€â–¶        force_reset: load op, 00
031  05001 â”‚                            or op, 01                      ; Set bit 0
032  2D007 â”‚                            output op, MISC_OPORT
033  20037 â”‚     â•­â¤™                     call dly_us
034  030FE â”‚     â”‚                      and op, fe                     ; Clear bit 0
035  2D007 â”‚     â”‚                      output op, MISC_OPORT
036  25000 â”‚     â”‚                      return
           â”‚     â”‚
037        â”‚     â”‚                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
037        â”‚     â”‚                      ; Subroutine Name: dly_us
           â”‚     â”‚                      ;
037        â”‚     â”‚                      ; Delay of 1 usec
037        â”‚     â”‚                      ; Delay is [(4 * dly_reg) + 6] / Fclk
037        â”‚     â”‚                      ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           â”‚     â”‚                      ;
037        â”‚     â”‚                      ; Routine uses dly_reg and does not restore it
           â”‚     â”‚                      ;
037        â”‚     â”‚                      ; 24 (i.e $18) assumes a 100 MHz clock
037        â”‚     â”‚                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚     â”‚
037        â”‚     â”‚              dly_us:
037  01618 â•­â”€â”€â”€â”¬â”¬â”´â–¶                     load dly_reg, 24'd
038  19601 â”‚   â”‚â”‚â•­â–¶           .wait_us: sub dly_reg, 01
039  36038 â”‚   â”‚â”‚â•°â¤™                     jump NZ, .wait_us
03A  25000 â”‚   â”‚â”‚                       return
           â”‚   â”‚â”‚
03B        â”‚   â”‚â”‚                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03B        â”‚   â”‚â”‚                       ; Subroutine Name: adc_conv
           â”‚   â”‚â”‚                       ;
03B        â”‚   â”‚â”‚                       ; Pass in adc_clk_mask and adc_conv_mask
03B        â”‚   â”‚â”‚                       ; clk_0 is bit 0 of adc_clk_mask
03B        â”‚   â”‚â”‚                       ; clk_1 is bit 1 of adc_clk_mask
03B        â”‚   â”‚â”‚                       ; conv_0 is bit 2 of adc_conv_mask
03B        â”‚   â”‚â”‚                       ; conv_1 is bit 3 of adc_conv_maks
           â”‚   â”‚â”‚                       ;
03B        â”‚   â”‚â”‚                       ; Uses the cnt register to count clock pulses (16 bit ADC)
03B        â”‚   â”‚â”‚                       ; but restores cnt register before returning!!!
03B        â”‚   â”‚â”‚                       ; Use adc_reg but we donâ€™t restore it
           â”‚   â”‚â”‚                       ;
03B        â”‚   â”‚â”‚                       ; ******
03B        â”‚   â”‚â”‚                       ; Used by both the adc_test and the nuclear program
03B        â”‚   â”‚â”‚                       ; ******
           â”‚   â”‚â”‚                       ;
03B        â”‚   â”‚â”‚                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚   â”‚â”‚
03B        â”‚   â”‚â”‚             adc_conv:
           â”‚   â”‚â”‚
03B        â”‚   â”‚â”‚                       ; Save cnt register
           â”‚   â”‚â”‚
03B  2E5F0 â•­â”€â”€â”€â”€â”€â”€â–¶                     store cnt, (SP)                ; Push
03C  19F01 â”‚   â”‚â”‚                       sub SP, 01
           â”‚   â”‚â”‚
           â”‚   â”‚â”‚
03D        â”‚   â”‚â”‚                       ; Bring conv signals high (determined by adc_conv_mask)
03D        â”‚   â”‚â”‚                       ; The AD7687 ADCs sample PSD analog outputs on the rising
03D        â”‚   â”‚â”‚                       ; edge of CONV signal
           â”‚   â”‚â”‚
03D  00790 â”‚   â”‚â”‚                       load adc_reg, adc_conv_mask    ; Make CONV high
03E  2D701 â”‚   â”‚â”‚                       output adc_reg, ADC_CTL_PORT
           â”‚   â”‚â”‚
03F        â”‚   â”‚â”‚                       ; Wait for 2 usec
           â”‚   â”‚â”‚
03F  20037 â”‚   â”‚â•°â”€â¤™                     call dly_us
040  20037 â”‚   â•°â”€â”€â¤™                     call dly_us
           â”‚
041        â”‚                            ; Bring conv signals low
           â”‚
041  06790 â”‚                            xor adc_reg, adc_conv_mask
042  2D701 â”‚                            output adc_reg, ADC_CTL_PORT
           â”‚
043        â”‚                            ; Apply 16 clock pulses (takes about 2 usec)
043        â”‚                            ; Reading serial data out of the ADCs
043        â”‚                            ; Clocked into shift registers in our custom block
           â”‚
043  01510 â”‚                            load cnt, 16'd
044  06780 â”‚     â•­â–¶          .clk_loop: xor adc_reg, adc_clk_mask
045  2D701 â”‚     â”‚                      output adc_reg, ADC_CTL_PORT
046  06780 â”‚     â”‚                      xor adc_reg, adc_clk_mask
047  00EE0 â”‚     â”‚                      load se, se                    ; NOP
048  00EE0 â”‚     â”‚                      load se, se                    ; NOP
049  2D701 â”‚     â”‚                      output adc_reg, ADC_CTL_PORT
04A  19501 â”‚     â”‚                      sub cnt, 01
04B  36044 â”‚     â•°â¤™                     jump NZ, .clk_loop
           â”‚
04C        â”‚                            ; Restore cnt register
           â”‚
04C  11F01 â”‚                            add SP, 01                     ; Pop
04D  0A5F0 â”‚                            fetch cnt, (SP)
           â”‚
           â”‚
04E  25000 â”‚                            return
           â”‚
04F        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04F        â”‚                            ; Name: adc_to_fifo
           â”‚                            ;
04F        â”‚                            ; Each time this routine is called, it sends the A, B, C, T
04F        â”‚                            ; adc values to the microblaze FIFO
04F        â”‚                            ; ip will be used ...should contain PSDx_IPORT (x = 0 or 1)
           â”‚                            ;
04F        â”‚                            ; Tag format:
           â”‚                            ;
04F        â”‚                            ; 0		psd addr bit 0
04F        â”‚                            ; 1		psd addr bit 1
04F        â”‚                            ; 2		psd addr bit 2
04F        â”‚                            ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
04F        â”‚                            ; 4		bit 0 of sc
04F        â”‚                            ; 5		bit 1 of sc
04F        â”‚                            ; 6		bit 0 of type
04F        â”‚                            ; 7		bit 1 of type
           â”‚
04F        â”‚                            ; type = 00 ---> ADC data
04F        â”‚                            ; type = 01 ---> Board id
04F        â”‚                            ; type = 10 ---> TDC data (lower 24 bits)
04F        â”‚                            ; type = 11 ---> TDC data (upper 24 bits)
           â”‚
04F        â”‚                            ; sc = 00 -----> integrator A
04F        â”‚                            ; sc = 01 -----> integrator B
04F        â”‚                            ; sc = 10 -----> integrator C
04F        â”‚                            ; sc = 11 -----> time
04F        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
04F        â”‚               adc_to_fifo:
           â”‚                            ;
04F        â”‚                            ; When we enter the routine, ip should contain PSD0 or PSD1 IPORT
04F        â”‚                            ; addr_reg will be used ...should contain PSDx_IPORT (x = 0 or 1)
04F        â”‚                            ; Here is the bit map
04F        â”‚                            ; NOTE: bit 6 tells us if it is PSD 0 or PSD1
           â”‚                            ;
04F        â”‚                            ; 0		psd0_or
04F        â”‚                            ; 1		psd0_token_out
04F        â”‚                            ; 2		psd0_acq_ack
04F        â”‚                            ; 3		psd0_addr_out0
04F        â”‚                            ; 4		psd0_addr_out1
04F        â”‚                            ; 5		psd0_addr_out2
04F        â”‚                            ; 6     0 if PSD 0, 1 if PSD 1
04F        â”‚                            ; 7     0
           â”‚
04F        â”‚                            ; Push some registers onto stack
           â”‚
04F  2E5F0 â•­â”€â”€â”€â”€â”€â”€â–¶                     store cnt, (SP)                ; Push
050  19F01 â”‚                            sub SP, 01
           â”‚
051  2E0F0 â”‚                            store op, (SP)                 ; Push
052  19F01 â”‚                            sub SP, 01
           â”‚
053  2E1F0 â”‚                            store ip, (SP)                 ; Push
054  19F01 â”‚                            sub SP, 01
           â”‚
           â”‚
055        â”‚                            ; Shift right 3 places
055        â”‚                            ; Lower nybble now contains the channel address (bit 3 is PSD ID)
055        â”‚                            ; Upper nybble contains 4â€™b000
           â”‚
055  14D0E â”‚                            sr0 addr_reg
056  14D0E â”‚                            sr0 addr_reg
057  14D0E â”‚                            sr0 addr_reg
           â”‚
           â”‚
058        â”‚                            ; Load cnt to keep track which output we are working on
058        â”‚                            ; A, B, C, or T (00, 01, 10, 11)
           â”‚
058  01500 â”‚                            load cnt, 00
           â”‚
059        â”‚                            ; Use scr1 to keep track of which PSD chip (either 0 or 1)
059        â”‚                            ; Inspect bit 3 of ip register to see if it is PSD 0 or PSD 1
           â”‚
059  01300 â”‚                            load scr1, 00                  ; PSD 0
05A  0DD08 â”‚                            test addr_reg, 08              ; Test bit 3
05B  3205D â”‚     â•­â¤™                     jump Z, .loop
05C  01301 â”‚     â”‚                      load scr1, 01                  ; PSD 1
           â”‚     â”‚
05D        â”‚     â”‚                      ; We will write DATA_TAG_PORT first
05D        â”‚     â”‚                      ; Format of the data tag byte :
05D        â”‚     â”‚                      ; 	xxyyzzzz
05D        â”‚     â”‚                      ; 	xx is type (00 = adc, 01 = board id, 10 = lower TDC data, 11 = upper TDC data)
05D        â”‚     â”‚                      ; 	yy = sc (00 = A, 01 = B, 10 = C , 11 =T)
05D        â”‚     â”‚                      ; 	zz = 4-bit channel address
           â”‚     â”‚
05D  000D0 â”‚    â•­â”´â–¶              .loop: load op, addr_reg              ; Load channel address
05E  00450 â”‚    â”‚                       load scr2, cnt                 ; Copy cnt (i.e. which analog output) to scr2
05F  14406 â”‚    â”‚                       sl0 scr2
060  14406 â”‚    â”‚                       sl0 scr2
061  14406 â”‚    â”‚                       sl0 scr2
062  14406 â”‚    â”‚                       sl0 scr2
063        â”‚    â”‚                       ; Shift left 4 places
063  04040 â”‚    â”‚                       or op, scr2                    ; Combine with channel address
064  2D002 â”‚    â”‚                       output op, DATA_TAG_PORT       ; Put out our data tag (MSbyte of 32-bit word)
           â”‚    â”‚
065        â”‚    â”‚                       ; Now we will now write ADC_CTL_PORT
065        â”‚    â”‚                       ; We need to route out the appropriate ADC register to the FIFO using MUX (3 bits)
           â”‚    â”‚
065  00050 â”‚    â”‚                       load op, cnt                   ; cnt is either (00 = A, 01 = B, 10 = C, 11 = T)
066  14006 â”‚    â”‚                       sl0 op
067  14006 â”‚    â”‚                       sl0 op
068  14006 â”‚    â”‚                       sl0 op
069  14006 â”‚    â”‚                       sl0 op
06A        â”‚    â”‚                       ; Mux sel is bits 4, 5, 6 of the ADC_CTL_PORT
06A  0D301 â”‚    â”‚                       test scr1, 01                  ; Test bit 0				; Bit 6 is 0 if PSD 0
06B  3206D â”‚    â”‚â•­â¤™                     jump Z, .skip
06C  05040 â”‚    â”‚â”‚                      or op, 40                      ; Set bit 6				; Bit 6 is a 1 if PSD 1
06D  2D001 â”‚    â”‚â•°â–¶              .skip: output op, ADC_CTL_PORT
           â”‚    â”‚                       ;
06E        â”‚    â”‚                       ; Correct input is now sitting on FIFO input
06E        â”‚    â”‚                       ; Wait for â€™treadyâ€™ signal to be active
           â”‚    â”‚                       ;
06E  09100 â”‚    â”‚â•­â–¶         .wait_trdy: input ip, STATUS_IPORT
           â”‚    â”‚â”‚
06F        â”‚    â”‚â”‚                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           â”‚    â”‚â”‚
06F  0D101 â”‚    â”‚â”‚                      test ip, 01                    ; Test bit 0
070  3206E â”‚    â”‚â•°â¤™                     jump Z, .wait_trdy
           â”‚    â”‚
071        â”‚    â”‚                       ; When FIFO is ready, send data (what we send to vaild port makes no diff)
           â”‚    â”‚
071  2D0FE â”‚    â”‚                       output op, VALID_PORT
           â”‚    â”‚
072        â”‚    â”‚                       ; Check to see if we are done sending A, B, C, T
072        â”‚    â”‚                       ; When cnt is equal to 4, we are done!
           â”‚    â”‚
072  11501 â”‚    â”‚                       add cnt, 01
073  1D504 â”‚    â”‚                       compare cnt, 04
074  3605D â”‚    â•°â”€â¤™                     jump NZ, .loop
           â”‚
075        â”‚                            ; Retrieve registers from stack
           â”‚
075  11F01 â”‚                            add SP, 01                     ; Pop
076  0A1F0 â”‚                            fetch ip, (SP)
           â”‚
077  11F01 â”‚                            add SP, 01                     ; Pop
078  0A0F0 â”‚                            fetch op, (SP)
           â”‚
079  11F01 â”‚                            add SP, 01                     ; Pop
07A  0A5F0 â”‚                            fetch cnt, (SP)
           â”‚
           â”‚
07B  25000 â”‚                            return
           â”‚
07C        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
07C        â”‚                            ; Name: get_event
           â”‚                            ;
07C        â”‚                            ; Routine to get a nuclear physics event
           â”‚                            ;
07C        â”‚                            ; Aquires data from the 4 ADCS (A, B, C, T) for all hit channels on
07C        â”‚                            ; both PSD chips!
           â”‚                            ;
07C        â”‚                            ; We look at ORs and keep getting samples until both PSD0 and PSD1 ORs low!
07C        â”‚                            ; Each time we get A, B, C, T samples, we send them to the FIFO
07C        â”‚                            ; Each time send a word to the FIFO, we need to write to VALID_PORT
           â”‚                            ;
07C        â”‚                            ; Before we exit we need to send one more word, what we
07C        â”‚                            ; send is not so important but when this word is sent
07C        â”‚                            ; we need to do a write to LAST_PORT! This signals the end of packet!
           â”‚                            ;
07C        â”‚                            ; *** Used by nuclear program
           â”‚                            ;
07C        â”‚                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           â”‚
07C        â”‚                 get_event:
           â”‚
07C        â”‚                            ; Set the busy bit (also led[1])
07C        â”‚                            ; Bit 1 of LED_PORT is led[1] which is also the busy bit!
           â”‚
07C  05B02 â•­â”€â”€â”€â”€â”€â”€â–¶                     or led_reg, 02                 ; Set bit 1
07D  2DB00 â”‚                            output led_reg, LED_PORT
           â”‚
07E        â”‚                            ; Check the ORs out of PSD chips
07E        â”‚                            ; If both ORs low then we are done!
           â”‚
07E  01A00 â•­â”¬â”€â”¬â”€â”€â”€â–¶              .loop: load psd_or_reg, 00
07F  01700 â”‚â”‚ â”‚                         load adc_reg, 00
           â”‚â”‚ â”‚
080  09102 â”‚â”‚ â”‚                         input ip, PSD0_IPORT
081  0D101 â”‚â”‚ â”‚                         test ip, 01                    ; Test bit 0					; Testing PSD0 OR
082  32084 â”‚â”‚ â”‚  â•­â¤™                     jump Z, .or0
083  05A01 â”‚â”‚ â”‚  â”‚                      or psd_or_reg, 01              ; Set bit 0			; Make note that PSD0 OR is high
084  09103 â”‚â”‚ â”‚  â•°â–¶               .or0: input ip, PSD1_IPORT
085  0D101 â”‚â”‚ â”‚                         test ip, 01                    ; Test bit 0					; Testing PSD1 OR
086  32088 â”‚â”‚ â”‚  â•­â¤™                     jump Z, .or1
087  05A02 â”‚â”‚ â”‚  â”‚                      or psd_or_reg, 02              ; Set bit 1			; Make note that PSD1 OR is high
           â”‚â”‚ â”‚  â”‚                      ;
088        â”‚â”‚ â”‚  â”‚                      ; Implement a case statement based on lower two bits of psd_or_reg
           â”‚â”‚ â”‚  â”‚                      ;
           â”‚â”‚ â”‚  â”‚
088  1DA00 â”‚â”‚ â”‚  â•°â–¶               .or1: compare psd_or_reg, 00
089  320C4 â•­â”€â”€â”€â”€â”€â”€â¤™                     jump Z, .done
08A  1DA01 â”‚â”‚ â”‚                         compare psd_or_reg, 01
08B  32091 â”‚â”‚ â”‚ â•­â”€â¤™                     jump Z, .psd0
08C  1DA02 â”‚â”‚ â”‚ â”‚                       compare psd_or_reg, 02
08D  320A0 â”‚â”‚ â”‚â•­â”€â”€â¤™                     jump Z, .psd1
08E  1DA03 â”‚â”‚ â”‚â”‚â”‚                       compare psd_or_reg, 03
08F  320AF â”‚â”‚â•­â”€â”€â”€â”€â¤™                     jump Z, .both
           â”‚â”‚â”‚â”‚â”‚â”‚                       ;
090        â”‚â”‚â”‚â”‚â”‚â”‚                       ; Should never happen ... if it does then hang
090        â”‚â”‚â”‚â”‚â”‚â”‚                       ; Both LEDs will be on and PicoBlaze will be
090        â”‚â”‚â”‚â”‚â”‚â”‚                       ; non-responsive
           â”‚â”‚â”‚â”‚â”‚â”‚                       ;
090  22090 â”‚â”‚â”‚â”‚â”‚â”‚â•°â–¶               .err: jump .err
           â”‚â”‚â”‚â”‚â”‚â”‚
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ;  Only PSD 0 needs attention
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           â”‚â”‚â”‚â”‚â”‚â”‚
091        â”‚â”‚â”‚â”‚â”‚â”‚                .psd0:
           â”‚â”‚â”‚â”‚â”‚â”‚
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; Notablly sel_ext_addr (bit 7) must be low!
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; The other bits in port ALSO need to be low
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; except for acq_clk (bit 3). It needs to be high.
091        â”‚â”‚â”‚â”‚â”‚â”‚                       ; PSD chips put out new analog outputs when acq_clk goes high!
           â”‚â”‚â”‚â”‚â”‚â”‚
091  01000 â”‚â”‚â”‚â”‚â”‚â•°â”€â–¶                     load op, 00
092  05008 â”‚â”‚â”‚â”‚â”‚                        or op, 08                      ; Set bit 3				; acq clk for PSD 0 high
093  2D005 â”‚â”‚â”‚â”‚â”‚                        output op, PSD0_OPORT
094  20037 â•°â”€â”€â”€â”€â”€â”€â¤™                     call dly_us                    ; Give analog outputs chance to settle
           â”‚â”‚â”‚â”‚â”‚                        ;
095        â”‚â”‚â”‚â”‚â”‚                        ; Set up our masks
           â”‚â”‚â”‚â”‚â”‚                        ;
095  01801 â”‚â”‚â”‚â”‚â”‚                        load adc_clk_mask, 00000001'b
096  01904 â”‚â”‚â”‚â”‚â”‚                        load adc_conv_mask, 00000100'b
           â”‚â”‚â”‚â”‚â”‚
097        â”‚â”‚â”‚â”‚â”‚                        ; Perform adc conversion
           â”‚â”‚â”‚â”‚â”‚
097  2003B â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_conv
           â”‚â”‚â”‚â”‚â”‚
098        â”‚â”‚â”‚â”‚â”‚                        ; Read PSD address
           â”‚â”‚â”‚â”‚â”‚
098  09D02 â”‚â”‚â”‚â”‚â”‚                        input addr_reg, PSD0_IPORT
           â”‚â”‚â”‚â”‚â”‚
099        â”‚â”‚â”‚â”‚â”‚                        ; We need to send A, B, C, T off to FIFO
           â”‚â”‚â”‚â”‚â”‚
099  2004F â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_to_fifo
           â”‚â”‚â”‚â”‚â”‚
09A        â”‚â”‚â”‚â”‚â”‚                        ; Bring acq_clk low (acq_clk is bit 3)
09A        â”‚â”‚â”‚â”‚â”‚                        ; Resets the hit and active registers
           â”‚â”‚â”‚â”‚â”‚
09A  030F7 â”‚â”‚â”‚â”‚â”‚                        and op, f7                     ; Clear bit 3			 	; Bring acq clk low
09B  2D005 â”‚â”‚â”‚â”‚â”‚                        output op, PSD0_OPORT
           â”‚â”‚â”‚â”‚â”‚
09C        â”‚â”‚â”‚â”‚â”‚                        ; Check token out from PSD 0 (token_out is bit 1)
09C        â”‚â”‚â”‚â”‚â”‚                        ; If token_out is HIGH then contine else we are done
           â”‚â”‚â”‚â”‚â”‚
09C  09102 â”‚â”‚â”‚â”‚â”‚                        input ip, PSD0_IPORT
09D  0D102 â”‚â”‚â”‚â”‚â”‚                        test ip, 02                    ; Test bit 1
09E  3607E â”‚â”‚â”‚â•°â”€â”€â”€â¤™                     jump NZ, .loop
09F  220C4 â”‚â”‚â”‚â•­â”€â”€â”€â¤™                     jump .done
           â”‚â”‚â”‚â”‚â”‚
0A0        â”‚â”‚â”‚â”‚â”‚                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
0A0        â”‚â”‚â”‚â”‚â”‚                        ;  Only PSD 1 needs attention
0A0        â”‚â”‚â”‚â”‚â”‚                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           â”‚â”‚â”‚â”‚â”‚
0A0        â”‚â”‚â”‚â”‚â”‚                 .psd1:
           â”‚â”‚â”‚â”‚â”‚
0A0        â”‚â”‚â”‚â”‚â”‚                        ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
0A0        â”‚â”‚â”‚â”‚â”‚                        ; Notablly sel_ext_addr (bit 7) must be low!
0A0        â”‚â”‚â”‚â”‚â”‚                        ; The other bits in port ALSO need to be low
0A0        â”‚â”‚â”‚â”‚â”‚                        ; except for acq_clk (bit 3). It needs to be high.
           â”‚â”‚â”‚â”‚â”‚
0A0  01000 â”‚â”‚â”‚â”‚â•°â”€â”€â–¶                     load op, 00
0A1  05008 â”‚â”‚â”‚â”‚                         or op, 08                      ; Set bit 3
0A2  2D006 â”‚â”‚â”‚â”‚                         output op, PSD1_OPORT
0A3  20037 â•°â”€â”€â”€â”€â”€â”€â¤™                     call dly_us
           â”‚â”‚â”‚â”‚
0A4        â”‚â”‚â”‚â”‚                         ; Set up our masks
           â”‚â”‚â”‚â”‚
0A4  01802 â”‚â”‚â”‚â”‚                         load adc_clk_mask, 00000010'b
0A5  01908 â”‚â”‚â”‚â”‚                         load adc_conv_mask, 00001000'b
           â”‚â”‚â”‚â”‚
0A6        â”‚â”‚â”‚â”‚                         ; Perform adc conversion
           â”‚â”‚â”‚â”‚
0A6  2003B â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_conv
           â”‚â”‚â”‚â”‚
0A7        â”‚â”‚â”‚â”‚                         ; Read PSD address
           â”‚â”‚â”‚â”‚
0A7  09103 â”‚â”‚â”‚â”‚                         input ip, PSD1_IPORT
           â”‚â”‚â”‚â”‚
0A8        â”‚â”‚â”‚â”‚                         ; We need to send A, B, C, T off to FIFO
           â”‚â”‚â”‚â”‚
0A8  2004F â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_to_fifo
           â”‚â”‚â”‚â”‚
0A9        â”‚â”‚â”‚â”‚                         ; Bring acq_clk low (acq_clk is bit 3)
0A9        â”‚â”‚â”‚â”‚                         ; Resets the hit and active registers
           â”‚â”‚â”‚â”‚
0A9  030F7 â”‚â”‚â”‚â”‚                         and op, f7                     ; Clear bit 3
0AA  2D006 â”‚â”‚â”‚â”‚                         output op, PSD1_OPORT
           â”‚â”‚â”‚â”‚
0AB        â”‚â”‚â”‚â”‚                         ; Check token out from PSD (token_out is bit 1)
0AB        â”‚â”‚â”‚â”‚                         ; If token_out is HIGH then contine else we are done
           â”‚â”‚â”‚â”‚
0AB  09103 â”‚â”‚â”‚â”‚                         input ip, PSD1_IPORT
0AC  0D102 â”‚â”‚â”‚â”‚                         test ip, 02                    ; Test bit 1
0AD  3607E â”‚â•°â”€â”€â”€â”€â”€â¤™                     jump NZ, .loop
0AE  220C4 â”‚ â”‚â”‚ â•­â”€â¤™                     jump .done
           â”‚ â”‚â”‚ â”‚
0AF        â”‚ â”‚â”‚ â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
0AF        â”‚ â”‚â”‚ â”‚                       ;  Both PSD chips needs attention
0AF        â”‚ â”‚â”‚ â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           â”‚ â”‚â”‚ â”‚
0AF        â”‚ â”‚â”‚ â”‚                .both:
           â”‚ â”‚â”‚ â”‚
0AF        â”‚ â”‚â”‚ â”‚                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
0AF        â”‚ â”‚â”‚ â”‚                       ; Notablly sel_ext_addr (bit 7) must be low!
0AF        â”‚ â”‚â”‚ â”‚                       ; The other bits in port ALSO need to be low
0AF        â”‚ â”‚â”‚ â”‚                       ; except for acq_clk (bit 3). It needs to be high.
           â”‚ â”‚â”‚ â”‚
0AF  01000 â”‚ â•°â”€â”€â”€â”€â–¶                     load op, 00
0B0  05008 â”‚  â”‚ â”‚                       or op, 08                      ; Set bit 3
0B1  2D005 â”‚  â”‚ â”‚                       output op, PSD0_OPORT
0B2  2D006 â”‚  â”‚ â”‚                       output op, PSD1_OPORT
0B3  20037 â•°â”€â”€â”€â”€â”€â”€â¤™                     call dly_us                    ; Wait for PSD analog outputs to settle
           â”‚  â”‚ â”‚
0B4        â”‚  â”‚ â”‚                       ; Set up our masks
           â”‚  â”‚ â”‚
0B4  01803 â”‚  â”‚ â”‚                       load adc_clk_mask, 00000011'b
0B5  0190C â”‚  â”‚ â”‚                       load adc_conv_mask, 00001100'b
           â”‚  â”‚ â”‚
0B6        â”‚  â”‚ â”‚                       ; Perform adc conversion
           â”‚  â”‚ â”‚
0B6  2003B â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_conv
           â”‚  â”‚ â”‚
0B7        â”‚  â”‚ â”‚                       ; Read PSD 0 address
           â”‚  â”‚ â”‚
0B7  09702 â”‚  â”‚ â”‚                       input adc_reg, PSD0_IPORT
           â”‚  â”‚ â”‚
0B8        â”‚  â”‚ â”‚                       ; We need to send A, B, C, T off to FIFO
           â”‚  â”‚ â”‚
0B8  2004F â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_to_fifo
           â”‚  â”‚ â”‚
0B9        â”‚  â”‚ â”‚                       ; Read PSD 1 address
           â”‚  â”‚ â”‚
0B9  09703 â”‚  â”‚ â”‚                       input adc_reg, PSD1_IPORT
           â”‚  â”‚ â”‚
0BA        â”‚  â”‚ â”‚                       ; We need to send A, B, C, T off to FIFO
           â”‚  â”‚ â”‚
0BA  2004F â•°â”€â”€â”€â”€â”€â”€â¤™                     call adc_to_fifo
           â”‚  â”‚ â”‚
0BB        â”‚  â”‚ â”‚                       ; Bring acq_clk low (acq_clk is bit 3)
0BB        â”‚  â”‚ â”‚                       ; Resets the hit and active registers
           â”‚  â”‚ â”‚
0BB  030F7 â”‚  â”‚ â”‚                       and op, f7                     ; Clear bit 3
0BC  2D005 â”‚  â”‚ â”‚                       output op, PSD0_OPORT
0BD  2D006 â”‚  â”‚ â”‚                       output op, PSD1_OPORT
           â”‚  â”‚ â”‚
0BE        â”‚  â”‚ â”‚                       ; Check token out from PSD (token_out is bit 1)
0BE        â”‚  â”‚ â”‚                       ; If token_out is HIGH then contine else we are done
           â”‚  â”‚ â”‚
0BE  09102 â”‚  â”‚ â”‚                       input ip, PSD0_IPORT
0BF  0D102 â”‚  â”‚ â”‚                       test ip, 02                    ; Test bit 1
0C0  3607E â•°â”€â”€â”€â”€â”€â”€â¤™                     jump NZ, .loop
           â”‚  â”‚ â”‚
0C1  09103 â”‚  â”‚ â”‚                       input ip, PSD1_IPORT
0C2  0D102 â”‚  â”‚ â”‚                       test ip, 02                    ; Test bit 1
0C3  3607E â•°â”€â”€â”€â”€â”€â”€â¤™                     jump NZ, .loop
           â”‚  â”‚ â”‚
0C4        â”‚  â”‚ â”‚                       ; We are DONE!
           â”‚  â”‚ â”‚
0C4        â”‚  â”‚ â”‚                .done:
           â”‚  â”‚ â”‚
0C4        â”‚  â”‚ â”‚                       ; (1) Need to send one more word to FIFO
0C4        â”‚  â”‚ â”‚                       ; Bit 0 of STATUS_IPORT is the tready signal
0C4        â”‚  â”‚ â”‚                       ; When we send this last word we need to write to the LAST_PORT
0C4        â”‚  â”‚ â”‚                       ; So we can just ignore the last word sent on microblaze side of things
           â”‚  â”‚ â”‚
0C4  09100 â•°â”€â”€â”´â”€â”´â”¬â–¶                     input ip, STATUS_IPORT
0C5  0D101 â”‚     â”‚                      test ip, 01                    ; Test bit 0
0C6  320C4 â”‚     â•°â¤™                     jump Z, .done
           â”‚
0C7        â”‚                            ; What we write to LAST_PORT makes no difference
           â”‚
0C7  2D2FF â”‚                            output scr0, LAST_PORT
           â”‚
0C8        â”‚                            ; (2)
0C8        â”‚                            ; Bring token_in (bit 6) high for bit PSD0 and PSD1
           â”‚                            ;
0C8  05040 â”‚                            or op, 40                      ; Set bit 6
0C9  2D005 â”‚                            output op, PSD0_OPORT
0CA  2D006 â”‚                            output op, PSD1_OPORT
0CB        â”‚                            ; (3)
0CB        â”‚                            ; Unset the busy flag (busy flag is same as LED 1)
           â”‚                            ;
0CB  03BFD â”‚                            and led_reg, fd                ; Clear bit 1
0CC  2DB00 â”‚                            output led_reg, LED_PORT
           â”‚
0CD  25000 â”‚                            return
           â”‚
0CE        â”‚                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0CE        â”‚                            ; ******* NUCLEAR PHYSICS PROGRAM *********
           â”‚                            ;
0CE        â”‚                            ; We sit in a tight loop waiting for take_event to go HIGH
0CE        â”‚                            ; When posedge take_event comes along we call get_event routine.
           â”‚                            ;
0CE        â”‚                            ; We stay in get_event untill all PSD channels are read out and
0CE        â”‚                            ; sent back to microblaze using the streamin FIFO.
           â”‚                            ;
0CE        â”‚                            ; We then wait for take_event to go LOW. We then go back and
0CE        â”‚                            ; sit in tight loop waiting for next event!
           â”‚                            ;
0CE        â”‚                            ; led[0] is lit when take_event is high
0CE        â”‚                            ; led[1] is lit when we are actually in the get_event subroutine
0CE        â”‚                            ; led[1] is also the busy bit i.e we are in get_event!
           â”‚                            ;
0CE        â”‚                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0CE        â”‚                   nuclear:
0CE  20001 â•°â”€â”€â”€â”€â”€â”€â–¶                     call init
           â”‚
0CF        â”‚                            ; Wait for take_event to go HIGH (Turn LED0 ON)
0CF        â”‚                            ; Take event is bit 1 of the STATUS_IPORT
           â”‚
0CF  09100 â”‚    â•­â”¬â–¶             .wait0: input ip, STATUS_IPORT
0D0  0D102 â”‚    â”‚â”‚                      test ip, 02                    ; Test bit 1
0D1  320CF â”‚    â”‚â•°â¤™                     jump Z, .wait0
           â”‚    â”‚
0D2        â”‚    â”‚                       ; First thing we need to do is bring veto_reset
0D2        â”‚    â”‚                       ; high on PSD chips before they auto_reset
0D2        â”‚    â”‚                       ; Keep force_reset low
           â”‚    â”‚
0D2  01000 â”‚    â”‚                       load op, 00
0D3  05002 â”‚    â”‚                       or op, 02                      ; Set bit 1
0D4  2D007 â”‚    â”‚                       output op, MISC_OPORT
           â”‚    â”‚
0D5        â”‚    â”‚                       ; Turn led[0] on (bit 0 of LED_PORT)
0D5        â”‚    â”‚                       ; led[0] is turned on only when we are in take event
           â”‚    â”‚
0D5  05B01 â”‚    â”‚                       or led_reg, 01                 ; Set bit 0
0D6  2DB00 â”‚    â”‚                       output led_reg, LED_PORT
           â”‚    â”‚
0D7        â”‚    â”‚                       ; Call the get_event routine
0D7        â”‚    â”‚                       ; Returns once all hit channels are read out!
0D7        â”‚    â”‚                       ; While we are in get_event the busy bit is set
           â”‚    â”‚
0D7        â”‚    â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0D7  2007C â•°â”€â”€â”€â”€â”€â”€â¤™                     call get_event
0D8        â”‚    â”‚                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           â”‚    â”‚
0D8        â”‚    â”‚                       ; De-assert veto_reset
0D8        â”‚    â”‚                       ; Keep force_reset low
           â”‚    â”‚
0D8  01000 â”‚    â”‚                       load op, 00
0D9  2D007 â”‚    â”‚                       output op, MISC_OPORT
           â”‚    â”‚
0DA        â”‚    â”‚                       ; Wait for take_event (bit 1 of STATUS_IPORT)
           â”‚    â”‚
0DA  09100 â”‚    â”‚â•­â–¶             .wait1: input ip, STATUS_IPORT
0DB  0D102 â”‚    â”‚â”‚                      test ip, 02                    ; Test bit 1
0DC  360DA â”‚    â”‚â•°â¤™                     jump NZ, .wait1
           â”‚    â”‚
0DD        â”‚    â”‚                       ; Force a reset (about 1 usec long)
0DD        â”‚    â”‚                       ; Shouldnâ€™t be necessary but doesnâ€™t hurt
           â”‚    â”‚
0DD  20030 â•°â”€â”€â”€â”€â”€â”€â¤™                     call force_reset
                â”‚
0DE             â”‚                       ; Turn led[0] off!
                â”‚
0DE  03BFE      â”‚                       and led_reg, fe                ; Clear bit 0
0DF  2DB00      â”‚                       output led_reg, LED_PORT
                â”‚
0E0             â”‚                       ; Go back and wait for the next event
                â”‚
0E0  220CF      â•°â”€â¤™                     jump .wait0

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       â•­â–¶                     returni disable
                 â”‚                      ;
3FF              â”‚                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              â”‚                      ; Interrupt vector is stored at location $3FF
3FF              â”‚                      ; We will jump to our ISR routine
3FF              â”‚                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 â”‚
3FF              â”‚                      address 3FF
3FF  22380       â•°â¤™                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/gengel/VIVADO_FPGA/Trenz-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    MISC_OPORT         07     pico_program.psm
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
    PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      0A
    datestamp_month    02
    datestamp_year     19
    timestamp_hours    0F
    timestamp_minutes  16
    timestamp_seconds  10


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "10 Feb 2025"
    timestamp$       "15:22:16"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv               03B   pico_program.psm
    adc_conv.clk_loop      044   pico_program.psm
    adc_to_fifo            04F   pico_program.psm
    adc_to_fifo.loop       05D   pico_program.psm
    adc_to_fifo.skip       06D   pico_program.psm
    adc_to_fifo.wait_trdy  06E   pico_program.psm
    dly_us                 037   pico_program.psm
    dly_us.wait_us         038   pico_program.psm
    force_reset            030   pico_program.psm
    get_event              07C   pico_program.psm
    get_event.both         0AF   pico_program.psm
    get_event.done         0C4   pico_program.psm
    get_event.err          090   pico_program.psm
    get_event.loop         07E   pico_program.psm
    get_event.or0          084   pico_program.psm
    get_event.or1          088   pico_program.psm
    get_event.psd0         091   pico_program.psm
    get_event.psd1         0A0   pico_program.psm
    init                   001   pico_program.psm
    my_isr                 380   pico_program.psm
    nuclear                0CE   pico_program.psm
    nuclear.wait0          0CF   pico_program.psm
    nuclear.wait1          0DA   pico_program.psm
 *  origin                 000   pico_program.psm
 *  tdc_reg_ld             02F   pico_program.psm
 *  tdc_ser                022   pico_program.psm
    tdc_ser.clk_loop       024   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          5
   ADDCY        -
   AND          9
   CALL         16
   CALL@        -
   COMPARE      5
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        4
   HWBUILD      -
   INPUT        15
   JUMP         26
   JUMP@        -
   LOAD         41
   LOAD&RETURN  -
   OR           19
   OUTPUT       40
   OUTPUTK      -
   REGBANK      -
   RETURN       8
   RETURNI      1
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          3
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        5
   SUB          7
   SUBCY        -
   TEST         12
   TESTCY       -
   XOR          3
