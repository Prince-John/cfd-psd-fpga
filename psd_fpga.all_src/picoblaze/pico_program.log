Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2024-11-10T14:48:18
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 135
  Memory locations available: 3961
  Scratchpad size: 256


Assembly listing
----------------
                                        ;
000                                     ; Test program for our picoblaze
000                                     ; For starters just blink led connected to bit 0
000                                     ; of output port #0
                                        ;
000                                     ; Keep adding until is does everything we need!
                                        ;
000                                     ; 31-Oct-2024
                                        ;

000                                     ; ********************************************
000                                     ; Output ports (we have 8 real output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast signals
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED0
000                                     ; 1		LED1 (also the busy bit!)

000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Board id
000                                     ; type = 10 ---> TDC data (lower 24 bits)
000                                     ; type = 11 ---> TDC data (upper 24 bits)

000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; Give more desciptive names to some of our registers
                                        ;
000                                     namereg s0, op                 ; Output port register
000                                     namereg s1, ip                 ; Input port register
000                                     namereg s2, scr0               ; Scratchpad register 0
000                                     namereg s3, scr1               ; Scratchpad register 1
000                                     namereg s4, scr2               ; Scratchpad register 2
000                                     namereg s5, cnt                ; Used for counting "things"
000                                     namereg s6, dreg               ; Used in delay_1us routine
000                                     namereg s7, adc_reg            ; Used by adc routine (global)
000                                     namereg s8, adc_mask           ; Used by adc routine (global)
000                                     namereg s9, word_cntr          ; Keeps track of word count (global)
000                                     namereg sa, led_reg            ; Global variable that constains state of LEDs (global)

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     constant BOARD_ID, 00


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ;********************************************
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ;********************************************
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000

000  2206A ╭──────⤙             origin: jump adc_test
001        │                            ; origin:  	jump      	 nuclear
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
001        │                            ; Initialize the stack pointer, SP
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ; Read the board id and save it to scratchpad memory location 0
           │
002  01201 │                            load scr0, BOARD_ID_PORT
003  2F200 │                            store scr0, BOARD_ID
           │
004        │                            ; Clear the output port registers
           │
004  01200 │                            load scr0, 00
005  2D200 │                            output scr0, LED_PORT
006  2D202 │                            output scr0, DATA_TAG_PORT
007  2D203 │                            output scr0, TDC_DATA_PORT
008  2D204 │                            output scr0, TDC_CTL_PORT
           │
009        │                            ; Clear some registers
           │
009  01000 │                            load op, 00
00A  01100 │                            load ip, 00
00B  01500 │                            load cnt, 00
00C  01600 │                            load dreg, 00
00D  01700 │                            load adc_reg, 00
00E  01800 │                            load adc_mask, 00
00F  01900 │                            load word_cntr, 00
010  01A00 │                            load led_reg, 00
           │
011        │                            ; Reset the ADC shift registers
011        │                            ; Bring reset bit high in adc_reg and then back low
011        │                            ; Bit 7 of adc_reg is the reset adc registers bit
011        │                            ; Clock and conv signals low
011        │                            ; Mux selects (3’b000) choosing adc reg for PSD0 A integrator
011        │                            ; Pulse the adc reg reset line
           │
011  05780 │                            or adc_reg, 80                 ; Set bit 7
012  2D701 │                            output adc_reg, ADC_CTL_PORT
013  0377F │                            and adc_reg, 7f                ; Clear bit 7
014  2D701 │                            output adc_reg, ADC_CTL_PORT
           │
015        │                            ; Make sure that tokens into the PSD chips are HIGH
015        │                            ; token_in for the PSD ports is bit 6
           │
015  01200 │                            load scr0, 00
016  05240 │                            or scr0, 40                    ; Set bit 6
017  2D205 │                            output scr0, PSD0_OPORT
018  2D206 │                            output scr0, PSD1_OPORT
           │
019        │                            ; Done so return
           │
019  25000 │                            return
           │
01A        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
01A        │                            ; Subroutine Name: dly_us
           │                            ;
01A        │                            ; Delay of 1 usec
01A        │                            ; Delay is [(4 * dreg) + 6] / Fclk
01A        │                            ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │                            ;
01A        │                            ; Routine uses dreg and does not restore it
           │                            ;
01A        │                            ; 24 (i.e $18) assumes a 100 MHz clock
01A        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
01A        │                    dly_us:
01A  01618 ╭───┬┬─▶                     load dreg, 24'd
01B  19601 │   ││╭▶           .wait_us: sub dreg, 01
01C  3601B │   ││╰⤙                     jump NZ, .wait_us
01D  25000 │   ││                       return
           │   ││
01E        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
01E        │   ││                       ; Subroutine Name: adc_conv_0
           │   ││                       ;
01E        │   ││                       ; Uses the cnt register to count clock pulses
01E        │   ││                       ; but restores cnt register before returning
01E        │   ││                       ; Uses adc_reg bot does not restores it
01E        │   ││                       ; Uses scr0 but does not restore it
01E        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
01E        │   ││           adc_conv_0:
           │   ││
01E        │   ││                       ; Save cnt register
           │   ││
01E  2E5F0 │╭─┬───▶                     store cnt, (SP)                ; Push
01F  19F01 ││ │││                       sub SP, 01
           ││ │││
           ││ │││
020        ││ │││                       ; Bring conv high
020        ││ │││                       ; Bit 2 is conv_0 signal
           ││ │││
020  05704 ││ │││                       or adc_reg, 04                 ; Set bit 2
021  2D701 ││ │││                       output adc_reg, ADC_CTL_PORT
           ││ │││
022        ││ │││                       ; Wait for 2 usec
           ││ │││
022  2001A ││ ││╰─⤙                     call dly_us
023  2001A ││ │╰──⤙                     call dly_us
           ││ │
024        ││ │                         ; Bring conv low
024        ││ │                         ; Bit 2 is conv_0 signal
           ││ │
024  037FB ││ │                         and adc_reg, fb                ; Clear bit 2
025  2D701 ││ │                         output adc_reg, ADC_CTL_PORT
           ││ │
026        ││ │                         ; Bit 0 of ADC_CTL_PORT is adc_sclk for psd0
           ││ │
026  01801 ││ │                         load adc_mask, 00000001'b
           ││ │
027        ││ │                         ; Apply 16 clock pulses (takes about 2 usec)
           ││ │
027  01510 ││ │                         load cnt, 16'd
028  06780 ││ │  ╭▶          .clk_loop: xor adc_reg, adc_mask
029  2D701 ││ │  │                      output adc_reg, ADC_CTL_PORT
02A  06780 ││ │  │                      xor adc_reg, adc_mask
02B  00EE0 ││ │  │                      load se, se                    ; NOP
02C  00EE0 ││ │  │                      load se, se                    ; NOP
02D  2D701 ││ │  │                      output adc_reg, ADC_CTL_PORT
02E  19501 ││ │  │                      sub cnt, 01
02F  36028 ││ │  ╰⤙                     jump NZ, .clk_loop
           ││ │
030        ││ │                         ; Restore cnt register
           ││ │
030  11F01 ││ │                  .loc1: add SP, 01                     ; Pop
031  0A5F0 ││ │                         fetch cnt, (SP)
           ││ │
           ││ │
032  25000 ││ │                         return
           ││ │
033        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
033        ││ │                         ; Name: adc_to_fifo
           ││ │                         ;
033        ││ │                         ; Each time this routine is called, it sends the A, B, C, T
033        ││ │                         ; adc values to the microblaze FIFO
033        ││ │                         ; The values are 16-bits (byte0, byte1) but the FIFO transfer is 32 bits
033        ││ │                         ; byte 2 will containt board id and byte3 will contain a tag
           ││ │                         ;
033        ││ │                         ; Tag format:
           ││ │                         ;
033        ││ │                         ; 0		psd addr bit 0
033        ││ │                         ; 1		psd addr bit 1
033        ││ │                         ; 2		psd addr bit 2
033        ││ │                         ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
033        ││ │                         ; 4		bit 0 of sc
033        ││ │                         ; 5		bit 1 of sc
033        ││ │                         ; 6		bit 0 of type
033        ││ │                         ; 7		bit 1 of type
           ││ │
033        ││ │                         ; type = 00 ---> ADC data
033        ││ │                         ; type = 01 ---> Board id
033        ││ │                         ; type = 10 ---> TDC data (lower 24 bits)
033        ││ │                         ; type = 11 ---> TDC data (upper 24 bits)
           ││ │
033        ││ │                         ; sc = 00 -----> integrator A
033        ││ │                         ; sc = 01 -----> integrator B
033        ││ │                         ; sc = 10 -----> integrator C
033        ││ │                         ; sc = 11 -----> time
033        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││ │
033        ││ │            adc_to_fifo:
           ││ │                         ;
033        ││ │                         ; When we enter the routine, scr0 should contain the psd_address
033        ││ │                         ; Since we just read the psd port
033        ││ │                         ; Write out data tag
           ││ │                         ;
033        ││ │                         ; 0		psd0_or
033        ││ │                         ; 1		psd0_token_out
033        ││ │                         ; 2		psd0_acq_ack
033        ││ │                         ; 3		psd0_addr_out0
033        ││ │                         ; 4		psd0_addr_out1
033        ││ │                         ; 5		psd0_addr_out2
033        ││ │                         ; 6     0 (psd chip 0)
           ││ │
033        ││ │                         ; Shift left 3 places so we will have lower nybble
033        ││ │                         ; Then we can twiddle bits 4 and 5
           ││ │
033  14206 ││ │╭──▶                     sl0 scr0
034  14206 ││ ││                        sl0 scr0
035  14206 ││ ││                        sl0 scr0
           ││ ││
           ││ ││
036        ││ ││                        ; Send A integrator
036        ││ ││                        ; adc_mux_sel is bits 4, 5, 6 of the ADC_CTL_PORT
           ││ ││
036  01700 ││ ││                        load adc_reg, 00
037  05700 ││ ││                        or adc_reg, 00                 ; 0 << 4
038  2D701 ││ ││                        output adc_reg, ADC_CTL_PORT
           ││ ││
039        ││ ││                        ; We have complete 8-bit data tag in scr0 at this point
           ││ ││
039  2D002 ││ ││                        output op, DATA_TAG_PORT
           ││ ││
03A        ││ ││                        ; Wait for ’tready’ signal to be active
           ││ ││                        ;
03A  09100 ││ ││ ╭▶         .wait_trdy: input ip, STATUS_IPORT
           ││ ││ │
03B        ││ ││ │                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           ││ ││ │
03B  0D101 ││ ││ │                      test ip, 01                    ; Test bit 0
03C  3203A ││ ││ ╰⤙                     jump Z, .wait_trdy
           ││ ││
03D        ││ ││                        ; When FIFO is ready, send data (what we send to vaild port makes no diff)
           ││ ││
03D  2D2FE ││ ││                        output scr0, VALID_PORT
           ││ ││
03E  25000 ││ ││                        return
           ││ ││
03F        ││ ││                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03F        ││ ││                        ; Name: get_event_0
           ││ ││                        ;
03F        ││ ││                        ; For time being only support single psd chip (psd 0)
03F        ││ ││                        ; Routine to get a nuclear physics event
03F        ││ ││                        ; Aquires data from the 4 ADCS (A, B, C, T)
           ││ ││                        ;
03F        ││ ││                        ; Uses op and ip and does not restore it
           ││ ││                        ;
03F        ││ ││                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││ ││
03F        ││ ││           get_event_0:
           ││ ││
03F        ││ ││                        ; Set the busy bit (also LED1!)
03F        ││ ││                        ; Bit 1 of LED_PORT is LED1 and also the busy bit
           ││ ││
03F  05A02 ││╭────▶                     or led_reg, 02                 ; Set bit 1
040  2DA00 │││││                        output led_reg, LED_PORT
           │││││
041        │││││                        ; Check the OR out of PSD 0 (bit 0)
           │││││
041  09102 │││││                        input ip, PSD0_IPORT
042  0D101 │││││                        test ip, 01                    ; Test bit 0
043  32050 │││││╭─⤙                     jump Z, .done
           ││││││
044        ││││││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
           ││││││
044  01000 ││││││╭▶              .loop: load op, 00
045  2D005 │││││││                      output op, PSD0_OPORT
           │││││││
046        │││││││                      ; Bring acq_clk high (acq_clk is bit 3 of PSD0_PORT)
           │││││││
046  05008 │││││││                      or op, 08                      ; Set bit 3
047  2D005 │││││││                      output op, PSD0_OPORT
           │││││││
048        │││││││                      ; Perform ADC conversion
           │││││││
048  2001E │││╰───⤙                     call adc_conv_0
           │││ │││
049        │││ │││                      ; Read PSD addresses (use scr0 which adc_to_fifo will read)
           │││ │││
049  09202 │││ │││                      input scr0, PSD0_IPORT
           │││ │││
04A        │││ │││                      ; We need to send the ADC registers off to the FIFO
           │││ │││
04A  20033 │││ ╰──⤙                     call adc_to_fifo
           │││  ││
04B        │││  ││                      ; Bring acq_clk low (acq_clk is bit 3)
           │││  ││
04B  030F7 │││  ││                      and op, f7                     ; Clear bit 3
04C  2D005 │││  ││                      output op, PSD0_OPORT
           │││  ││
04D        │││  ││                      ; Check token_out from PSD (token_out is bit 1)
04D        │││  ││                      ; If token_out high then continue else we are done
           │││  ││
04D  09102 │││  ││                      input ip, PSD0_IPORT
04E  0D102 │││  ││                      test ip, 02                    ; Test bit 1
04F  36044 │││  │╰⤙                     jump NZ, .loop
050        │││  │                .done:
           │││  │
050        │││  │                       ; Bring token_in high
           │││  │
050  05040 │││  ╰─▶                     or op, 40                      ; Set bit 6
051  2D005 │││                          output op, PSD0_OPORT
           │││
052        │││                          ; Unset the busy flag (busy flag is same as LED1)
           │││
052  03AFD │││                          and led_reg, fd                ; Clear bit 1
053  2DA00 │││                          output led_reg, LED_PORT
           │││
054  25000 │││                          return
           │││
055        │││                          ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
055        │││                          ; Name: data_acq
           │││                          ;
055        │││                          ; Routine to get a data_acq event
055        │││                          ; word_cntr keeps track of where we are in the packet
055        │││                          ; For testing we are just getting 50 ADC samples
055        │││                          ; NOTE: ip and op are  not restored
055        │││                          ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │││
055        │││                data_acq:
           │││
055        │││                          ; Select adc T subchannel of PSD0 to drive FIFO
055        │││                          ; Mux sel for ADC T for chan 0 is 2’b011
055        │││                          ; adc_mux_sel is bits 4, 5, 6 of the ADC_CTL_PORT
           │││
055  01700 │││╭───▶                     load adc_reg, 00
056  05730 ││││                         or adc_reg, 30                 ; 3 << 4
057  2D701 ││││                         output adc_reg, ADC_CTL_PORT
           ││││                         ;
058        ││││                         ; Write out the data identifier
058        ││││                         ; 00 11 0111  (adc T chan7)
           ││││
058  01037 ││││                         load op, 00110111'b
059  2D002 ││││                         output op, DATA_TAG_PORT
           ││││
05A        ││││                         ; Wait for 20 usec i.e. our sampling period
           ││││
05A  01514 ││││╭──▶            .delay0: load cnt, 20'd
05B  2001A ╰─────┬⤙            .delay1: call dly_us
05C  19501 │││││ │                      sub cnt, 01
05D  3605B │││││ ╰⤙                     jump NZ, .delay1
           │││││
05E        │││││                        ; Perform a conversion
           │││││
05E  2001E │╰─────⤙                     call adc_conv_0
           │ │││
05F        │ │││                        ; Wait for ’tready’ signal to be active
           │ │││                        ;
05F  09100 │ │││ ╭▶         .wait_trdy: input ip, STATUS_IPORT
           │ │││ │
060        │ │││ │                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │ │││ │
060  0D101 │ │││ │                      test ip, 01                    ; Test bit 0
061  3205F │ │││ ╰⤙                     jump Z, .wait_trdy
           │ │││                        ;
062        │ │││                        ; Either assert just ’tvalid’ or both ’tvalid’ and ’tlast’
062        │ │││                        ; What we actually write to the VALID or LAST port is irrelevant.
062        │ │││                        ; When we write to LAST port, both ’tvalid’ and ’tlast’ asserted.
062        │ │││                        ; When packet_cntr contains $01 the write to LAST port
           │ │││
062  1D901 │ │││                        compare word_cntr, 01
063  36066 │ │││╭─⤙                     jump NZ, .loc0
064  2D2FF │ ││││                       output scr0, LAST_PORT
065  22067 │ ││││╭⤙                     jump .loc1
066  2D2FE │ │││╰─▶              .loc0: output scr0, VALID_PORT
067  19901 │ │││ ╰▶              .loc1: sub word_cntr, 01
068  3605A │ ││╰──⤙                     jump NZ, .delay0
           │ ││
069  25000 │ ││                         return
           │ ││
06A        │ ││                         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
06A        │ ││                         ; ******* ADC TEST PROGRAM *********
           │ ││                         ;
06A        │ ││                         ; Let’s grab a packet whenever we see take_event go high
06A        │ ││                         ; When take_event goes high, turn LED0 on
06A        │ ││                         ; When take event goes low, turn LED0 off
06A        │ ││                         ; LED0 is bit 0 of LED_PORT
06A        │ ││                         ; LED1 is bit 1 of LED_PORT
06A        │ ││                         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           │ ││
06A  20001 ╰──────▶           adc_test: call init
           │ ││
06B        │ ││                         ; Wait for take_event to go low
           │ ││
06B  09100 │ ││ ╭┬▶          adc_test0: input ip, STATUS_IPORT
06C  0D102 │ ││ ││                      test ip, 02                    ; Test bit 1
06D  3606B │ ││ │╰⤙                     jump NZ, adc_test0
           │ ││ │
06E        │ ││ │                       ; Take event is low so turn LED0 off
           │ ││ │
06E  03AFE │ ││ │                       and led_reg, fe                ; Clear bit 0
06F  2DA00 │ ││ │                       output led_reg, LED_PORT
           │ ││ │
070        │ ││ │                       ; Wait for take_event to go high
           │ ││ │
070  09100 │ ││ │╭▶          adc_test1: input ip, STATUS_IPORT
071  0D102 │ ││ ││                      test ip, 02                    ; Test bit 1
072  32070 │ ││ │╰⤙                     jump Z, adc_test1
           │ ││ │
073        │ ││ │                       ; Take event is high so turn LED0 on
           │ ││ │
073  05A01 │ ││ │                       or led_reg, 01                 ; Set bit 0
074  2DA00 │ ││ │                       output led_reg, LED_PORT
           │ ││ │
075        │ ││ │                       ; word_cntr keeps track of where we are in the packet creation process
075        │ ││ │                       ; load word_cntr with how many words we want in our packet
           │ ││ │
075  01932 │ ││ │                       load word_cntr, 50'd
           │ ││ │
076        │ ││ │                       ; Don’t return until we have captured a complete packet and sent
076        │ ││ │                       ; the packet to the uBlaze using streaming FIFO
           │ ││ │
076  20055 │ │╰───⤙                     call data_acq
           │ │  │
077        │ │  │                       ; Go back to top of loop and do it all over again!
           │ │  │
077  2206B │ │  ╰─⤙                     jump adc_test0
           │ │
078        │ │                          ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
078        │ │                          ; ******* Nuclear Physics Program *********
           │ │                          ;
078        │ │                          ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
078        │ │                 nuclear:
078  20001 ╰──────⤙                     call init
             │
079          │                          ; Wait for take_event to go HIGH (Turn LED0 ON)
079          │                          ; Take event is bit 1 of the STATUS_IPORT
             │
079  09100   │  ╭┬▶           nuclear0: input ip, STATUS_IPORT
07A  0D102   │  ││                      test ip, 02                    ; Test bit 1
07B  32079   │  │╰⤙                     jump Z, nuclear0
07C  05A01   │  │                       or led_reg, 01                 ; Set bit 0
07D  2DA00   │  │                       output led_reg, LED_PORT
             │  │
07E          │  │                       ; Call the get_event routine
             │  │
07E  2003F   ╰────⤙                     call get_event_0
                │
07F             │                       ; Wait for take_event to go LOW (Turn LED0 OFF)
                │
07F  09100      │╭▶           nuclear1: input ip, STATUS_IPORT
080  0D102      ││                      test ip, 02                    ; Test bit 1
081  3607F      │╰⤙                     jump NZ, nuclear1
082  03AFE      │                       and led_reg, fe                ; Clear bit 0
083  2DA00      │                       output led_reg, LED_PORT
                │
084             │                       ; Go back and wait for the next event
                │
084  22079      ╰─⤙                     jump nuclear0

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/gle/VIVADO_FPGA/Cmod-A7-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
 *  PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      0A
    datestamp_month    0B
    datestamp_year     18
    timestamp_hours    0E
    timestamp_minutes  30
    timestamp_seconds  12

       * Unreferenced constant(s)


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "10 Nov 2024"
    timestamp$       "14:48:18"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv_0             01E   pico_program.psm
    adc_conv_0.clk_loop    028   pico_program.psm
 *  adc_conv_0.loc1        030   pico_program.psm
    adc_test               06A   pico_program.psm
    adc_test0              06B   pico_program.psm
    adc_test1              070   pico_program.psm
    adc_to_fifo            033   pico_program.psm
    adc_to_fifo.wait_trdy  03A   pico_program.psm
    data_acq               055   pico_program.psm
    data_acq.delay0        05A   pico_program.psm
    data_acq.delay1        05B   pico_program.psm
    data_acq.loc0          066   pico_program.psm
    data_acq.loc1          067   pico_program.psm
    data_acq.wait_trdy     05F   pico_program.psm
    dly_us                 01A   pico_program.psm
    dly_us.wait_us         01B   pico_program.psm
    get_event_0            03F   pico_program.psm
    get_event_0.done       050   pico_program.psm
    get_event_0.loop       044   pico_program.psm
    init                   001   pico_program.psm
    my_isr                 380   pico_program.psm
 *  nuclear                078   pico_program.psm
    nuclear0               079   pico_program.psm
    nuclear1               07F   pico_program.psm
 *  origin                 000   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          1
   ADDCY        -
   AND          6
   CALL         10
   CALL@        -
   COMPARE      1
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        1
   HWBUILD      -
   INPUT        9
   JUMP         18
   JUMP@        -
   LOAD         23
   LOAD&RETURN  -
   OR           10
   OUTPUT       29
   OUTPUTK      -
   REGBANK      -
   RETURN       6
   RETURNI      1
   RL           -
   RR           -
   SL0          3
   SL1          -
   SLA          -
   SLX          -
   SR0          -
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        2
   SUB          5
   SUBCY        -
   TEST         8
   TESTCY       -
   XOR          2
