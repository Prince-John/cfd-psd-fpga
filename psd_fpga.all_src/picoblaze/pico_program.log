Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2024-11-07T15:45:14
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 133
  Memory locations available: 3963
  Scratchpad size: 256


Assembly listing
----------------
                                        ;
000                                     ; Test program for our picoblaze
000                                     ; For starters just blink led connected to bit 0
000                                     ; of output port #0
                                        ;
000                                     ; Keep adding until is does everything we need!
                                        ;
000                                     ; 31-Oct-2024
                                        ;

000                                     ; ********************************************
000                                     ; Output ports (we have 8 real output ports)
000                                     ; Currently ports 5, 6, 7 are UNUSED.
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast signals
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; --------------------------------
000                                     ; 0		LED0
000                                     ; 1		LED1
000                                     ; 2
000                                     ; 3
000                                     ; 4
000                                     ; 5
000                                     ; 6
000                                     ; 7

000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		sc bit 0
000                                     ; 5		sc bit 1
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Board id
000                                     ; type = 10 ---> TDC data (lower 24 bits)
000                                     ; type = 11 ---> TDC data (upper 24 bits)

000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6
000                                     ; 7

000                                     ; Ports 5, 6, abd 7 are currently unused

000                                     constant OP5, 05

000                                     constant OP6, 06

000                                     constant OP7, 07


000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_PORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2
000                                     ; 3
000                                     ; 4
000                                     ; 5
000                                     ; 6
000                                     ; 7

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]
000                                     ; 6
000                                     ; 7

000                                     ; Input ports 2 through 7 are not currently used

000                                     ; --------------------------------
000                                     ; CURRENTLY UNUSED
000                                     ; --------------------------------

000                                     constant IP2, 02

000                                     constant IP3, 03

000                                     constant IP4, 04

000                                     constant IP5, 05

000                                     constant IP6, 06

000                                     constant IP7, 07

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; Give more desciptive names to some of our registers
                                        ;
000                                     namereg s0, op                 ; Output port register
000                                     namereg s1, ip                 ; Input port register
000                                     namereg s2, scr0               ; Scratchpad register 0
000                                     namereg s3, scr1               ; Scratchpad register 1
000                                     namereg s4, scr2               ; Scratchpad register 2
000                                     namereg s5, cnt                ; Used in counters
000                                     namereg s6, dreg               ; Used in delay_1us routine
000                                     namereg s7, adc_reg            ; Used by adc routine
000                                     namereg s8, adc_mask           ; Used by adc routine
000                                     namereg s9, word_cntr          ; Keeps track of word count
000                                     namereg sa, status             ; Global variable with status info

000                                     ; ---------------------------
000                                     ; status register contents
000                                     ; ---------------------------
                                        ;
000                                     ; 0		event_in_progress
000                                     ; 1
000                                     ; 2
000                                     ; 3
000                                     ; 4
000                                     ; 5
000                                     ; 6
000                                     ; 7

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ;********************************************
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ;********************************************
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000

000  22075 ╭──────⤙             origin: jump main
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
001        │                            ; Initialize the stack pointer, SP
001        │                            ; Set all output port bits low
001        │                            ; Uses scr1 BUT restores it!!!!
001        │                            ; Demos out to work with stack!
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ;  Push scr1 onto the stack
           │
002  2E3F0 │                            store scr1, (SP)               ; Push
003  19F01 │                            sub SP, 01
           │
           │
004        │                            ; Clear the 8 output port registers
           │
004  01300 │                            load scr1, 00
           │
005  2D300 │                            output scr1, LED_PORT
006  2D301 │                            output scr1, ADC_CTL_PORT
007  2D302 │                            output scr1, DATA_TAG_PORT
008  2D303 │                            output scr1, TDC_DATA_PORT
009  2D304 │                            output scr1, TDC_CTL_PORT
00A  2D305 │                            output scr1, OP5
00B  2D306 │                            output scr1, OP6
00C  2D307 │                            output scr1, OP7
           │
00D        │                            ; Clear some registers
           │
00D  01100 │                            load ip, 00
00E  01000 │                            load op, 00
00F  01A00 │                            load status, 00
010  01500 │                            load cnt, 00
011  01600 │                            load dreg, 00
012  01700 │                            load adc_reg, 00
013  01800 │                            load adc_mask, 00
014  01500 │                            load cnt, 00
015  01900 │                            load word_cntr, 00
           │
016        │                            ; Restore scr1 register
           │
016  11F01 │                            add SP, 01                     ; Pop
017  0A3F0 │                            fetch scr1, (SP)
           │
018  25000 │                            return
           │
019        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
019        │                            ; Subroutine Name: dly_100ns
           │                            ;
019        │                            ; Delay of 100 ns
           │                            ;
019        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
019        │                 dly_100ns:
019  00EE0 │                            load se, se                    ; NOP
01A  00EE0 │                            load se, se                    ; NOP
01B  00EE0 │                            load se, se                    ; NOP
01C  25000 │                            return
           │
01D        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
01D        │                            ; Subroutine Name: dly_us
           │                            ;
01D        │                            ; Delay of 1 usec
01D        │                            ; Delay is [(4 * dreg) + 6] / Fclk
01D        │                            ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │                            ;
01D        │                            ; Routine uses dreg and does not restore it
           │                            ;
01D        │                            ; 24 (i.e $18) assumes a 100 MHz clock
01D        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
01D        │                    dly_us:
01D  01618 │╭┬┬─┬─▶                     load dreg, 24'd
01E  19601 ││││ │╭▶           .wait_us: sub dreg, 01
01F  3601E ││││ │╰⤙                     jump NZ, .wait_us
020  25000 ││││ │                       return
           ││││ │
021        ││││ │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
021        ││││ │                       ; Subroutine Name: dly_100ms
           ││││ │                       ;
021        ││││ │                       ; Delay for "about" 100ms by repeatly calling
021        ││││ │                       ; delay_1us subroutine
021        ││││ │                       ; Note: 100,000 is $0186A0
           ││││ │                       ;
021        ││││ │                       ; Uses scr0, scr1, scr2 but does NOT destroys them
021        ││││ │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││ │
021        ││││ │            dly_100ms:
           ││││ │
021        ││││ │                       ; Push scr regs onto stack
           ││││ │
021  2E2F0 ││││╭──▶                     store scr0, (SP)               ; Push
022  19F01 ││││││                       sub SP, 01
           ││││││
023  2E3F0 ││││││                       store scr1, (SP)               ; Push
024  19F01 ││││││                       sub SP, 01
           ││││││
025  2E4F0 ││││││                       store scr2, (SP)               ; Push
026  19F01 ││││││                       sub SP, 01
           ││││││
           ││││││
027  01401 ││││││                       load scr2, 01
028  01386 ││││││                       load scr1, 86
029  012A0 ││││││                       load scr0, A0
02A  2001D │││││╰┬⤙              .loop: call dly_us
02B  19201 │││││ │                      sub scr0, 01
02C  1B300 │││││ │                      subcy scr1, 00
02D  1B400 │││││ │                      subcy scr2, 00
02E  3E02A │││││ ╰⤙                     jump NC, .loop
           │││││
02F        │││││                        ; Restore scratch registers
           │││││
02F  11F01 │││││                        add SP, 01                     ; Pop
030  0A4F0 │││││                        fetch scr2, (SP)
           │││││
031  11F01 │││││                        add SP, 01                     ; Pop
032  0A3F0 │││││                        fetch scr1, (SP)
           │││││
033  11F01 │││││                        add SP, 01                     ; Pop
034  0A2F0 │││││                        fetch scr0, (SP)
           │││││
           │││││
035  25000 │││││                        return
           │││││
036        │││││                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
036        │││││                        ; Subroutine Name: dly_sec
036        │││││                        ; Delays for about 1 second
036        │││││                        ; Uses cnt but saves it on stack and then
036        │││││                        ; pops it off the stack before returning
036        │││││                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │││││
036        │││││               dly_sec:
           │││││
036        │││││                        ; Push counter register onto stack
           │││││
036  2E5F0 │││││                        store cnt, (SP)                ; Push
037  19F01 │││││                        sub SP, 01
           │││││
           │││││
038  0150A │││││                        load cnt, 10'd
039  20021 ││││╰─┬⤙              .loop: call dly_100ms
03A  19501 ││││  │                      sub cnt, 01
03B  36039 ││││  ╰⤙                     jump NZ, .loop
           ││││
03C        ││││                         ; Pop counter register off stack
           ││││
03C  11F01 ││││                         add SP, 01                     ; Pop
03D  0A5F0 ││││                         fetch cnt, (SP)
           ││││
03E  25000 ││││                         return
           ││││
03F        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03F        ││││                         ; Subroutine Name: adc_conv
           ││││                         ;
03F        ││││                         ; Uses the cnt register to count clock pulses
03F        ││││                         ; but restores cnt register before returning
03F        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││
03F        ││││               adc_conv:
           ││││
03F        ││││                         ; Save cnt register
           ││││
03F  2E5F0 ││││ ╭─▶                     store cnt, (SP)                ; Push
040  19F01 ││││ │                       sub SP, 01
           ││││ │
           ││││ │
041        ││││ │                       ; Load adc_mask register with 01
041        ││││ │                       ; In other words point to adc0_sclk!
           ││││ │
041  01801 ││││ │                       load adc_mask, 01
           ││││ │
042        ││││ │                       ; Reset the ADC shift registers
042        ││││ │                       ; Bring reset bit high in adc_reg and then back low
           ││││ │
042  05780 ││││ │                       or adc_reg, 80                 ; Set bit 7
043  2D701 ││││ │                       output adc_reg, ADC_CTL_PORT
044  0377F ││││ │                       and adc_reg, 7f                ; Clear bit 7
045  2D701 ││││ │                       output adc_reg, ADC_CTL_PORT
           ││││ │
046        ││││ │                       ; Bring conv high
           ││││ │
046  05704 ││││ │                       or adc_reg, 04                 ; Set bit 2
047  2D701 ││││ │                       output adc_reg, ADC_CTL_PORT
           ││││ │
048        ││││ │                       ; Wait for 2 usec
           ││││ │
048  2001D │││╰───⤙                     call dly_us
049  2001D ││╰────⤙                     call dly_us
           ││   │
04A        ││   │                       ; Bring conv low
           ││   │
04A  037FB ││   │                       and adc_reg, fb                ; Clear bit 2
04B  2D701 ││   │                       output adc_reg, ADC_CTL_PORT
           ││   │
04C        ││   │                       ; Apply 16 clock pulses (takes about 2 usec)
           ││   │
04C  01510 ││   │                       load cnt, 16'd
04D  06780 ││   │╭▶          .clk_loop: xor adc_reg, adc_mask
04E  2D701 ││   ││                      output adc_reg, ADC_CTL_PORT
04F  06780 ││   ││                      xor adc_reg, adc_mask
050  00EE0 ││   ││                      load se, se                    ; NOP
051  00EE0 ││   ││                      load se, se                    ; NOP
052  2D701 ││   ││                      output adc_reg, ADC_CTL_PORT
053  19501 ││   ││                      sub cnt, 01
054  3604D ││   │╰⤙                     jump NZ, .clk_loop
           ││   │
055        ││   │                       ; Restore cnt register
           ││   │
055  11F01 ││   │                .loc1: add SP, 01                     ; Pop
056  0A5F0 ││   │                       fetch cnt, (SP)
           ││   │
           ││   │
057  25000 ││   │                       return
           ││   │
058        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
058        ││   │                       ; Name: get_event
058        ││   │                       ; Routine to get a nuclear physics event
058        ││   │                       ; word_cntr keeps track of where we are in the packet
058        ││   │                       ; Uses ip and op regs but restore them on exit
058        ││   │                       ; For testing we are just getting 50 ADC samples
058        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   │
058        ││   │            get_event:
           ││   │
058        ││   │                       ; Save ip and op registers
           ││   │
058  2E1F0 ││ ╭───▶                     store ip, (SP)                 ; Push
059  19F01 ││ │ │                       sub SP, 01
           ││ │ │
05A  2E0F0 ││ │ │                       store op, (SP)                 ; Push
05B  19F01 ││ │ │                       sub SP, 01
           ││ │ │
           ││ │ │
05C        ││ │ │                       ; Select adc T subchannel of PSD0 to drive FIFO
05C        ││ │ │                       ; Mux sel for ADC T for chan 0 is 2’b011
           ││ │ │
05C  01700 ││ │ │                       load adc_reg, 00
05D  05730 ││ │ │                       or adc_reg, 30                 ; 3 << 4
05E  2D701 ││ │ │                       output adc_reg, ADC_CTL_PORT
           ││ │ │                       ;
05F        ││ │ │                       ; Write out the data identifier
05F        ││ │ │                       ; 00 11 0111  (adc T chan7)
           ││ │ │
05F  01037 ││ │ │                       load op, 00110111'b
060  2D002 ││ │ │                       output op, DATA_TAG_PORT
           ││ │ │
061        ││ │ │                       ; Wait for 20 usec i.e. our sampling period
           ││ │ │
061  01514 ││ │╭──▶            .delay0: load cnt, 20'd
062  2001D │╰────┬⤙            .delay1: call dly_us
063  19501 │  ││││                      sub cnt, 01
064  36062 │  │││╰⤙                     jump NZ, .delay1
           │  │││
065        │  │││                       ; Perform a conversion
           │  │││
065  2003F │  ││╰─⤙                     call adc_conv
           │  ││
066        │  ││                        ; Wait for ’tready’ signal to be active
           │  ││                        ;
066  09100 │  ││ ╭▶         .wait_trdy: input ip, STATUS_PORT
           │  ││ │
067        │  ││ │                      ; Test bit 0 (i.e. tready) ... if zero we should wait
           │  ││ │
067  0D101 │  ││ │                      test ip, 00000001'b
068  32066 │  ││ ╰⤙                     jump Z, .wait_trdy
           │  ││                        ;
069        │  ││                        ; Either assert just ’tvalid’ or both ’tvalid’ and ’tlast’
069        │  ││                        ; What we actually write to the VALID or LAST port is irrelevant.
069        │  ││                        ; When we write to LAST port, both ’tvalid’ and ’tlast’ asserted.
069        │  ││                        ; When packet_cntr contains $01 the write to LAST port
           │  ││
069  1D901 │  ││                        compare word_cntr, 01
06A  3606D │  ││╭─⤙                     jump NZ, .loc0
06B  2D2FF │  │││                       output scr0, LAST_PORT
06C  2206E │  │││╭⤙                     jump .loc1
06D  2D2FE │  ││╰─▶              .loc0: output scr0, VALID_PORT
06E  19901 │  ││ ╰▶              .loc1: sub word_cntr, 01
06F  36061 │  │╰──⤙                     jump NZ, .delay0
           │  │
070        │  │                         ; Restore the ip and op registers
           │  │
070  11F01 │  │                         add SP, 01                     ; Pop
071  0A0F0 │  │                         fetch op, (SP)
           │  │
072  11F01 │  │                         add SP, 01                     ; Pop
073  0A1F0 │  │                         fetch ip, (SP)
           │  │
074  25000 │  │                         return
           │  │
075        │  │                         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
075        │  │                         ; ******* MAIN ROUTINE *********
           │  │                         ;
075        │  │                         ; Let’s grab a packet whenever we see take_event go high
075        │  │                         ; When take_event goes high, turn LED0 on
075        │  │                         ; When take event goes low, turn LED0 off
075        │  │                         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           │  │
075  20001 ╰──────▶               main: call init
              │
076           │             .main_loop:
              │
076           │                         ; Wait for take_event to go low
              │
076  09100    │ ╭┬▶             .main0: input ip, STATUS_PORT
077  0D102    │ ││                      test ip, 00000010'b
078  36076    │ │╰⤙                     jump NZ, .main0
              │ │
079           │ │                       ; Take event is low so turn LED0 off
              │ │
079  030FE    │ │                       and op, fe                     ; Clear bit 0
07A  2D000    │ │                       output op, LED_PORT
              │ │
07B           │ │                       ; Wait for take_event to go high
              │ │
07B  09100    │ │╭▶             .main1: input ip, STATUS_PORT
07C  0D102    │ ││                      test ip, 00000010'b
07D  3207B    │ │╰⤙                     jump Z, .main1
              │ │
07E           │ │                       ; Take event is high so turn LED0 on
              │ │
07E  05001    │ │                       or op, 01                      ; Set bit 0
07F  2D000    │ │                       output op, LED_PORT
              │ │
080           │ │                       ; word_cntr keeps track of where we are in the packet creation process
080           │ │                       ; load word_cntr with how many words we want in our packet
              │ │
080  01932    │ │                       load word_cntr, 50'd
              │ │
081           │ │                       ; Don’t return until we have captured a complete packet and sent
081           │ │                       ; the packet to the uBlaze using streaming FIFO
              │ │
081  20058    ╰───⤙                     call get_event
                │
082             │                       ; Go back to top of loop and do it all over again!
                │
082  22076      ╰─⤙                     jump .main_loop

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/gle/VIVADO_FPGA/Cmod-A7-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
 *  BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
 *  IP2                02     pico_program.psm
 *  IP3                03     pico_program.psm
 *  IP4                04     pico_program.psm
 *  IP5                05     pico_program.psm
 *  IP6                06     pico_program.psm
 *  IP7                07     pico_program.psm
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    NUL                00
    OP5                05     pico_program.psm
    OP6                06     pico_program.psm
    OP7                07     pico_program.psm
    ST                 9C
    STATUS_PORT        00     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      07
    datestamp_month    0B
    datestamp_year     18
    timestamp_hours    0F
    timestamp_minutes  2D
    timestamp_seconds  0E

       * Unreferenced constant(s)


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "07 Nov 2024"
    timestamp$       "15:45:14"


List of line labels
-------------------
    Label                Addr  Source PSM file 
 --------                ----  --------------- 
    adc_conv             03F   pico_program.psm
    adc_conv.clk_loop    04D   pico_program.psm
 *  adc_conv.loc1        055   pico_program.psm
    dly_100ms            021   pico_program.psm
    dly_100ms.loop       02A   pico_program.psm
 *  dly_100ns            019   pico_program.psm
 *  dly_sec              036   pico_program.psm
    dly_sec.loop         039   pico_program.psm
    dly_us               01D   pico_program.psm
    dly_us.wait_us       01E   pico_program.psm
    get_event            058   pico_program.psm
    get_event.delay0     061   pico_program.psm
    get_event.delay1     062   pico_program.psm
    get_event.loc0       06D   pico_program.psm
    get_event.loc1       06E   pico_program.psm
    get_event.wait_trdy  066   pico_program.psm
    init                 001   pico_program.psm
    main                 075   pico_program.psm
    main.main0           076   pico_program.psm
    main.main1           07B   pico_program.psm
    main.main_loop       076   pico_program.psm
    my_isr               380   pico_program.psm
 *  origin               000   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          8
   ADDCY        -
   AND          3
   CALL         8
   CALL@        -
   COMPARE      1
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        8
   HWBUILD      -
   INPUT        3
   JUMP         14
   JUMP@        -
   LOAD         27
   LOAD&RETURN  -
   OR           4
   OUTPUT       20
   OUTPUTK      -
   REGBANK      -
   RETURN       7
   RETURNI      1
   RL           -
   RR           -
   SL0          -
   SL1          -
   SLA          -
   SLX          -
   SR0          -
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        8
   SUB          14
   SUBCY        2
   TEST         3
   TESTCY       -
   XOR          2
