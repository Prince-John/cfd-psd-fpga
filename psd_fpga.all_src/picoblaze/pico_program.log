Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2025-03-21T09:44:13
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 356
  Memory locations available: 3740
  Scratchpad size: 256


Assembly listing
----------------
000                                     ; ################################################
000                                     ; NOTE:  All PicoBlaze instructions take 2 clock
000                                     ; cycles so 20 ns (100 MHz clock)
000                                     ; ################################################
                                        ;
000                                     ; GLE: 11-Feb-2025
000                                     ; Adding the support we need for TDC7200
                                        ;
000                                     ; GLE: 15-Feb-2025
000                                     ; Continuing to add TDC support
000                                     ; Fixed bug in get_event routine
000                                     ; Important that token_in go low before
000                                     ; acq_clk goes high!
                                        ;
000                                     ; GLE: 17-Feb-2025
000                                     ; Finished program BUT still needs to be tested!
000                                     ; Fixed a bug -> veto_reset should go low after take_event goes low
                                        ;
000                                     ; GLE: 19-Mar-2025
000                                     ; Reviewing to make sure everything is complete and working

000                                     ; ********************************************
000                                     ; Output ports (we have 8 "real" output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast strobes
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED 0
000                                     ; 1		LED 1 (also the busy bit!)

000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Timestamp Counter (upper and lower)
000                                     ; type = 10 ---> TDC TIME1 or TIME 2 value
000                                     ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
                                        ;
000                                     ; For type = 00
000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time
                                        ;
000                                     ; For types 01, 10, 11
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6		tdc_csb
000                                     ; 7		tdc_enable

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     constant MISC_OPORT, 07

000                                     ; --------------------------------
000                                     ; PORT 7 (Misc outputs)
000                                     ; --------------------------------
                                        ;
000                                     ; 0 	force_psd_reset
000                                     ; 1		veto_reset
000                                     ; 2		fifo_mux_sel[0]
000                                     ; 3		fifo_mux_sel[1]
000                                     ; 4		psd_glob_ena
                                        ;
000                                     ; fifo_mux_sel = 00 -> adc_data (adc_reg)
000                                     ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
000                                     ; fifo_mux_sel = 10 -> tstamp counter (lower)
000                                     ; fifo_mux_sel = 11 -> tstamp counter (upper)

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2		tdc_intb (interrupt signal from TDC7200)
000                                     ; [3:7] 0

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]
000                                     ; 6     0
000                                     ; 7     0

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)
000                                     ; 7     0

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)
000                                     ; 7     0

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; We can use s0 - sd, se and sf are special
000                                     ; Give more desciptive names to some of our registers
000                                     ; The scratch registers get used but not restored!
000                                     ; Other regs tend to be saved on the stack!
                                        ;
000                                     namereg s0, op                 ; Output port register
000                                     namereg s1, ip                 ; Input port register
000                                     namereg s2, scr0               ; Scratchpad register 0 (scratch)
000                                     namereg s3, scr1               ; Scratchpad register 1 (scratch)
000                                     namereg s4, cnt                ; Used for counting "things"
000                                     namereg s5, dly_reg            ; Used in delay_1us routine
000                                     namereg s6, adc_reg            ; Used by adc routine
000                                     namereg s7, adc_clk_mask       ; Defines which adc clocks are to be used
000                                     namereg s8, adc_conv_mask      ; Defines which adc conv signals are to be used
000                                     namereg s9, psd_or_reg         ; Lower 2 bits keep track of PSD1 and PSD0 ORs
000                                     namereg sa, led_reg            ; State of LED_PORT
000                                     namereg sb, tdc_ctl_reg        ; State of TDC_CTL_PORT
000                                     namereg sc, misc_oport_reg     ; State of MISC_OPORT
000                                     namereg sd, addr_reg           ; Holds PSD channel address and TDC7200 addresses

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; Register se is also special
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Read the board id port and store it in scratchpad memory

000                                     constant BOARD_ID, 00


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; TDC7200 address map (no auto-increment i.e. bit 7 is 0)
000                                     ; Read/Write control is bit 6 where set means WRITE!!!!
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Address of CONFIG1 register (with write bit set!)

000                                     constant CONFIG1, 40


000                                     ; Address of CONFIG2 register (with write bit set!)

000                                     constant CONFIG2, 41


000                                     ; Address of TIME1 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME1, 10


000                                     ; Address of TIME2 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME2, 11


000                                     ; Address of CALIBRATION1 register (with write bit cleared!)

000                                     constant CALIBRATION1, 1b


000                                     ; Address of CALIBRATION2 register (with write bit cleared!)

000                                     constant CALIBRATION2, 1c


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Configuration values
                                        ;
000                                     ; We want Mode 1, 2 calibration cycles, 2 stops, ave cycles = 0
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Value we want to load into CONFIG1 register
000                                     ; Bit 0 is set so it will start measurement when value written

000                                     constant CONFIG1_VAL, 01


000                                     ; Value we want to load into CONFIG2 register

000                                     constant CONFIG2_VAL, 01


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Data id tag bytes when working with time data
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Here is the mapping
                                        ;
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TSTAMP_LOWER_TAG, 40

000                                     constant TSTAMP_UPPER_TAG, 50

000                                     constant TDC_TIME1_TAG, 90

000                                     constant TDC_TIME2_TAG, a0

000                                     constant TDC_CAL1_TAG, d0

000                                     constant TDC_CAL2_TAG, e0


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000
000  22148 ╭──────⤙             origin: jump nuclear
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
           │                            ;
001        │                            ; Initialize the stack pointer, SP
001        │                            ; Initialize registers and ports
001        │                            ; Read board id and save
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ; Read the board id from port and save it to scratchpad memory location 0
           │
002  09201 │                            input scr0, BOARD_ID_PORT
003  2F200 │                            store scr0, BOARD_ID
           │
004        │                            ; Clear  registers
           │
004  01000 │                            load op, 00
005  01100 │                            load ip, 00
006  01200 │                            load scr0, 00
007  01300 │                            load scr1, 00
008  01400 │                            load cnt, 00
009  01500 │                            load dly_reg, 00
00A  01600 │                            load adc_reg, 00
00B  01700 │                            load adc_clk_mask, 00
00C  01800 │                            load adc_conv_mask, 00
00D  01900 │                            load psd_or_reg, 00
00E  01A00 │                            load led_reg, 00
00F  01B00 │                            load tdc_ctl_reg, 00
010  01C00 │                            load misc_oport_reg, 00
011  01D00 │                            load addr_reg, 00
           │
012        │                            ; Clear the output port registers
           │
012  2D200 │                            output scr0, LED_PORT          ; turn off LEDs
013  2D202 │                            output scr0, DATA_TAG_PORT
014  2D203 │                            output scr0, TDC_DATA_PORT
           │
015        │                            ; Bring tdc_csb (bit 6) high
015        │                            ; Rest of signals low
           │
015  05B40 │                            or tdc_ctl_reg, 40             ; Set bit 6
016  2DB04 │                            output tdc_ctl_reg, TDC_CTL_PORT
           │
017        │                            ; Need to reset the tdc_reg
017        │                            ; Synchronous reset (bit 3) so we need to apply a clock pulse
           │
017  2002A │   ╭──⤙                     call clr_tdc_reg
           │   │
018        │   │                        ; Reset the ADC shift registers
018        │   │                        ; Bring reset bit high in adc_reg and then back low
018        │   │                        ; Bit 7 of adc_reg is the reset adc registers bit
018        │   │                        ; Clock and conv signals low
018        │   │                        ; Mux selects (3’b000) choosing adc reg for PSD0 A integrator
018        │   │                        ; Pulse the adc reg reset line
           │   │
018  05680 │   │                        or adc_reg, 80                 ; Set bit 7
019  2D601 │   │                        output adc_reg, ADC_CTL_PORT
01A  0367F │   │                        and adc_reg, 7f                ; Clear bit 7
01B  2D601 │   │                        output adc_reg, ADC_CTL_PORT
           │   │
01C        │   │                        ; Make sure that tokens into the PSD chips are HIGH (inactive)
01C        │   │                        ; token_in for the PSD ports is bit 6
01C        │   │                        ; Others bit should be low
           │   │
01C  05040 │   │                        or op, 40                      ; Set bit 6
01D  2D005 │   │                        output op, PSD0_OPORT
01E  2D006 │   │                        output op, PSD1_OPORT
           │   │
01F        │   │                        ; Bring the force_reset and veto_reset pins low on both PSD chips
01F        │   │                        ; force_reset is bit 0
01F        │   │                        ; veto_reset is bit 1
01F        │   │                        ; fifo_mux_sel (bits 2 and 3) is 00 (i.e. selecting adc_reg)
01F        │   │                        ; Make psd_global_ena (bit 4) low
           │   │
01F  01C00 │   │                        load misc_oport_reg, 00
020  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
021        │   │                        ; We need to initialize the timestamp stuff if we are board 0
           │   │
021  0B200 │   │                        fetch scr0, BOARD_ID
022  36024 │   │ ╭⤙                     jump NZ, .done
           │   │ │
023        │   │ │                      ; If we are board 0, then we need to initialize the TDC7200 chip
           │   │ │
023  20036 │   │╭─⤙                     call tdc_init
           │   │││
024        │   │││                      ; Done so return
           │   │││
024  25000 │   ││╰▶              .done: return
           │   ││
025        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
025        │   ││                       ; Collection of support routines for timestamp creation.
           │   ││                       ;
025        │   ││                       ; We will used tdc_ctl_reg to keep state
025        │   ││                       ; of the TDC_CTL_PORT
           │   ││                       ;
025        │   ││                       ; --------------------------------
025        │   ││                       ; PORT 4 (TDC register control)
025        │   ││                       ; --------------------------------
025        │   ││                       ; 0		tdc_reg_ld_0
025        │   ││                       ; 1		tdc_reg_ld_1
025        │   ││                       ; 2		tdc_reg_ld_2
025        │   ││                       ; 3		tdc_reg_rst
025        │   ││                       ; 4		tdc_reg_shift
025        │   ││                       ; 5		tdc_reg_sclk
025        │   ││                       ; 6		tdc_csb
025        │   ││                       ; 7		tdc_enable
025        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │   ││
025        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
025        │   ││                       ; Subroutine Name: tdc_reg_clk
           │   ││                       ;
025        │   ││                       ; Routine to apply a single clock pulse to tdc_reg
025        │   ││                       ; Doesn’t effect TDC7200 because tdc_csb should be high
025        │   ││                       ; when we apply the single clock pulse.  Pulse is needed
025        │   ││                       ; for synchronous reset and sychronous load of tdc_reg
025        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
025  05B20 ╭─────┬▶        tdc_reg_clk: or tdc_ctl_reg, 20             ; Set bit 5
026  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk high
027  03BDF │   │││                      and tdc_ctl_reg, df            ; Clear bit 5
028  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk low
029  25000 │   │││                      return
           │   │││
02A        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
02A        │   │││                      ; Subroutine Name: clr_tdc_reg
           │   │││                      ;
02A        │   │││                      ; Clears the tdc register in our timstamp_interface module
02A        │   │││                      ; The clear (bit 3) is synchronous so we need to apply a clock pulse
           │   │││                      ;
02A        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │││
02A  05B08 ╭┬──┴──▶        clr_tdc_reg: or tdc_ctl_reg, 08             ; Set bit 3
02B  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
02C  20025 ││   │╰⤙                     call tdc_reg_clk
02D  03BF7 ││   │                       and tdc_ctl_reg, f7            ; Clear bit 3
02E  2DB04 ││   │                       output tdc_ctl_reg, TDC_CTL_PORT
02F  25000 ││   │                       return
           ││   │
030        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
030        ││   │                       ; Subroutine Name: tdc_ena
           ││   │                       ;
030        ││   │                       ; This routine will enable the TDC7200
030        ││   │                       ; We do this by bringing the tdc_enable (Bit 7) low
030        ││   │                       ; and then bring it high. Enable must be high
030        ││   │                       ; for TDC7200 to perform conversions.
030        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   │
030  03B7F ││   │╭▶            tdc_ena: and tdc_ctl_reg, 7f            ; Clear bit 7
031  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
032  200AA ╭──────⤙                     call dly_us
033  05B80 ││   ││                      or tdc_ctl_reg, 80             ; Set bit 7
034  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
035  25000 ││   ││                      return
036        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
036        ││   ││                      ; Subroutine Name: tdc_init
           ││   ││                      ;
036        ││   ││                      ; Routine to initialize the TDC7200 and related circuits
036        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   ││
036        ││   ││            tdc_init:
           ││   ││
036        ││   ││                      ; Enable the TDC7200
036        ││   ││                      ; This only needs to be done once
036        ││   ││                      ; Brings tdc_ena low and then high!
           ││   ││
036  20030 ││   ╰┴▶                     call tdc_ena
           ││
037        ││                           ; Load config data into CONFIG2 register
037        ││                           ; This only needs to be done once!!!!!
037        ││                           ; addr_reg needs to be loaded with address
037        ││                           ; op needs to be loaded with value to be stored at address
           ││
037  01D41 ││                           load addr_reg, CONFIG2
038  01001 ││                           load op, CONFIG2_VAL
039  20050 ││ ╭───⤙                     call config_tdc
           ││ │
03A        ││ │                         ; Start a TDC7200 measurement!
           ││ │
03A  20062 ╭──────⤙                     call start_tdc
           ││ │
03B  25000 ││ │                         return
           ││ │
03C        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03C        ││ │                         ; Subroutine Name: tdc_serial
           ││ │                         ;
03C        ││ │                         ; Routine to send and receive serial dataa
03C        ││ │                         ; from TDC7200. Used to send both internal
03C        ││ │                         ; register address and data to the TDC7200
           ││ │                         ;
03C        ││ │                         ; We should enter with cnt register containing
03C        ││ │                         ; number of clock pulses we want
           ││ │                         ;
03C        ││ │                         ; Make sure the tdc_csb is LOW when this routine
03C        ││ │                         ; is called!
           ││ │                         ;
03C        ││ │                         ; Minimum sclk period for the TDC7200 is 50 ns
           ││ │                         ;
03C        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││ │
03C        ││ │             tdc_serial:
           ││ │
03C        ││ │                         ; Bring the shift control on tdc register high!
           ││ │
03C  05B10 ╭─┬────▶                     or tdc_ctl_reg, 10             ; Set bit 4
03D  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
03E        ││││                         ; Apply clock pulses (number in cnt register)
03E        ││││                         ; Use scr0 as a clock mask (tdc_sclk is bit 5)
           ││││
03E  01220 ││││                         load scr0, 00100000'b
03F  06B20 ││││  ╭▶          .clk_loop: xor tdc_ctl_reg, scr0
040  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
041  00EE0 ││││  │                      load se, se                    ; NOP
042  00EE0 ││││  │                      load se, se                    ; NOP
043  06B20 ││││  │                      xor tdc_ctl_reg, scr0
044  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
045  19401 ││││  │                      sub cnt, 01
046  3603F ││││  ╰⤙                     jump NZ, .clk_loop
           ││││
047        ││││                         ; Bring the shift control on tdc register low!
           ││││
047  03BEF ││││                         and tdc_ctl_reg, ef            ; Clear bit 4
048  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
049  25000 ││││                         return
           ││││                         ;
04A        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04A        ││││                         ; Subroutine Name: tdc_csb_low
           ││││                         ;
04A        ││││                         ; Bring TDC7200 csb pin low (bit 6 of TDC_CTL_PORT)
04A        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││
04A  03BBF ╭─────┬▶        tdc_csb_low: and tdc_ctl_reg, bf            ; Clear bit 6
04B  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
04C  25000 ││││  │                      return
           ││││  │                      ;
04D        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04D        ││││  │                      ; Subroutine Name: tdc_csb_high
           ││││  │                      ;
04D        ││││  │                      ; Bring TDC7200 CSB pin high (bit 6 of TDC_CTL_PORT)
04D        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││  │
04D  05B40 ╭────┬─▶       tdc_csb_high: or tdc_ctl_reg, 40             ; Set bit 6
04E  2DB04 ││││ ││                      output tdc_ctl_reg, TDC_CTL_PORT
04F  25000 ││││ ││                      return
           ││││ ││
050        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050        ││││ ││                      ; Subroutine Name: config_tdc
           ││││ ││                      ;
050        ││││ ││                      ; When we enter, addr_reg should contain the configuration
050        ││││ ││                      ; register address we want to load, either CONFGI1 or CONFIG2
           ││││ ││                      ;
050        ││││ ││                      ; Also, when we enter, op register should contain the
050        ││││ ││                      ; configuration value, wither CONFIG1_VAL ore CONFIG2_VAL
           ││││ ││                      ;
050        ││││ ││                      ; Loads the TDC7200 CONFIG1 or CONFIG2 register
050        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││ ││
050  2002A │╰─┴┬──⤙         config_tdc: call clr_tdc_reg
           │ │ │││
051        │ │ │││                      ; Load address information and write to TDC_DATA_PORT
051        │ │ │││                      ; addr_reg is passed into routine and contains address
051        │ │ │││                      ; of TDC7200 register we want to load!
           │ │ │││
051  2DD03 │ │ │││                      output addr_reg, TDC_DATA_PORT
           │ │ │││
052        │ │ │││                      ; Assert ld[2] control (most significant byte of tdc register)
052        │ │ │││                      ; Synchronous load so we need to apply a clock pulse!
052        │ │ │││                      ; ld[2] is bit 2 pf the TDC_CTL_PORT
           │ │ │││
052  05B04 │ │ │││                      or tdc_ctl_reg, 04             ; Set bit 2
053  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
054  20025 ╰──────⤙                     call tdc_reg_clk
055  03BFB │ │ │││                      and tdc_ctl_reg, fb            ; Clear bit 2
056  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
057        │ │ │││                      ; Write value to TDC_DATA_PORT
057        │ │ │││                      ; The op register is passed into routine and contains the data value
           │ │ │││
057  2D003 │ │ │││                      output op, TDC_DATA_PORT
           │ │ │││
058        │ │ │││                      ; Assert ld[1] control (middle byte of tdc register)
058        │ │ │││                      ; ld[1] is bit 1 of TDC_CTL_PORT
           │ │ │││
058  05B02 │ │ │││                      or tdc_ctl_reg, 02             ; Set bit 1
059  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
05A  20025 ╰──────⤙                     call tdc_reg_clk
05B  03BFD │ │ │││                      and tdc_ctl_reg, fd            ; Clear bit 1
05C  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
05D        │ │ │││                      ; Bring tdc_csb pin low (active)
           │ │ │││
05D  2004A │ │ ││╰⤙                     call tdc_csb_low
           │ │ ││
05E        │ │ ││                       ; Load cnt with the number of clock pulses we want i.e. 16
05E        │ │ ││                       ; We need 8 clocks to load register address and 8 to load the value
05E        │ │ ││                       ; Address goes in first followed by data
           │ │ ││
05E  01410 │ │ ││                       load cnt, 16'd
           │ │ ││
05F        │ │ ││                       ; Call our TDC serial routine
           │ │ ││
05F  2003C │ ╰────⤙                     call tdc_serial
           │   ││
060        │   ││                       ; Bring tdc_csb pin high (inactive)
           │   ││
060  2004D │   │╰─⤙                     call tdc_csb_high
           │   │
061  25000 │   │                        return
           │   │
062        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
062        │   │                        ; Subroutine Name: start_tdc
           │   │                        ;
062        │   │                        ; This routine will start a measurement on TDC7200
062        │   │                        ; if this board 0.
           │   │                        ;
062        │   │                        ; Measurements are started by writing to CONFIG1 with
062        │   │                        ; the least significant bit set!
           │   │                        ;
062        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
062        │   │             start_tdc:
           │   │
062        │   │                        ; Fetch the board id
           │   │
062  0B200 ╰──────▶                     fetch scr0, BOARD_ID
063  32067 │   │ ╭⤙                     jump Z, .done
           │   │ │
064        │   │ │                      ; Start the TDC7200 since the board is 0
064        │   │ │                      ; We start the TDC7200 by writing to CONFIG1
           │   │ │
064  01D40 │   │ │                      load addr_reg, CONFIG1
065  01001 │   │ │                      load op, CONFIG1_VAL
066  20050 │   ╰──⤙                     call config_tdc
           │     │
067        │     │                      ; We are done, so return!
           │     │
067  25000 │     ╰▶              .done: return
           │
068        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
068        │                            ; Subroutine Name: read_tdc
           │                            ;
068        │                            ; Reads a 24-bit register from the TDC7200
           │                            ;
068        │                            ; When we enter, addr_reg should contain the register we
068        │                            ; want to read from, either TIME1, TIME2, CALIBRATION1,
068        │                            ; or CALIBRATION2
           │                            ;
068        │                            ; Takes a total of 32 clock pulses to do the read
068        │                            ; First 8 loads the register address and then last 24
068        │                            ; clocks read out the data
068        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
068  2002A ╰───┬──⤙           read_tdc: call clr_tdc_reg               ; clears all 24-bits of tdc_reg
           │   │
069        │   │                        ; Load address information and write to TDC_DATA_PORT
           │   │
069  2DD03 │   │                        output addr_reg, TDC_DATA_PORT
           │   │
06A        │   │                        ; Assert ld[2] control (most significant byte of tdc register)
06A        │   │                        ; Load address of register into ms byte of tdc_reg
06A        │   │                        ; Synchronous load so we need to apply clock pulse
           │   │
06A  05B04 │   │                        or tdc_ctl_reg, 04             ; Set bit 2
06B  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
06C  20025 ╰──────⤙                     call tdc_reg_clk
06D  03BFB │   │                        and tdc_ctl_reg, fb            ; Clear bit 2
06E  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
           │   │
06F        │   │                        ; Bring tdc_csb pin low (active)
           │   │
06F  2004A ╰──────⤙                     call tdc_csb_low
           │   │
070        │   │                        ; Load cnt register with the number of clock pulses we want i.e. 8
070        │   │                        ; It takes 8 clock pulses to load the register address (with write bit set)
070        │   │                        ; and then 24 clocks to read the data so a total of 32 clock pulse
           │   │
070  01420 │   │                        load cnt, 32'd
           │   │
071        │   │                        ; Call our TDC serial routine
           │   │
071  2003C ╰──────⤙                     call tdc_serial
           │   │
072        │   │                        ; Bring tdc_csb pin high (inactive)
           │   │
072  2004D ╰──────⤙                     call tdc_csb_high
           │   │
073  25000 │   │                        return
           │   │
074        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
074        │   │                        ; Subroutine Name: time_to_fifo
           │   │                        ;
074        │   │                        ; Routine sends time related data to the FIFO
           │   │                        ;
074        │   │                        ;	constant	TSTAMP_LOWER_TAG, 40
074        │   │                        ;	constant	TSTAMP_UPPER_TAG, 50
074        │   │                        ;	constant	TDC_TIME1_TAG, 90
074        │   │                        ;	constant	TDC_TIME2_TAG, a0
074        │   │                        ;	constant	TDC_CAL1_TAG, d0
074        │   │                        ;	constant	TDC_CAL2_TAG, e0
           │   │                        ;
074        │   │                        ; PORT 7 (MISC_OPORT)
           │   │                        ;
074        │   │                        ; 0 	force_psd_reset
074        │   │                        ; 1		veto_reset
074        │   │                        ; 2		fifo_mux_sel[0]
074        │   │                        ; 3		fifo_mux_sel[1]
074        │   │                        ; 4		psd_glob_ena
           │   │                        ;
074        │   │                        ; fifo_mux_sel = 00 -> adc_data (adc_reg)
074        │   │                        ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
074        │   │                        ; fifo_mux_sel = 10 -> tstamp counter (lower)
074        │   │                        ; fifo_mux_sel = 11 -> tstamp counter (upper)
           │   │                        ;
074        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
074        │   │          time_to_fifo:
           │   │
074        │   │                        ; Send tstamp_counter (lower 24 bits)
074        │   │                        ; Start by writing out correct data tag
           │   │
074  01040 ╭──────▶                     load op, TSTAMP_LOWER_TAG
075  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
076        │   │                        ; Set the fifo_mux_sel to 10
           │   │
076  05C08 │   │                        or misc_oport_reg, 08          ; Set bit 3
077  03CFB │   │                        and misc_oport_reg, fb         ; Clear bit 2
078  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
079        │   │                        ; Wait for FIFO to be ready
           │   │
079  09100 │   │ ╭▶             .wait0: input ip, STATUS_IPORT
           │   │ │
07A        │   │ │                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │   │ │
07A  0D101 │   │ │                      test ip, 01                    ; Test bit 0
07B  32079 │   │ ╰⤙                     jump Z, .wait0
           │   │
07C        │   │                        ; When FIFO is ready, send data (what we send to vaild port makes no diff)
07C        │   │                        ; Writing to the VALID_port, strobes the tvalid control signal!
           │   │
07C  2D2FE │   │                        output scr0, VALID_PORT
           │   │
07D        │   │                        ; Send tstamp counter (upper 24 bits)
           │   │
07D  01050 │   │                        load op, TSTAMP_UPPER_TAG
07E  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
07F        │   │                        ; Set the fifo_mux_sel to 11 (it was 10)
           │   │
07F  05C04 │   │                        or misc_oport_reg, 04          ; Set bit 2
080  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
081        │   │                        ; Wait for FIFO to be ready
           │   │
081  09100 │   │ ╭▶             .wait1: input ip, STATUS_IPORT
082  0D101 │   │ │                      test ip, 01                    ; Test bit 0
083  32081 │   │ ╰⤙                     jump Z, .wait1
           │   │
084        │   │                        ; Need to check if we are board 0 or not?
084        │   │                        ; The board ID is saved in scratchpad memory
084        │   │                        ; If not board 0, then got DONE!
           │   │
084  0B200 │   │                        fetch scr0, BOARD_ID
085  360A8 │   │╭─⤙                     jump NZ, .done
           │   ││
086        │   ││                       ; This is board 0!
           │   ││
086  2D2FE │   ││                       output scr0, VALID_PORT
           │   ││
087        │   ││                       ; Send tag to DATA_TAG_PORT
           │   ││
087  01090 │   ││                       load op, TDC_TIME1_TAG
088  2D002 │   ││                       output op, DATA_TAG_PORT
           │   ││
089        │   ││                       ; Set the fifo_mux_sel to 01 (it was 11)
           │   ││
089  03CF7 │   ││                       and misc_oport_reg, f7         ; Clear bit 3
08A  2DC07 │   ││                       output misc_oport_reg, MISC_OPORT
           │   ││
08B        │   ││                       ; Get and send TIME1 value
           │   ││
08B  01D10 │   ││                       load addr_reg, TIME1
08C  20068 │   ╰──⤙                     call read_tdc
           │    │
08D        │    │                       ; Wait for the FIFO to be ready
           │    │
08D  09100 │    │╭▶             .wait2: input ip, STATUS_IPORT
08E  0D101 │    ││                      test ip, 01                    ; Test bit 0
08F  3208D │    │╰⤙                     jump Z, .wait2
           │    │
090        │    │                       ; Strobe TIME1 data into FIFO
           │    │
090  2D2FE │    │                       output scr0, VALID_PORT
           │    │
091        │    │                       ; Ready to handle TIME2 data!
091        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
091  010A0 │    │                       load op, TDC_TIME2_TAG
092  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
093        │    │                       ; Get TIME2 value
           │    │
093  01D11 │    │                       load addr_reg, TIME2
094  20068 ╰──────⤙                     call read_tdc
           │    │
095        │    │                       ; Wait for the FIFO to be ready
           │    │
095  09100 │    │╭▶             .wait3: input ip, STATUS_IPORT
096  0D101 │    ││                      test ip, 01                    ; Test bit 0
097  32095 │    │╰⤙                     jump Z, .wait3
           │    │
098        │    │                       ; Strobe data into FIFO
           │    │
098  2D2FE │    │                       output scr0, VALID_PORT
           │    │
099        │    │                       ; Ready to handle CALIBRATION1 value
099        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
099  010D0 │    │                       load op, TDC_CAL1_TAG
09A  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
09B        │    │                       ; Get CALIBRATION1 value
           │    │
09B  01D1B │    │                       load addr_reg, CALIBRATION1
09C  20068 ╰──────⤙                     call read_tdc
           │    │
09D        │    │                       ; Wait for the FIFO to be ready
           │    │
09D  09100 │    │╭▶             .wait4: input ip, STATUS_IPORT
09E  0D101 │    ││                      test ip, 01                    ; Test bit 0
09F  3209D │    │╰⤙                     jump Z, .wait4
           │    │
0A0        │    │                       ; Strobe data into FIFO
           │    │
0A0  2D2FE │    │                       output scr0, VALID_PORT
           │    │
0A1        │    │                       ; Ready to handle the CALIBRATION2 value
0A1        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
0A1  010E0 │    │                       load op, TDC_CAL2_TAG
0A2  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
0A3        │    │                       ; Get CALABRATION1 value
           │    │
0A3  01D1C │    │                       load addr_reg, CALIBRATION2
0A4  20068 ╰──────⤙                     call read_tdc
           │    │
0A5        │    │                       ; Wait for the FIFO to be ready
           │    │
0A5  09100 │    │╭▶             .wait5: input ip, STATUS_IPORT
0A6  0D101 │    ││                      test ip, 01                    ; Test bit 0
0A7  320A5 │    │╰⤙                     jump Z, .wait5
           │    │
0A8        │    │                       ; DONE!
           │    │
0A8  2D2FF │    ╰─▶              .done: output scr0, LAST_PORT
0A9  25000 │                            return
           │
0AA        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0AA        │                            ; Subroutine Name: dly_us
           │                            ;
0AA        │                            ; Delay of 1 usec
0AA        │                            ; Delay is [(4 * dly_reg) + 6] / Fclk
0AA        │                            ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │                            ;
0AA        │                            ; Routine uses dly_reg and does not restore it
           │                            ;
0AA        │                            ; 24 (i.e $18) assumes a 100 MHz clock
0AA        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0AA        │                    dly_us:
0AA  01518 ╰───┬┬─▶                     load dly_reg, 24'd
0AB  19501 │   ││╭▶           .wait_us: sub dly_reg, 01
0AC  360AB │   ││╰⤙                     jump NZ, .wait_us
0AD  25000 │   ││                       return
           │   ││
0AE        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0AE        │   ││                       ; Subroutine Name: adc_conv
           │   ││                       ;
0AE        │   ││                       ; Pass in adc_clk_mask and adc_conv_mask
0AE        │   ││                       ; clk_0 is bit 0 of adc_clk_mask
0AE        │   ││                       ; clk_1 is bit 1 of adc_clk_mask
0AE        │   ││                       ; conv_0 is bit 2 of adc_conv_mask
0AE        │   ││                       ; conv_1 is bit 3 of adc_conv_maks
           │   ││                       ;
0AE        │   ││                       ; Uses the cnt register to count clock pulses (16 bit ADC)
0AE        │   ││                       ; but restores cnt register before returning!!!
0AE        │   ││                       ; Use adc_reg but we don’t restore it
           │   ││                       ;
0AE        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
0AE        │   ││             adc_conv:
           │   ││
0AE        │   ││                       ; Save cnt register
           │   ││
0AE  2E4F0 ╭──────▶                     store cnt, (SP)                ; Push
0AF  19F01 │   ││                       sub SP, 01
           │   ││
           │   ││
0B0        │   ││                       ; Bring conv signals high (determined by adc_conv_mask)
0B0        │   ││                       ; The AD7687 ADCs sample PSD analog outputs on the rising
0B0        │   ││                       ; edge of CONV signal
           │   ││
0B0  00680 │   ││                       load adc_reg, adc_conv_mask    ; Make CONV high
0B1  2D601 │   ││                       output adc_reg, ADC_CTL_PORT
           │   ││
0B2        │   ││                       ; Wait for 2 usec
           │   ││
0B2  200AA │   │╰─⤙                     call dly_us
0B3  200AA │   ╰──⤙                     call dly_us
           │
0B4        │                            ; Bring conv signals low
           │
0B4  06680 │                            xor adc_reg, adc_conv_mask
0B5  2D601 │                            output adc_reg, ADC_CTL_PORT
           │
0B6        │                            ; Apply 16 clock pulses (takes about 2 usec)
0B6        │                            ; Reading serial data out of the ADCs
0B6        │                            ; Clocked into shift registers in our custom block
           │
0B6  01410 │                            load cnt, 16'd
0B7  06670 │     ╭▶          .clk_loop: xor adc_reg, adc_clk_mask
0B8  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0B9  06670 │     │                      xor adc_reg, adc_clk_mask
0BA  00EE0 │     │                      load se, se                    ; NOP
0BB  00EE0 │     │                      load se, se                    ; NOP
0BC  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0BD  19401 │     │                      sub cnt, 01
0BE  360B7 │     ╰⤙                     jump NZ, .clk_loop
           │
0BF        │                            ; Restore cnt register
           │
0BF  11F01 │                            add SP, 01                     ; Pop
0C0  0A4F0 │                            fetch cnt, (SP)
           │
           │
0C1  25000 │                            return
           │
0C2        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0C2        │                            ; Name: adc_to_fifo
           │                            ;
0C2        │                            ; Each time this routine is called, it sends the A, B, C, T
0C2        │                            ; adc values to the microblaze FIFO
0C2        │                            ; ip will be used ...should contain PSDx_IPORT (x = 0 or 1)
           │                            ;
0C2        │                            ; Tag format:
           │                            ;
0C2        │                            ; 0		psd addr bit 0
0C2        │                            ; 1		psd addr bit 1
0C2        │                            ; 2		psd addr bit 2
0C2        │                            ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
0C2        │                            ; 4		bit 0 of sc
0C2        │                            ; 5		bit 1 of sc
0C2        │                            ; 6		bit 0 of type
0C2        │                            ; 7		bit 1 of type
           │
0C2        │                            ; type = 00 ---> ADC data
0C2        │                            ; type = 01 ---> Timestamp Counter
0C2        │                            ; type = 10 ---> TDC TIME1 or TIME 2 value
0C2        │                            ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
           │
0C2        │                            ; sc = 00 -----> integrator A
0C2        │                            ; sc = 01 -----> integrator B
0C2        │                            ; sc = 10 -----> integrator C
0C2        │                            ; sc = 11 -----> time
0C2        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0C2        │               adc_to_fifo:
           │                            ;
0C2        │                            ; When we enter the routine, ip should contain PSD0 or PSD1 IPORT
0C2        │                            ; addr_reg will be used ...should contain PSDx_IPORT (x = 0 or 1)
0C2        │                            ; Here is the bit map
0C2        │                            ; NOTE: bit 6 tells us if it is PSD 0 or PSD1
           │                            ;
0C2        │                            ; 0		psd0_or
0C2        │                            ; 1		psd0_token_out
0C2        │                            ; 2		psd0_acq_ack
0C2        │                            ; 3		psd0_addr_out0
0C2        │                            ; 4		psd0_addr_out1
0C2        │                            ; 5		psd0_addr_out2
0C2        │                            ; 6     0 if PSD 0, 1 if PSD 1
0C2        │                            ; 7     0
           │
0C2        │                            ; Push some registers onto stack
           │
0C2  2E4F0 ╭──────▶                     store cnt, (SP)                ; Push
0C3  19F01 │                            sub SP, 01
           │
0C4  2E0F0 │                            store op, (SP)                 ; Push
0C5  19F01 │                            sub SP, 01
           │
0C6  2E1F0 │                            store ip, (SP)                 ; Push
0C7  19F01 │                            sub SP, 01
           │
           │
0C8        │                            ; Shift right 3 places
0C8        │                            ; Lower nybble now contains the channel address (bit 3 is PSD ID)
0C8        │                            ; Upper nybble contains 4’b000
           │
0C8  14D0E │                            sr0 addr_reg
0C9  14D0E │                            sr0 addr_reg
0CA  14D0E │                            sr0 addr_reg
           │
           │
0CB        │                            ; Load cnt to keep track which output we are working on
0CB        │                            ; A, B, C, or T (00, 01, 10, 11)
           │
0CB  01400 │                            load cnt, 00
           │
0CC        │                            ; Use scr1 to keep track of which PSD chip (either 0 or 1)
0CC        │                            ; Inspect bit 3 of ip register to see if it is PSD 0 or PSD 1
           │
0CC  01300 │                            load scr1, 00                  ; PSD 0
0CD  0DD08 │                            test addr_reg, 08              ; Test bit 3
0CE  320D0 │     ╭⤙                     jump Z, .loop
0CF  01301 │     │                      load scr1, 01                  ; PSD 1
           │     │
0D0        │     │                      ; We will write DATA_TAG_PORT first
0D0        │     │                      ; Format of the data tag byte :
0D0        │     │                      ; 	xxyyzzzz
0D0        │     │                      ; 	xx is type (00 = adc, 01 = tstamp, 10 = tdc time, 11 = tdc cal)
0D0        │     │                      ; 	For ADC, yy = sc (00 = A, 01 = B, 10 = C , 11 =T)
0D0        │     │                      ;	For tstamp_counter, yy -> 00 = lower 24 bits, 01 = upper 24 bits
0D0        │     │                      ;	For tdc time, yy = 01 -> TIME1, yy = 10 -> TIME2
0D0        │     │                      ;	For tdc calibration, yy = 01 = CALIBRATION1, yy = 10 -> CALIBRATION2
0D0        │     │                      ; 	zz = 4-bit channel address
           │     │
0D0  000D0 │    ╭┴▶              .loop: load op, addr_reg              ; Load channel address
0D1  00240 │    │                       load scr0, cnt                 ; Copy cnt (i.e. which analog output) to scr0
0D2  14206 │    │                       sl0 scr0
0D3  14206 │    │                       sl0 scr0
0D4  14206 │    │                       sl0 scr0
0D5  14206 │    │                       sl0 scr0
0D6        │    │                       ; Shift left 4 places
0D6  04020 │    │                       or op, scr0                    ; Combine with channel address
0D7  2D002 │    │                       output op, DATA_TAG_PORT       ; Put out our data tag (MSbyte of 32-bit word)
           │    │
0D8        │    │                       ; Now we will now write ADC_CTL_PORT
0D8        │    │                       ; We need to route out the appropriate ADC register to the FIFO using MUX (3 bits)
           │    │
0D8  00040 │    │                       load op, cnt                   ; cnt is either (00 = A, 01 = B, 10 = C, 11 = T)
0D9  14006 │    │                       sl0 op
0DA  14006 │    │                       sl0 op
0DB  14006 │    │                       sl0 op
0DC  14006 │    │                       sl0 op
0DD        │    │                       ; Mux sel is bits 4, 5, 6 of the ADC_CTL_PORT
0DD  0D301 │    │                       test scr1, 01                  ; Test bit 0				; Bit 6 is 0 if PSD 0
0DE  320E0 │    │╭⤙                     jump Z, .skip
0DF  05040 │    ││                      or op, 40                      ; Set bit 6				; Bit 6 is a 1 if PSD 1
0E0  2D001 │    │╰▶              .skip: output op, ADC_CTL_PORT
           │    │                       ;
0E1        │    │                       ; Correct input is now sitting on FIFO input
0E1        │    │                       ; Wait for ’tready’ signal to be active
           │    │                       ;
           │    │
0E1  09100 │    │╭▶         .wait_trdy: input ip, STATUS_IPORT
           │    ││
0E2        │    ││                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │    ││
0E2  0D101 │    ││                      test ip, 01                    ; Test bit 0
0E3  320E1 │    │╰⤙                     jump Z, .wait_trdy
           │    │
0E4        │    │                       ; When FIFO is ready, send data (what we send to vaild port makes no diff)
           │    │
0E4  2D0FE │    │                       output op, VALID_PORT
           │    │
0E5        │    │                       ; Check to see if we are done sending A, B, C, T
0E5        │    │                       ; When cnt is equal to 4, we are done!
           │    │
0E5  11401 │    │                       add cnt, 01
0E6  1D404 │    │                       compare cnt, 04
0E7  360D0 │    ╰─⤙                     jump NZ, .loop
           │
0E8        │                            ; Retrieve registers from stack
           │
0E8  11F01 │                            add SP, 01                     ; Pop
0E9  0A1F0 │                            fetch ip, (SP)
           │
0EA  11F01 │                            add SP, 01                     ; Pop
0EB  0A0F0 │                            fetch op, (SP)
           │
0EC  11F01 │                            add SP, 01                     ; Pop
0ED  0A4F0 │                            fetch cnt, (SP)
           │
           │
0EE  25000 │                            return
           │
0EF        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0EF        │                            ; Name: get_event
           │                            ;
0EF        │                            ; Routine to get a nuclear physics event
           │                            ;
0EF        │                            ; Aquires data from the 4 ADCS (A, B, C, T) for all hit channels on
0EF        │                            ; both PSD chips!
           │                            ;
0EF        │                            ; We look at ORs and keep getting samples until both PSD0 and PSD1 ORs low!
0EF        │                            ; Each time we get A, B, C, T samples, we send them to the FIFO
0EF        │                            ; Each time send a word to the FIFO, we need to write to VALID_PORT (or LAST_PORT)
           │                            ;
0EF        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0EF        │                 get_event:
           │
0EF        │                            ; Set the busy bit (also led[1])
0EF        │                            ; Bit 1 of LED_PORT is led[1] which is also the busy bit!
           │
0EF  05A02 ╭──────▶                     or led_reg, 02                 ; Set bit 1
0F0  2DA00 │                            output led_reg, LED_PORT
           │
0F1        │                            ; We need to set the FIFO mux to select the output of ADC mux
0F1        │                            ; fifo_mux_sel = 00 (bits 2 and 3 of the MISC_IPORT
           │
0F1  03CFB │                            and misc_oport_reg, fb         ; Clear bit 2
0F2  03CF7 │                            and misc_oport_reg, f7         ; Clear bit 3
0F3  2DC07 │                            output misc_oport_reg, MISC_OPORT
           │
0F4        │                            ; Check the ORs out of PSD chips
0F4        │                            ; If both ORs low then we are done!
           │
0F4  01900 ╭┬─┬───▶              .loop: load psd_or_reg, 00
0F5  01600 ││ │                         load adc_reg, 00
           ││ │
0F6  09102 ││ │                         input ip, PSD0_IPORT
0F7  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD0 OR
0F8  320FA ││ │  ╭⤙                     jump Z, .or0
0F9  05901 ││ │  │                      or psd_or_reg, 01              ; Set bit 0			; Make note that PSD0 OR is high
0FA  09103 ││ │  ╰▶               .or0: input ip, PSD1_IPORT
0FB  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD1 OR
0FC  320FE ││ │  ╭⤙                     jump Z, .or1
0FD  05902 ││ │  │                      or psd_or_reg, 02              ; Set bit 1			; Make note that PSD1 OR is high
           ││ │  │                      ;
0FE        ││ │  │                      ; Implement a case statement based on lower two bits of psd_or_reg
           ││ │  │                      ;
           ││ │  │
0FE  1D900 ││ │  ╰▶               .or1: compare psd_or_reg, 00
0FF  3213E ╭──────⤙                     jump Z, .done
100  1D901 ││ │                         compare psd_or_reg, 01
101  32107 ││ │ ╭─⤙                     jump Z, .psd0
102  1D902 ││ │ │                       compare psd_or_reg, 02
103  32117 ││ │╭──⤙                     jump Z, .psd1
104  1D903 ││ │││                       compare psd_or_reg, 03
105  32127 ││╭────⤙                     jump Z, .both
           ││││││                       ;
106        ││││││                       ; Should never happen ... if it does then hang
106        ││││││                       ; Both LEDs will be on and PicoBlaze will be
106        ││││││                       ; non-responsive
           ││││││                       ;
106  22106 ││││││╰▶               .err: jump .err
           ││││││
107        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
107        ││││││                       ;  Only PSD 0 needs attention
107        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           ││││││
107        ││││││                .psd0:
           ││││││
107        ││││││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
107        ││││││                       ; Notablly sel_ext_addr (bit 7) must be low!
107        ││││││                       ; The other bits in port ALSO need to be low
107        ││││││                       ; except for acq_clk (bit 3). It needs to be high.
107        ││││││                       ; PSD chips put out new analog outputs when acq_clk goes high!
           ││││││                       ;
107        ││││││                       ; BUG FIX on 15-Feb-2025
107        ││││││                       ; Important that token_in go low before acq_clk rises
           ││││││
107  01000 │││││╰─▶                     load op, 00
108  2D005 │││││                        output op, PSD0_OPORT          ; Token in low!!!!
109  05008 │││││                        or op, 08                      ; Set bit 3				; acq clk for PSD 0 high
10A  2D005 │││││                        output op, PSD0_OPORT
10B  200AA ╰──────⤙                     call dly_us                    ; Give analog outputs chance to settle
           │││││                        ;
10C        │││││                        ; Set up our masks
           │││││                        ;
10C  01701 │││││                        load adc_clk_mask, 00000001'b
10D  01804 │││││                        load adc_conv_mask, 00000100'b
           │││││
10E        │││││                        ; Perform adc conversion
           │││││
10E  200AE ╰──────⤙                     call adc_conv
           │││││
10F        │││││                        ; Read PSD address
           │││││
10F  09D02 │││││                        input addr_reg, PSD0_IPORT
           │││││
110        │││││                        ; We need to send A, B, C, T off to FIFO
           │││││
110  200C2 ╰──────⤙                     call adc_to_fifo
           │││││
111        │││││                        ; Bring acq_clk low (acq_clk is bit 3)
111        │││││                        ; Resets the hit and active registers
           │││││
111  030F7 │││││                        and op, f7                     ; Clear bit 3			 	; Bring acq clk low
112  2D005 │││││                        output op, PSD0_OPORT
           │││││
113        │││││                        ; Check token out from PSD 0 (token_out is bit 1)
113        │││││                        ; If token_out is HIGH then contine else we are done
           │││││
113  09102 │││││                        input ip, PSD0_IPORT
114  0D102 │││││                        test ip, 02                    ; Test bit 1
115  360F4 │││╰───⤙                     jump NZ, .loop
116  2213E │││╭───⤙                     jump .done
           │││││
117        │││││                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
117        │││││                        ;  Only PSD 1 needs attention
117        │││││                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │││││
117        │││││                 .psd1:
           │││││
117        │││││                        ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
117        │││││                        ; Notablly sel_ext_addr (bit 7) must be low!
117        │││││                        ; The other bits in port ALSO need to be low
117        │││││                        ; except for acq_clk (bit 3). It needs to be high.
           │││││
117  01000 ││││╰──▶                     load op, 00
118  2D006 ││││                         output op, PSD1_OPORT          ;	Token in low
119  05008 ││││                         or op, 08                      ; Set bit 3
11A  2D006 ││││                         output op, PSD1_OPORT          ; 	Bring acq_clk high
11B  200AA ╰──────⤙                     call dly_us
           ││││
11C        ││││                         ; Set up our masks
           ││││
11C  01702 ││││                         load adc_clk_mask, 00000010'b
11D  01808 ││││                         load adc_conv_mask, 00001000'b
           ││││
11E        ││││                         ; Perform adc conversion
           ││││
11E  200AE ╰──────⤙                     call adc_conv
           ││││
11F        ││││                         ; Read PSD address
           ││││
11F  09103 ││││                         input ip, PSD1_IPORT
           ││││
120        ││││                         ; We need to send A, B, C, T off to FIFO
           ││││
120  200C2 ╰──────⤙                     call adc_to_fifo
           ││││
121        ││││                         ; Bring acq_clk low (acq_clk is bit 3)
121        ││││                         ; Resets the hit and active registers
           ││││
121  030F7 ││││                         and op, f7                     ; Clear bit 3
122  2D006 ││││                         output op, PSD1_OPORT
           ││││
123        ││││                         ; Check token out from PSD (token_out is bit 1)
123        ││││                         ; If token_out is HIGH then contine else we are done
           ││││
123  09103 ││││                         input ip, PSD1_IPORT
124  0D102 ││││                         test ip, 02                    ; Test bit 1
125  360F4 │╰─────⤙                     jump NZ, .loop
126  2213E │ ││ ╭─⤙                     jump .done
           │ ││ │
127        │ ││ │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
127        │ ││ │                       ;  Both PSD chips needs attention
127        │ ││ │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │ ││ │
127        │ ││ │                .both:
           │ ││ │
127        │ ││ │                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
127        │ ││ │                       ; Notablly sel_ext_addr (bit 7) must be low!
127        │ ││ │                       ; The other bits in port ALSO need to be low
127        │ ││ │                       ; except for acq_clk (bit 3). It needs to be high.
           │ ││ │
127  01000 │ ╰────▶                     load op, 00
128  2D005 │  │ │                       output op, PSD0_OPORT          ; Token in low
129  2D006 │  │ │                       output op, PSD1_OPORT          ; Token in low
12A  05008 │  │ │                       or op, 08                      ; Set bit 3
12B  2D005 │  │ │                       output op, PSD0_OPORT          ; acq_clk high
12C  2D006 │  │ │                       output op, PSD1_OPORT          ; acq_clk high
12D  200AA ╰──────⤙                     call dly_us                    ; Wait for PSD analog outputs to settle
           │  │ │
12E        │  │ │                       ; Set up our masks
           │  │ │
12E  01703 │  │ │                       load adc_clk_mask, 00000011'b
12F  0180C │  │ │                       load adc_conv_mask, 00001100'b
           │  │ │
130        │  │ │                       ; Perform adc conversion
           │  │ │
130  200AE ╰──────⤙                     call adc_conv
           │  │ │
131        │  │ │                       ; Read PSD 0 address
           │  │ │
131  09602 │  │ │                       input adc_reg, PSD0_IPORT
           │  │ │
132        │  │ │                       ; We need to send A, B, C, T off to FIFO
           │  │ │
132  200C2 ╰──────⤙                     call adc_to_fifo
           │  │ │
133        │  │ │                       ; Read PSD 1 address
           │  │ │
133  09603 │  │ │                       input adc_reg, PSD1_IPORT
           │  │ │
134        │  │ │                       ; We need to send A, B, C, T off to FIFO
           │  │ │
134  200C2 ╰──────⤙                     call adc_to_fifo
           │  │ │
135        │  │ │                       ; Bring acq_clk low (acq_clk is bit 3)
135        │  │ │                       ; Resets the hit and active registers
           │  │ │
135  030F7 │  │ │                       and op, f7                     ; Clear bit 3
136  2D005 │  │ │                       output op, PSD0_OPORT
137  2D006 │  │ │                       output op, PSD1_OPORT
           │  │ │
138        │  │ │                       ; Check token out from PSD (token_out is bit 1)
138        │  │ │                       ; If token_out is HIGH then contine else we are done
           │  │ │
138  09102 │  │ │                       input ip, PSD0_IPORT
139  0D102 │  │ │                       test ip, 02                    ; Test bit 1
13A  360F4 ╰──────⤙                     jump NZ, .loop
           │  │ │
13B  09103 │  │ │                       input ip, PSD1_IPORT
13C  0D102 │  │ │                       test ip, 02                    ; Test bit 1
13D  360F4 ╰──────⤙                     jump NZ, .loop
           │  │ │
13E        │  │ │                       ; We are DONE!
           │  │ │
13E  09100 ╰──┴─┴┬▶              .done: input ip, STATUS_IPORT
13F  0D101 │     │                      test ip, 01                    ; Test bit 0
140  3213E │     ╰⤙                     jump Z, .done
           │
141        │                            ; (1)
141        │                            ; Bring token_in (bit 6) high for bit PSD0 and PSD1
           │                            ;
141  05040 │                            or op, 40                      ; Set bit 6
142  2D005 │                            output op, PSD0_OPORT
143  2D006 │                            output op, PSD1_OPORT
           │
144        │                            ; (2)
144        │                            ; Get and send time data to the FIFO
           │                            ;
144  20074 ╰──────⤙                     call time_to_fifo
           │
145        │                            ; (3)
145        │                            ; Unset the busy flag (busy flag is same as LED 1)
           │                            ;
145  03AFD │                            and led_reg, fd                ; Clear bit 1
146  2DA00 │                            output led_reg, LED_PORT
           │
147  25000 │                            return
           │
148        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148        │                            ; ******* NUCLEAR PHYSICS PROGRAM *********
           │                            ;
148        │                            ; We sit in a tight loop waiting for take_event to go HIGH
148        │                            ; When posedge take_event comes along we call get_event routine.
           │                            ;
148        │                            ; We stay in get_event untill all PSD channels are read out and
148        │                            ; sent back to microblaze using the streaming FIFO.
           │                            ;
148        │                            ; We then wait for take_event to go LOW. We then go back and
148        │                            ; sit in tight loop waiting for next event!
           │                            ;
148        │                            ; led[1] is lit when we are actually in the get_event subroutine
148        │                            ; led[1] is also the busy bit i.e we are in get_event!
           │                            ;
148        │                            ; For time being let’s turn led[0] on whenever take_event is low
148        │                            ; i.e. we are just waiting for an event to come along
           │                            ;
148        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148        │                   nuclear:
           │
148        │                            ; Initialize registers, ports, etc
148        │                            ; If board id is 0 then also configure and start TDC7200
           │
148  20001 ╰──────▶                     call init
           │
149        │                            ; Enable the PSD chips (turn on global enable)
           │
149  05C10 │                            or misc_oport_reg, 10          ; Set bit 4
14A  2DC07 │                            output misc_oport_reg, MISC_OPORT
           │
14B        │                            ; Turn led[0] on (On while we wait for take_event to go high!)
           │
14B  05A01 │    ╭─▶              .loop: or led_reg, 01                 ; Set bit 0
14C  2DA00 │    │                       output led_reg, LED_PORT
           │    │
14D        │    │                       ; Wait for take_event to go HIGH
14D        │    │                       ; Take event is bit 1 of the STATUS_IPORT
           │    │
14D  09100 │    │╭▶             .wait0: input ip, STATUS_IPORT
14E  0D102 │    ││                      test ip, 02                    ; Test bit 1
14F  3214D │    │╰⤙                     jump Z, .wait0
           │    │
150        │    │                       ; First thing we need to do is bring veto_reset
150        │    │                       ; high on PSD chips before they auto_reset and
150        │    │                       ; disable (global enable low!) the PSD chips
           │    │
150  05C02 │    │                       or misc_oport_reg, 02          ; Set bit 1		; Assert veto_reset
151  03CEF │    │                       and misc_oport_reg, ef         ; Clear bit 4		; Disable PSD
152  2D007 │    │                       output op, MISC_OPORT
           │    │
153        │    │                       ; Turn led[0] off since we are now processing an event!
           │    │
153  03AFE │    │                       and led_reg, fe                ; Clear bit 0
154  2DA00 │    │                       output led_reg, LED_PORT
           │    │
155        │    │                       ; Call the get_event routine
155        │    │                       ; Returns once all hit channels are read out!
155        │    │                       ; While we are in get_event the busy bit is set
           │    │
155        │    │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
155  200EF ╰──────⤙                     call get_event
156             │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                │
156             │                       ; Wait for take_event to go INACTIVE (bit 1 of STATUS_IPORT)
                │
156  09100      │╭▶             .wait1: input ip, STATUS_IPORT
157  0D102      ││                      test ip, 02                    ; Test bit 1
158  36156      │╰⤙                     jump NZ, .wait1
                │
159             │                       ; De-assert veto_reset
                │
159  03CFD      │                       and misc_oport_reg, fd         ; Clear bit 1
15A  2D007      │                       output op, MISC_OPORT
                │
15B             │                       ; Force a reset (about 1 usec long)
15B             │                       ; Shouldn’t be necessary but doesn’t hurt
15B             │                       ; We want to be absolutely sure analog blocks
15B             │                       ; are in reset when we enable psd chips!
                │
15B  05C01      │                       or misc_oport_reg, 01          ; Set bit 0
15C  2DC07      │                       output misc_oport_reg, MISC_OPORT
15D  00EE0      │                       load se, se                    ; NOP
15E  00EE0      │                       load se, se                    ; NOP
15F  03CFE      │                       and misc_oport_reg, fe         ; Clear bit 0
160  2DC07      │                       output misc_oport_reg, MISC_OPORT
                │
161             │                       ; Go back and wait for the next event
                │
161  2214B      ╰─⤙                     jump .loop                     ;

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/gle/VIVADO_FPGA/Cmod-A7-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CALIBRATION1       1b     pico_program.psm
    CALIBRATION2       1c     pico_program.psm
    CONFIG1            40     pico_program.psm
    CONFIG1_VAL        01     pico_program.psm
    CONFIG2            41     pico_program.psm
    CONFIG2_VAL        01     pico_program.psm
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    MISC_OPORT         07     pico_program.psm
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
    PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CAL1_TAG       d0     pico_program.psm
    TDC_CAL2_TAG       e0     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    TDC_TIME1_TAG      90     pico_program.psm
    TDC_TIME2_TAG      a0     pico_program.psm
    TIME1              10     pico_program.psm
    TIME2              11     pico_program.psm
    TSTAMP_LOWER_TAG   40     pico_program.psm
    TSTAMP_UPPER_TAG   50     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      15
    datestamp_month    03
    datestamp_year     19
    timestamp_hours    09
    timestamp_minutes  2C
    timestamp_seconds  0D


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "21 Mar 2025"
    timestamp$       "09:44:13"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv               0AE   pico_program.psm
    adc_conv.clk_loop      0B7   pico_program.psm
    adc_to_fifo            0C2   pico_program.psm
    adc_to_fifo.loop       0D0   pico_program.psm
    adc_to_fifo.skip       0E0   pico_program.psm
    adc_to_fifo.wait_trdy  0E1   pico_program.psm
    clr_tdc_reg            02A   pico_program.psm
    config_tdc             050   pico_program.psm
    dly_us                 0AA   pico_program.psm
    dly_us.wait_us         0AB   pico_program.psm
    get_event              0EF   pico_program.psm
    get_event.both         127   pico_program.psm
    get_event.done         13E   pico_program.psm
    get_event.err          106   pico_program.psm
    get_event.loop         0F4   pico_program.psm
    get_event.or0          0FA   pico_program.psm
    get_event.or1          0FE   pico_program.psm
    get_event.psd0         107   pico_program.psm
    get_event.psd1         117   pico_program.psm
    init                   001   pico_program.psm
    init.done              024   pico_program.psm
    my_isr                 380   pico_program.psm
    nuclear                148   pico_program.psm
    nuclear.loop           14B   pico_program.psm
    nuclear.wait0          14D   pico_program.psm
    nuclear.wait1          156   pico_program.psm
 *  origin                 000   pico_program.psm
    read_tdc               068   pico_program.psm
    start_tdc              062   pico_program.psm
    start_tdc.done         067   pico_program.psm
    tdc_csb_high           04D   pico_program.psm
    tdc_csb_low            04A   pico_program.psm
    tdc_ena                030   pico_program.psm
    tdc_init               036   pico_program.psm
    tdc_reg_clk            025   pico_program.psm
    tdc_serial             03C   pico_program.psm
    tdc_serial.clk_loop    03F   pico_program.psm
    time_to_fifo           074   pico_program.psm
    time_to_fifo.done      0A8   pico_program.psm
    time_to_fifo.wait0     079   pico_program.psm
    time_to_fifo.wait1     081   pico_program.psm
    time_to_fifo.wait2     08D   pico_program.psm
    time_to_fifo.wait3     095   pico_program.psm
    time_to_fifo.wait4     09D   pico_program.psm
    time_to_fifo.wait5     0A5   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          5
   ADDCY        -
   AND          21
   CALL         38
   CALL@        -
   COMPARE      5
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        7
   HWBUILD      -
   INPUT        21
   JUMP         35
   JUMP@        -
   LOAD         59
   LOAD&RETURN  -
   OR           26
   OUTPUT       76
   OUTPUTK      -
   REGBANK      -
   RETURN       16
   RETURNI      1
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          3
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        5
   SUB          7
   SUBCY        -
   TEST         18
   TESTCY       -
   XOR          5
