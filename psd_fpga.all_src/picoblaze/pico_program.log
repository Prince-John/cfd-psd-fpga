Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2025-09-30T14:33:43
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 365
  Memory locations available: 3731
  Scratchpad size: 256


Assembly listing
----------------
000                                     ; ################################################
000                                     ; NOTE:  All PicoBlaze instructions take 2 clock
000                                     ; cycles so 20 ns (100 MHz clock)
000                                     ; ################################################
                                        ;
000                                     ; GLE: 11-Feb-2025
000                                     ; Adding the support we need for TDC7200
                                        ;
000                                     ; GLE: 15-Feb-2025
000                                     ; Continuing to add TDC support
000                                     ; Fixed bug in get_event routine
000                                     ; Important that token_in go low before
000                                     ; acq_clk goes high!
                                        ;
000                                     ; GLE: 17-Feb-2025
000                                     ; Finished program BUT still needs to be tested!
000                                     ; Fixed a bug -> veto_reset should go low after take_event goes low
                                        ;
000                                     ; GLE: 19-Mar-2025
000                                     ; Reviewing to make sure everything is complete and working

000                                     ; ********************************************
000                                     ; Output ports (we have 8 "real" output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast strobes
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED 0
000                                     ; 1		LED 1 (also the busy bit!)
000                                     ; 2 		PICO Debug Flag 0
000                                     ; 3 		PICO Debug Flag 1
000                                     ; 	.
000                                     ; 	.
000                                     ; 	.
000                                     ; 7 		PICO Debug Flag 5
                                        ;
000                                     ; Prince - March 30: Used remaining bits to bring out 6 debug flag signals.



000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Timestamp Counter (upper and lower)
000                                     ; type = 10 ---> TDC TIME1 or TIME 2 value
000                                     ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
                                        ;
000                                     ; For type = 00
000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time
                                        ;
000                                     ; For types 01, 10, 11
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6		tdc_csb
000                                     ; 7		tdc_enable

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     constant MISC_OPORT, 07

000                                     ; --------------------------------
000                                     ; PORT 7 (Misc outputs)
000                                     ; --------------------------------
                                        ;
000                                     ; 0 	force_psd_reset
000                                     ; 1		veto_reset
000                                     ; 2		fifo_mux_sel[0]
000                                     ; 3		fifo_mux_sel[1]
000                                     ; 4		psd_glob_ena
                                        ;
000                                     ; fifo_mux_sel = 00 -> adc_data (adc_reg)
000                                     ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
000                                     ; fifo_mux_sel = 10 -> tstamp counter (lower)
000                                     ; fifo_mux_sel = 11 -> tstamp counter (upper)

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2		tdc_intb (interrupt signal from TDC7200)
000                                     ; [3:7] 0

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]
000                                     ; 6     0
000                                     ; 7     0

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)
000                                     ; 7     0

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)
000                                     ; 7     0

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; We can use s0 - sd, se and sf are special
000                                     ; Give more desciptive names to some of our registers
000                                     ; The scratch registers get used but not restored!
000                                     ; Other regs tend to be saved on the stack!
                                        ;
000                                     namereg s0, op                 ; Output port register
000                                     namereg s1, ip                 ; Input port register
000                                     namereg s2, scr0               ; Scratchpad register 0 (scratch)
000                                     namereg s3, scr1               ; Scratchpad register 1 (scratch)
000                                     namereg s4, cnt                ; Used for counting "things"
000                                     namereg s5, dly_reg            ; Used in delay_1us routine
000                                     namereg s6, adc_reg            ; Used by adc routine
000                                     namereg s7, adc_clk_mask       ; Defines which adc clocks are to be used
000                                     namereg s8, adc_conv_mask      ; Defines which adc conv signals are to be used
000                                     namereg s9, psd_or_reg         ; Lower 2 bits keep track of PSD1 and PSD0 ORs
000                                     namereg sa, led_reg            ; State of LED_PORT
000                                     namereg sb, tdc_ctl_reg        ; State of TDC_CTL_PORT
000                                     namereg sc, misc_oport_reg     ; State of MISC_OPORT
000                                     namereg sd, addr_reg           ; Holds PSD channel address and TDC7200 addresses

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; Register se is also special
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Read the board id port and store it in scratchpad memory

000                                     constant BOARD_ID, 00


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; TDC7200 address map (no auto-increment i.e. bit 7 is 0)
000                                     ; Read/Write control is bit 6 where set means WRITE!!!!
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Address of CONFIG1 register (with write bit set!)

000                                     constant CONFIG1, 40


000                                     ; Address of CONFIG2 register (with write bit set!)

000                                     constant CONFIG2, 41


000                                     ; Address of TIME1 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME1, 10


000                                     ; Address of TIME2 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME2, 11


000                                     ; Address of CALIBRATION1 register (with write bit cleared!)

000                                     constant CALIBRATION1, 1b


000                                     ; Address of CALIBRATION2 register (with write bit cleared!)

000                                     constant CALIBRATION2, 1c


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Configuration values
                                        ;
000                                     ; We want Mode 1, 2 calibration cycles, 2 stops, ave cycles = 0
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Value we want to load into CONFIG1 register
000                                     ; Bit 0 is set so it will start measurement when value written

000                                     constant CONFIG1_VAL, 01


000                                     ; Value we want to load into CONFIG2 register

000                                     constant CONFIG2_VAL, 01


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Data id tag bytes when working with time data
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Here is the mapping
                                        ;
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TSTAMP_LOWER_TAG, 40

000                                     constant TSTAMP_UPPER_TAG, 50

000                                     constant TDC_TIME1_TAG, 90

000                                     constant TDC_TIME2_TAG, a0

000                                     constant TDC_CAL1_TAG, d0

000                                     constant TDC_CAL2_TAG, e0


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000
000  22153 ╭──────⤙             origin: jump nuclear
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
           │                            ;
001        │                            ; Initialize the stack pointer, SP
001        │                            ; Initialize registers and ports
001        │                            ; Read board id and save
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ; Read the board id from port and save it to scratchpad memory location 0
           │
002  09201 │                            input scr0, BOARD_ID_PORT
003  2F200 │                            store scr0, BOARD_ID
           │
004        │                            ; Clear  registers
           │
004  01000 │                            load op, 00
005  01100 │                            load ip, 00
006  01200 │                            load scr0, 00
007  01300 │                            load scr1, 00
008  01400 │                            load cnt, 00
009  01500 │                            load dly_reg, 00
00A  01600 │                            load adc_reg, 00
00B  01700 │                            load adc_clk_mask, 00
00C  01800 │                            load adc_conv_mask, 00
00D  01900 │                            load psd_or_reg, 00
00E  01A00 │                            load led_reg, 00
00F  01B00 │                            load tdc_ctl_reg, 00
010  01C00 │                            load misc_oport_reg, 00
011  01D00 │                            load addr_reg, 00
           │
012        │                            ; Clear the output port registers
           │
012  2D200 │                            output scr0, LED_PORT          ; turn off LEDs
013  2D202 │                            output scr0, DATA_TAG_PORT
014  2D203 │                            output scr0, TDC_DATA_PORT
           │
015        │                            ; Bring tdc_csb (bit 6) high
015        │                            ; Rest of signals low
           │
015  05B40 │                            or tdc_ctl_reg, 40             ; Set bit 6
016  2DB04 │                            output tdc_ctl_reg, TDC_CTL_PORT
           │
017        │                            ; Need to reset the tdc_reg
017        │                            ; Synchronous reset (bit 3) so we need to apply a clock pulse
           │
017  2002B │   ╭──⤙                     call clr_tdc_reg
           │   │
018        │   │                        ; Reset the ADC shift registers
018        │   │                        ; Bring reset bit high in adc_reg and then back low
018        │   │                        ; Bit 7 of adc_reg is the reset adc registers bit
018        │   │                        ; Clock and conv signals low
018        │   │                        ; Mux selects (3’b000) choosing adc reg for PSD0 A integrator
018        │   │                        ; Pulse the adc reg reset line
           │   │
018  05680 │   │                        or adc_reg, 80                 ; Set bit 7
019  2D601 │   │                        output adc_reg, ADC_CTL_PORT
01A  0367F │   │                        and adc_reg, 7f                ; Clear bit 7
01B  2D601 │   │                        output adc_reg, ADC_CTL_PORT
           │   │
01C        │   │                        ; Make sure that tokens into the PSD chips are HIGH (inactive)
01C        │   │                        ; token_in for the PSD ports is bit 6
01C        │   │                        ; Others bit should be low
           │   │
01C  05040 │   │                        or op, 40                      ; Set bit 6
01D  2D005 │   │                        output op, PSD0_OPORT
01E  2D006 │   │                        output op, PSD1_OPORT
           │   │
01F        │   │                        ; Bring the force_reset and veto_reset pins low on both PSD chips
01F        │   │                        ; force_reset is bit 0
01F        │   │                        ; veto_reset is bit 1
01F        │   │                        ; fifo_mux_sel (bits 2 and 3) is 00 (i.e. selecting adc_reg)
01F        │   │                        ; Make psd_global_ena (bit 4) low
           │   │
01F  01C00 │   │                        load misc_oport_reg, 00
020  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
021        │   │                        ; We need to initialize the timestamp stuff if we are board 0
           │   │
021  0B200 │   │                        fetch scr0, BOARD_ID
022  1D200 │   │                        compare scr0, 00
023  36025 │   │ ╭⤙                     jump NZ, .done
           │   │ │
024        │   │ │                      ; If we are board 0, then we need to initialize the TDC7200 chip
           │   │ │
024  20037 │   │╭─⤙                     call tdc_init
           │   │││
025        │   │││                      ; Done so return
           │   │││
025  25000 │   ││╰▶              .done: return
           │   ││
026        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
026        │   ││                       ; Collection of support routines for timestamp creation.
           │   ││                       ;
026        │   ││                       ; We will used tdc_ctl_reg to keep state
026        │   ││                       ; of the TDC_CTL_PORT
           │   ││                       ;
026        │   ││                       ; --------------------------------
026        │   ││                       ; PORT 4 (TDC register control)
026        │   ││                       ; --------------------------------
026        │   ││                       ; 0		tdc_reg_ld_0
026        │   ││                       ; 1		tdc_reg_ld_1
026        │   ││                       ; 2		tdc_reg_ld_2
026        │   ││                       ; 3		tdc_reg_rst
026        │   ││                       ; 4		tdc_reg_shift
026        │   ││                       ; 5		tdc_reg_sclk
026        │   ││                       ; 6		tdc_csb
026        │   ││                       ; 7		tdc_enable
026        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │   ││
026        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
026        │   ││                       ; Subroutine Name: tdc_reg_clk
           │   ││                       ;
026        │   ││                       ; Routine to apply a single clock pulse to tdc_reg
026        │   ││                       ; Doesn’t effect TDC7200 because tdc_csb should be high
026        │   ││                       ; when we apply the single clock pulse.  Pulse is needed
026        │   ││                       ; for synchronous reset and sychronous load of tdc_reg
026        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
026  05B20 ╭─────┬▶        tdc_reg_clk: or tdc_ctl_reg, 20             ; Set bit 5
027  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk high
028  03BDF │   │││                      and tdc_ctl_reg, df            ; Clear bit 5
029  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk low
02A  25000 │   │││                      return
           │   │││
02B        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
02B        │   │││                      ; Subroutine Name: clr_tdc_reg
           │   │││                      ;
02B        │   │││                      ; Clears the tdc register in our timstamp_interface module
02B        │   │││                      ; The clear (bit 3) is synchronous so we need to apply a clock pulse
           │   │││                      ;
02B        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │││
02B  05B08 ╭┬──┴──▶        clr_tdc_reg: or tdc_ctl_reg, 08             ; Set bit 3
02C  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
02D  20026 ││   │╰⤙                     call tdc_reg_clk
02E  03BF7 ││   │                       and tdc_ctl_reg, f7            ; Clear bit 3
02F  2DB04 ││   │                       output tdc_ctl_reg, TDC_CTL_PORT
030  25000 ││   │                       return
           ││   │
031        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
031        ││   │                       ; Subroutine Name: tdc_ena
           ││   │                       ;
031        ││   │                       ; This routine will enable the TDC7200
031        ││   │                       ; We do this by bringing the tdc_enable (Bit 7) low
031        ││   │                       ; and then bring it high. Enable must be high
031        ││   │                       ; for TDC7200 to perform conversions.
031        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   │
031  03B7F ││   │╭▶            tdc_ena: and tdc_ctl_reg, 7f            ; Clear bit 7
032  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
033  200AB ╭──────⤙                     call dly_us
034  05B80 ││   ││                      or tdc_ctl_reg, 80             ; Set bit 7
035  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
036  25000 ││   ││                      return
037        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
037        ││   ││                      ; Subroutine Name: tdc_init
           ││   ││                      ;
037        ││   ││                      ; Routine to initialize the TDC7200 and related circuits
037        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   ││
037        ││   ││            tdc_init:
           ││   ││
037        ││   ││                      ; Enable the TDC7200
037        ││   ││                      ; This only needs to be done once
037        ││   ││                      ; Brings tdc_ena low and then high!
           ││   ││
037  20031 ││   ╰┴▶                     call tdc_ena
           ││
038        ││                           ; Load config data into CONFIG2 register
038        ││                           ; This only needs to be done once!!!!!
038        ││                           ; addr_reg needs to be loaded with address
038        ││                           ; op needs to be loaded with value to be stored at address
           ││
038  01D41 ││                           load addr_reg, CONFIG2
039  01001 ││                           load op, CONFIG2_VAL
03A  20051 ││ ╭───⤙                     call config_tdc
           ││ │
03B        ││ │                         ; Start a TDC7200 measurement!
           ││ │
03B  20063 ╭──────⤙                     call start_tdc
           ││ │
03C  25000 ││ │                         return
           ││ │
03D        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03D        ││ │                         ; Subroutine Name: tdc_serial
           ││ │                         ;
03D        ││ │                         ; Routine to send and receive serial dataa
03D        ││ │                         ; from TDC7200. Used to send both internal
03D        ││ │                         ; register address and data to the TDC7200
           ││ │                         ;
03D        ││ │                         ; We should enter with cnt register containing
03D        ││ │                         ; number of clock pulses we want
           ││ │                         ;
03D        ││ │                         ; Make sure the tdc_csb is LOW when this routine
03D        ││ │                         ; is called!
           ││ │                         ;
03D        ││ │                         ; Minimum sclk period for the TDC7200 is 50 ns
           ││ │                         ;
03D        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││ │
03D        ││ │             tdc_serial:
           ││ │
03D        ││ │                         ; Bring the shift control on tdc register high!
           ││ │
03D  05B10 ╭─┬────▶                     or tdc_ctl_reg, 10             ; Set bit 4
03E  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
03F        ││││                         ; Apply clock pulses (number in cnt register)
03F        ││││                         ; Use scr0 as a clock mask (tdc_sclk is bit 5)
           ││││
03F  01220 ││││                         load scr0, 00100000'b
040  06B20 ││││  ╭▶          .clk_loop: xor tdc_ctl_reg, scr0
041  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
042  00EE0 ││││  │                      load se, se                    ; NOP
043  00EE0 ││││  │                      load se, se                    ; NOP
044  06B20 ││││  │                      xor tdc_ctl_reg, scr0
045  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
046  19401 ││││  │                      sub cnt, 01
047  36040 ││││  ╰⤙                     jump NZ, .clk_loop
           ││││
048        ││││                         ; Bring the shift control on tdc register low!
           ││││
048  03BEF ││││                         and tdc_ctl_reg, ef            ; Clear bit 4
049  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
04A  25000 ││││                         return
           ││││                         ;
04B        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04B        ││││                         ; Subroutine Name: tdc_csb_low
           ││││                         ;
04B        ││││                         ; Bring TDC7200 csb pin low (bit 6 of TDC_CTL_PORT)
04B        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││
04B  03BBF ╭─────┬▶        tdc_csb_low: and tdc_ctl_reg, bf            ; Clear bit 6
04C  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
04D  25000 ││││  │                      return
           ││││  │                      ;
04E        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04E        ││││  │                      ; Subroutine Name: tdc_csb_high
           ││││  │                      ;
04E        ││││  │                      ; Bring TDC7200 CSB pin high (bit 6 of TDC_CTL_PORT)
04E        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││  │
04E  05B40 ╭────┬─▶       tdc_csb_high: or tdc_ctl_reg, 40             ; Set bit 6
04F  2DB04 ││││ ││                      output tdc_ctl_reg, TDC_CTL_PORT
050  25000 ││││ ││                      return
           ││││ ││
051        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
051        ││││ ││                      ; Subroutine Name: config_tdc
           ││││ ││                      ;
051        ││││ ││                      ; When we enter, addr_reg should contain the configuration
051        ││││ ││                      ; register address we want to load, either CONFGI1 or CONFIG2
           ││││ ││                      ;
051        ││││ ││                      ; Also, when we enter, op register should contain the
051        ││││ ││                      ; configuration value, wither CONFIG1_VAL ore CONFIG2_VAL
           ││││ ││                      ;
051        ││││ ││                      ; Loads the TDC7200 CONFIG1 or CONFIG2 register
051        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││ ││
051  2002B │╰─┴┬──⤙         config_tdc: call clr_tdc_reg
           │ │ │││
052        │ │ │││                      ; Load address information and write to TDC_DATA_PORT
052        │ │ │││                      ; addr_reg is passed into routine and contains address
052        │ │ │││                      ; of TDC7200 register we want to load!
           │ │ │││
052  2DD03 │ │ │││                      output addr_reg, TDC_DATA_PORT
           │ │ │││
053        │ │ │││                      ; Assert ld[2] control (most significant byte of tdc register)
053        │ │ │││                      ; Synchronous load so we need to apply a clock pulse!
053        │ │ │││                      ; ld[2] is bit 2 pf the TDC_CTL_PORT
           │ │ │││
053  05B04 │ │ │││                      or tdc_ctl_reg, 04             ; Set bit 2
054  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
055  20026 ╰──────⤙                     call tdc_reg_clk
056  03BFB │ │ │││                      and tdc_ctl_reg, fb            ; Clear bit 2
057  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
058        │ │ │││                      ; Write value to TDC_DATA_PORT
058        │ │ │││                      ; The op register is passed into routine and contains the data value
           │ │ │││
058  2D003 │ │ │││                      output op, TDC_DATA_PORT
           │ │ │││
059        │ │ │││                      ; Assert ld[1] control (middle byte of tdc register)
059        │ │ │││                      ; ld[1] is bit 1 of TDC_CTL_PORT
           │ │ │││
059  05B02 │ │ │││                      or tdc_ctl_reg, 02             ; Set bit 1
05A  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
05B  20026 ╰──────⤙                     call tdc_reg_clk
05C  03BFD │ │ │││                      and tdc_ctl_reg, fd            ; Clear bit 1
05D  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
05E        │ │ │││                      ; Bring tdc_csb pin low (active)
           │ │ │││
05E  2004B │ │ ││╰⤙                     call tdc_csb_low
           │ │ ││
05F        │ │ ││                       ; Load cnt with the number of clock pulses we want i.e. 16
05F        │ │ ││                       ; We need 8 clocks to load register address and 8 to load the value
05F        │ │ ││                       ; Address goes in first followed by data
           │ │ ││
05F  01410 │ │ ││                       load cnt, 16'd
           │ │ ││
060        │ │ ││                       ; Call our TDC serial routine
           │ │ ││
060  2003D │ ╰────⤙                     call tdc_serial
           │   ││
061        │   ││                       ; Bring tdc_csb pin high (inactive)
           │   ││
061  2004E │   │╰─⤙                     call tdc_csb_high
           │   │
062  25000 │   │                        return
           │   │
063        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
063        │   │                        ; Subroutine Name: start_tdc
           │   │                        ;
063        │   │                        ; This routine will start a measurement on TDC7200
063        │   │                        ; if this board 0.
           │   │                        ;
063        │   │                        ; Measurements are started by writing to CONFIG1 with
063        │   │                        ; the least significant bit set!
           │   │                        ;
063        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
063        │   │             start_tdc:
           │   │
063        │   │                        ; Fetch the board id
           │   │
063  0B200 ╰──────▶                     fetch scr0, BOARD_ID
064        │   │                        ;compare 	scr0, 00
064  32068 │   │ ╭⤙                     jump Z, .done
           │   │ │
065        │   │ │                      ; Start the TDC7200 since the board is 0
065        │   │ │                      ; We start the TDC7200 by writing to CONFIG1
           │   │ │
065  01D40 │   │ │                      load addr_reg, CONFIG1
066  01001 │   │ │                      load op, CONFIG1_VAL
067  20051 │   ╰──⤙                     call config_tdc
           │     │
068        │     │                      ; We are done, so return!
           │     │
068  25000 │     ╰▶              .done: return
           │
069        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
069        │                            ; Subroutine Name: read_tdc
           │                            ;
069        │                            ; Reads a 24-bit register from the TDC7200
           │                            ;
069        │                            ; When we enter, addr_reg should contain the register we
069        │                            ; want to read from, either TIME1, TIME2, CALIBRATION1,
069        │                            ; or CALIBRATION2
           │                            ;
069        │                            ; Takes a total of 32 clock pulses to do the read
069        │                            ; First 8 loads the register address and then last 24
069        │                            ; clocks read out the data
069        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
069  2002B ╰───┬──⤙           read_tdc: call clr_tdc_reg               ; clears all 24-bits of tdc_reg
           │   │
06A        │   │                        ; Load address information and write to TDC_DATA_PORT
           │   │
06A  2DD03 │   │                        output addr_reg, TDC_DATA_PORT
           │   │
06B        │   │                        ; Assert ld[2] control (most significant byte of tdc register)
06B        │   │                        ; Load address of register into ms byte of tdc_reg
06B        │   │                        ; Synchronous load so we need to apply clock pulse
           │   │
06B  05B04 │   │                        or tdc_ctl_reg, 04             ; Set bit 2
06C  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
06D  20026 ╰──────⤙                     call tdc_reg_clk
06E  03BFB │   │                        and tdc_ctl_reg, fb            ; Clear bit 2
06F  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
           │   │
070        │   │                        ; Bring tdc_csb pin low (active)
           │   │
070  2004B ╰──────⤙                     call tdc_csb_low
           │   │
071        │   │                        ; Load cnt register with the number of clock pulses we want i.e. 8
071        │   │                        ; It takes 8 clock pulses to load the register address (with write bit set)
071        │   │                        ; and then 24 clocks to read the data so a total of 32 clock pulse
           │   │
071  01420 │   │                        load cnt, 32'd
           │   │
072        │   │                        ; Call our TDC serial routine
           │   │
072  2003D ╰──────⤙                     call tdc_serial
           │   │
073        │   │                        ; Bring tdc_csb pin high (inactive)
           │   │
073  2004E ╰──────⤙                     call tdc_csb_high
           │   │
074  25000 │   │                        return
           │   │
075        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
075        │   │                        ; Subroutine Name: time_to_fifo
           │   │                        ;
075        │   │                        ; Routine sends time related data to the FIFO
           │   │                        ;
075        │   │                        ;	constant	TSTAMP_LOWER_TAG, 40
075        │   │                        ;	constant	TSTAMP_UPPER_TAG, 50
075        │   │                        ;	constant	TDC_TIME1_TAG, 90
075        │   │                        ;	constant	TDC_TIME2_TAG, a0
075        │   │                        ;	constant	TDC_CAL1_TAG, d0
075        │   │                        ;	constant	TDC_CAL2_TAG, e0
           │   │                        ;
075        │   │                        ; PORT 7 (MISC_OPORT)
           │   │                        ;
075        │   │                        ; 0 	force_psd_reset
075        │   │                        ; 1		veto_reset
075        │   │                        ; 2		fifo_mux_sel[0]
075        │   │                        ; 3		fifo_mux_sel[1]
075        │   │                        ; 4		psd_glob_ena
           │   │                        ;
075        │   │                        ; fifo_mux_sel = 00 -> adc_data (adc_reg)
075        │   │                        ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
075        │   │                        ; fifo_mux_sel = 10 -> tstamp counter (lower)
075        │   │                        ; fifo_mux_sel = 11 -> tstamp counter (upper)
           │   │                        ;
075        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
075        │   │          time_to_fifo:
           │   │
075        │   │                        ; Send tstamp_counter (lower 24 bits)
075        │   │                        ; Start by writing out correct data tag
           │   │
075  01040 ╭──────▶                     load op, TSTAMP_LOWER_TAG
076  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
077        │   │                        ; Set the fifo_mux_sel to 10
           │   │
077  05C08 │   │                        or misc_oport_reg, 08          ; Set bit 3
078  03CFB │   │                        and misc_oport_reg, fb         ; Clear bit 2
079  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
07A        │   │                        ; Wait for FIFO to be ready
07A        │   │                        ; Set the status bit LED[2] to high before starting to wait for tready
           │   │
07A        │   │                .wait0:
07A  09100 │   │ ╭▶                     input ip, STATUS_IPORT
           │   │ │
07B        │   │ │                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │   │ │
07B  0D101 │   │ │                      test ip, 01                    ; Test bit 0
07C  3207A │   │ ╰⤙                     jump Z, .wait0
           │   │
           │   │
07D        │   │                        ; When FIFO is ready, send data (what we send to vaild port makes no diff)
07D        │   │                        ; Writing to the VALID_port, strobes the tvalid control signal!
           │   │
07D  2D2FE │   │                        output scr0, VALID_PORT
           │   │
07E        │   │                        ; Send tstamp counter (upper 24 bits)
           │   │
07E  01050 │   │                        load op, TSTAMP_UPPER_TAG
07F  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
080        │   │                        ; Set the fifo_mux_sel to 11 (it was 10)
           │   │
080  05C04 │   │                        or misc_oport_reg, 04          ; Set bit 2
081  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
082        │   │                        ; Wait for FIFO to be ready
           │   │
082        │   │                .wait1:
082  09100 │   │ ╭▶                     input ip, STATUS_IPORT
083  0D101 │   │ │                      test ip, 01                    ; Test bit 0
084  32082 │   │ ╰⤙                     jump Z, .wait1
           │   │
           │   │
085        │   │                        ; Need to check if we are board 0 or not?
085        │   │                        ; The board ID is saved in scratchpad memory
085        │   │                        ; If not board 0, then got DONE!
           │   │
085  0B200 │   │                        fetch scr0, BOARD_ID
086        │   │                        ;compare 	scr0, 00
086  360A9 │   │╭─⤙                     jump NZ, .done
           │   ││
087        │   ││                       ; This is board 0!
           │   ││
087  2D2FE │   ││                       output scr0, VALID_PORT
           │   ││
088        │   ││                       ; Send tag to DATA_TAG_PORT
           │   ││
088  01090 │   ││                       load op, TDC_TIME1_TAG
089  2D002 │   ││                       output op, DATA_TAG_PORT
           │   ││
08A        │   ││                       ; Set the fifo_mux_sel to 01 (it was 11)
           │   ││
08A  03CF7 │   ││                       and misc_oport_reg, f7         ; Clear bit 3
08B  2DC07 │   ││                       output misc_oport_reg, MISC_OPORT
           │   ││
08C        │   ││                       ; Get and send TIME1 value
           │   ││
08C  01D10 │   ││                       load addr_reg, TIME1
08D  20069 │   ╰──⤙                     call read_tdc
           │    │
08E        │    │                       ; Wait for the FIFO to be ready
           │    │
08E        │    │               .wait2:
08E  09100 │    │╭▶                     input ip, STATUS_IPORT
08F  0D101 │    ││                      test ip, 01                    ; Test bit 0
090  3208E │    │╰⤙                     jump Z, .wait2
           │    │
           │    │
091        │    │                       ; Strobe TIME1 data into FIFO
           │    │
091  2D2FE │    │                       output scr0, VALID_PORT
           │    │
092        │    │                       ; Ready to handle TIME2 data!
092        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
092  010A0 │    │                       load op, TDC_TIME2_TAG
093  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
094        │    │                       ; Get TIME2 value
           │    │
094  01D11 │    │                       load addr_reg, TIME2
095  20069 ╰──────⤙                     call read_tdc
           │    │
096        │    │                       ; Wait for the FIFO to be ready
           │    │
096  09100 │    │╭▶             .wait3: input ip, STATUS_IPORT
097  0D101 │    ││                      test ip, 01                    ; Test bit 0
098  32096 │    │╰⤙                     jump Z, .wait3
           │    │
099        │    │                       ; Strobe data into FIFO
           │    │
099  2D2FE │    │                       output scr0, VALID_PORT
           │    │
09A        │    │                       ; Ready to handle CALIBRATION1 value
09A        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
09A  010D0 │    │                       load op, TDC_CAL1_TAG
09B  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
09C        │    │                       ; Get CALIBRATION1 value
           │    │
09C  01D1B │    │                       load addr_reg, CALIBRATION1
09D  20069 ╰──────⤙                     call read_tdc
           │    │
09E        │    │                       ; Wait for the FIFO to be ready
           │    │
09E  09100 │    │╭▶             .wait4: input ip, STATUS_IPORT
09F  0D101 │    ││                      test ip, 01                    ; Test bit 0
0A0  3209E │    │╰⤙                     jump Z, .wait4
           │    │
           │    │
0A1        │    │                       ; Strobe data into FIFO
           │    │
0A1  2D2FE │    │                       output scr0, VALID_PORT
           │    │
0A2        │    │                       ; Ready to handle the CALIBRATION2 value
0A2        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
0A2  010E0 │    │                       load op, TDC_CAL2_TAG
0A3  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
0A4        │    │                       ; Get CALABRATION1 value
           │    │
0A4  01D1C │    │                       load addr_reg, CALIBRATION2
0A5  20069 ╰──────⤙                     call read_tdc
           │    │
0A6        │    │                       ; Wait for the FIFO to be ready
           │    │
0A6  09100 │    │╭▶             .wait5: input ip, STATUS_IPORT
0A7  0D101 │    ││                      test ip, 01                    ; Test bit 0
0A8  320A6 │    │╰⤙                     jump Z, .wait5
           │    │
           │    │
0A9        │    │                       ; DONE!
           │    │
0A9  2D2FF │    ╰─▶              .done: output scr0, LAST_PORT
0AA  25000 │                            return
           │
0AB        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0AB        │                            ; Subroutine Name: dly_us
           │                            ;
0AB        │                            ; Delay of 1 usec
0AB        │                            ; Delay is [(4 * dly_reg) + 6] / Fclk
0AB        │                            ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │                            ;
0AB        │                            ; Routine uses dly_reg and does not restore it
           │                            ;
0AB        │                            ; 24 (i.e $18) assumes a 100 MHz clock
0AB        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0AB        │                    dly_us:
0AB  01518 ╰─┬┬┬┬─▶                     load dly_reg, 24'd
0AC  19501 │ ││││╭▶           .wait_us: sub dly_reg, 01
0AD  360AC │ ││││╰⤙                     jump NZ, .wait_us
0AE  25000 │ ││││                       return
           │ ││││
0AF        │ ││││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0AF        │ ││││                       ; Subroutine Name: adc_conv
           │ ││││                       ;
0AF        │ ││││                       ; Pass in adc_clk_mask and adc_conv_mask
0AF        │ ││││                       ; clk_0 is bit 0 of adc_clk_mask
0AF        │ ││││                       ; clk_1 is bit 1 of adc_clk_mask
0AF        │ ││││                       ; conv_0 is bit 2 of adc_conv_mask
0AF        │ ││││                       ; conv_1 is bit 3 of adc_conv_maks
           │ ││││                       ;
0AF        │ ││││                       ; Uses the cnt register to count clock pulses (16 bit ADC)
0AF        │ ││││                       ; but restores cnt register before returning!!!
0AF        │ ││││                       ; Use adc_reg but we don’t restore it
           │ ││││                       ;
0AF        │ ││││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │ ││││
0AF        │ ││││             adc_conv:
           │ ││││
0AF        │ ││││                       ; Save cnt register
           │ ││││
0AF  2E4F0 ╭──────▶                     store cnt, (SP)                ; Push
0B0  19F01 │ ││││                       sub SP, 01
           │ ││││
           │ ││││
0B1        │ ││││                       ; Bring conv signals high (determined by adc_conv_mask)
0B1        │ ││││                       ; The AD7687 ADCs sample PSD analog outputs on the rising
0B1        │ ││││                       ; edge of CONV signal
           │ ││││
0B1  200AB │ │││╰─⤙                     call dly_us                    ; DEBUG put in for ADC T Tail - Prince Sep 11
0B2  200AB │ ││╰──⤙                     call dly_us                    ;
0B3  00680 │ ││                         load adc_reg, adc_conv_mask    ; Make CONV high
0B4  2D601 │ ││                         output adc_reg, ADC_CTL_PORT
           │ ││
0B5        │ ││                         ; Wait for 2 usec
           │ ││
0B5  200AB │ │╰───⤙                     call dly_us
0B6  200AB │ ╰────⤙                     call dly_us
           │
0B7        │                            ; Bring conv signals low
           │
0B7  06680 │                            xor adc_reg, adc_conv_mask
0B8  2D601 │                            output adc_reg, ADC_CTL_PORT
           │
0B9        │                            ; Apply 16 clock pulses (takes about 2 usec)
0B9        │                            ; Reading serial data out of the ADCs
0B9        │                            ; Clocked into shift registers in our custom block
           │
0B9  01410 │                            load cnt, 16'd
0BA  06670 │     ╭▶          .clk_loop: xor adc_reg, adc_clk_mask
0BB  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0BC  06670 │     │                      xor adc_reg, adc_clk_mask
0BD  00EE0 │     │                      load se, se                    ; NOP
0BE  00EE0 │     │                      load se, se                    ; NOP
0BF  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0C0  19401 │     │                      sub cnt, 01
0C1  360BA │     ╰⤙                     jump NZ, .clk_loop
           │
0C2        │                            ; Restore cnt register
           │
0C2  11F01 │                            add SP, 01                     ; Pop
0C3  0A4F0 │                            fetch cnt, (SP)
           │
           │
0C4  25000 │                            return
           │
0C5        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0C5        │                            ; Name: adc_to_fifo
           │                            ;
0C5        │                            ; Each time this routine is called, it sends the A, B, C, T
0C5        │                            ; adc values to the microblaze FIFO
0C5        │                            ; ip will be used ...should contain PSDx_IPORT (x = 0 or 1)
           │                            ;
0C5        │                            ; Tag format:
           │                            ;
0C5        │                            ; 0		psd addr bit 0
0C5        │                            ; 1		psd addr bit 1
0C5        │                            ; 2		psd addr bit 2
0C5        │                            ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
0C5        │                            ; 4		bit 0 of sc
0C5        │                            ; 5		bit 1 of sc
0C5        │                            ; 6		bit 0 of type
0C5        │                            ; 7		bit 1 of type
           │
0C5        │                            ; type = 00 ---> ADC data
0C5        │                            ; type = 01 ---> Timestamp Counter
0C5        │                            ; type = 10 ---> TDC TIME1 or TIME 2 value
0C5        │                            ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
           │
0C5        │                            ; sc = 00 -----> integrator A
0C5        │                            ; sc = 01 -----> integrator B
0C5        │                            ; sc = 10 -----> integrator C
0C5        │                            ; sc = 11 -----> time
0C5        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0C5        │               adc_to_fifo:
           │                            ;
0C5        │                            ; When we enter the routine, ip should contain PSD0 or PSD1 IPORT
0C5        │                            ; addr_reg will be used ...should contain PSDx_IPORT (x = 0 or 1)
0C5        │                            ; Here is the bit map
0C5        │                            ; NOTE: bit 6 tells us if it is PSD 0 or PSD1
           │                            ;
0C5        │                            ; 0		psd0_or
0C5        │                            ; 1		psd0_token_out
0C5        │                            ; 2		psd0_acq_ack
0C5        │                            ; 3		psd0_addr_out0
0C5        │                            ; 4		psd0_addr_out1
0C5        │                            ; 5		psd0_addr_out2
0C5        │                            ; 6     0 if PSD 0, 1 if PSD 1
0C5        │                            ; 7     0
           │
0C5        │                            ; Push some registers onto stack
           │
0C5  05A04 ╭──────▶                     or led_reg, 04                 ; Set bit 2  			;DEBUG FLAG 0 START
0C6  2DA00 │                            output led_reg, LED_PORT       ;DEBUG FLAG 0
           │
0C7  2E4F0 │                            store cnt, (SP)                ; Push
0C8  19F01 │                            sub SP, 01
           │
0C9  2E0F0 │                            store op, (SP)                 ; Push
0CA  19F01 │                            sub SP, 01
           │
0CB  2E1F0 │                            store ip, (SP)                 ; Push
0CC  19F01 │                            sub SP, 01
           │
           │
0CD        │                            ; Shift right 3 places
0CD        │                            ; Lower nybble now contains the channel address (bit 3 is PSD ID)
0CD        │                            ; Upper nybble contains 4’b000
           │
0CD  14D0E │                            sr0 addr_reg
0CE  14D0E │                            sr0 addr_reg
0CF  14D0E │                            sr0 addr_reg
           │
           │
0D0        │                            ; Load cnt to keep track which output we are working on
0D0        │                            ; A, B, C, or T (00, 01, 10, 11)
           │
0D0  01400 │                            load cnt, 00
           │
0D1        │                            ; Use scr1 to keep track of which PSD chip (either 0 or 1)
0D1        │                            ; Inspect bit 3 of ip register to see if it is PSD 0 or PSD 1
           │
0D1  01300 │                            load scr1, 00                  ; PSD 0
0D2  0DD08 │                            test addr_reg, 08              ; Test bit 3
0D3  320D5 │     ╭⤙                     jump Z, .loop
0D4  01301 │     │                      load scr1, 01                  ; PSD 1
           │     │
0D5        │     │                      ; We will write DATA_TAG_PORT first
0D5        │     │                      ; Format of the data tag byte :
0D5        │     │                      ; 	xxyyzzzz
0D5        │     │                      ; 	xx is type (00 = adc, 01 = tstamp, 10 = tdc time, 11 = tdc cal)
0D5        │     │                      ; 	For ADC, yy = sc (00 = A, 01 = B, 10 = C , 11 =T)
0D5        │     │                      ;	For tstamp_counter, yy -> 00 = lower 24 bits, 01 = upper 24 bits
0D5        │     │                      ;	For tdc time, yy = 01 -> TIME1, yy = 10 -> TIME2
0D5        │     │                      ;	For tdc calibration, yy = 01 = CALIBRATION1, yy = 10 -> CALIBRATION2
0D5        │     │                      ; 	zz = 4-bit channel address
           │     │
0D5  000D0 │    ╭┴▶              .loop: load op, addr_reg              ; Load channel address
0D6  00240 │    │                       load scr0, cnt                 ; Copy cnt (i.e. which analog output) to scr0
0D7  14206 │    │                       sl0 scr0
0D8  14206 │    │                       sl0 scr0
0D9  14206 │    │                       sl0 scr0
0DA  14206 │    │                       sl0 scr0
0DB        │    │                       ; Shift left 4 places
0DB  04020 │    │                       or op, scr0                    ; Combine with channel address
0DC  2D002 │    │                       output op, DATA_TAG_PORT       ; Put out our data tag (MSbyte of 32-bit word)
           │    │
0DD        │    │                       ; Now we will now write ADC_CTL_PORT
0DD        │    │                       ; We need to route out the appropriate ADC register to the FIFO using MUX (3 bits)
           │    │
0DD  00040 │    │                       load op, cnt                   ; cnt is either (00 = A, 01 = B, 10 = C, 11 = T)
0DE  14006 │    │                       sl0 op
0DF  14006 │    │                       sl0 op
0E0  14006 │    │                       sl0 op
0E1  14006 │    │                       sl0 op
0E2        │    │                       ; Mux sel is bits 4, 5, 6 of the ADC_CTL_PORT
           │    │
           │    │
0E2  0D301 │    │                       test scr1, 01                  ; Test bit 0				; Bit 6 is 0 if PSD 0
0E3  320E5 │    │╭⤙                     jump Z, .skip
0E4  05040 │    ││                      or op, 40                      ; Set bit 6				; Bit 6 is a 1 if PSD 1
           │    ││
           │    ││
0E5  2D001 │    │╰▶              .skip: output op, ADC_CTL_PORT
           │    │                       ;
0E6        │    │                       ; Correct input is now sitting on FIFO input
0E6        │    │                       ; Wait for ’tready’ signal to be active
           │    │                       ;
           │    │
0E6  09100 │    │╭▶         .wait_trdy: input ip, STATUS_IPORT
           │    ││
0E7        │    ││                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │    ││
0E7  0D101 │    ││                      test ip, 01                    ; Test bit 0
0E8  320E6 │    │╰⤙                     jump Z, .wait_trdy
           │    │
           │    │
0E9        │    │                       ; When FIFO is ready, send data (what we send to vaild port makes no diff) --Prince: How do we know that the data is ready and stable?
           │    │
0E9  2D0FE │    │                       output op, VALID_PORT
           │    │
0EA        │    │                       ; Check to see if we are done sending A, B, C, T
0EA        │    │                       ; When cnt is equal to 4, we are done!
           │    │
0EA  11401 │    │                       add cnt, 01
0EB  1D404 │    │                       compare cnt, 04
0EC  360D5 │    ╰─⤙                     jump NZ, .loop
           │
0ED        │                            ; Retrieve registers from stack
           │
0ED  11F01 │                            add SP, 01                     ; Pop
0EE  0A1F0 │                            fetch ip, (SP)
           │
0EF  11F01 │                            add SP, 01                     ; Pop
0F0  0A0F0 │                            fetch op, (SP)
           │
0F1  11F01 │                            add SP, 01                     ; Pop
0F2  0A4F0 │                            fetch cnt, (SP)
           │
           │
0F3  25000 │                            return
           │
0F4        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0F4        │                            ; Name: get_event
           │                            ;
0F4        │                            ; Routine to get a nuclear physics event
           │                            ;
0F4        │                            ; Aquires data from the 4 ADCS (A, B, C, T) for all hit channels on
0F4        │                            ; both PSD chips!
           │                            ;
0F4        │                            ; We look at ORs and keep getting samples until both PSD0 and PSD1 ORs low!
0F4        │                            ; Each time we get A, B, C, T samples, we send them to the FIFO
0F4        │                            ; Each time send a word to the FIFO, we need to write to VALID_PORT (or LAST_PORT)
           │                            ;
0F4        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0F4        │                 get_event:
           │
0F4        │                            ; Set the busy bit (also led[1])
0F4        │                            ; Bit 1 of LED_PORT is led[1] which is also the busy bit!
           │
0F4  05A02 ╭──────▶                     or led_reg, 02                 ; Set bit 1
0F5  2DA00 │                            output led_reg, LED_PORT
           │
0F6        │                            ; We need to set the FIFO mux to select the output of ADC mux
0F6        │                            ; fifo_mux_sel = 00 (bits 2 and 3 of the MISC_IPORT
           │
0F6  03CFB │                            and misc_oport_reg, fb         ; Clear bit 2
0F7  03CF7 │                            and misc_oport_reg, f7         ; Clear bit 3
0F8  2DC07 │                            output misc_oport_reg, MISC_OPORT
           │
0F9        │                            ; Check the ORs out of PSD chips
0F9        │                            ; If both ORs low then we are done!
           │
0F9  01900 ╭┬─┬───▶              .loop: load psd_or_reg, 00
0FA  01600 ││ │                         load adc_reg, 00
           ││ │
0FB  09102 ││ │                         input ip, PSD0_IPORT
0FC  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD0 OR
0FD  320FF ││ │  ╭⤙                     jump Z, .or0
0FE  05901 ││ │  │                      or psd_or_reg, 01              ; Set bit 0			; Make note that PSD0 OR is high
0FF  09103 ││ │  ╰▶               .or0: input ip, PSD1_IPORT
100  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD1 OR
101  32103 ││ │  ╭⤙                     jump Z, .or1
102  05902 ││ │  │                      or psd_or_reg, 02              ; Set bit 1			; Make note that PSD1 OR is high
           ││ │  │                      ;
103        ││ │  │                      ; Implement a case statement based on lower two bits of psd_or_reg
           ││ │  │                      ;
           ││ │  │
103  1D900 ││ │  ╰▶               .or1: compare psd_or_reg, 00
104  32143 ╭──────⤙                     jump Z, .done
105  1D901 ││ │                         compare psd_or_reg, 01
106  3210C ││ │ ╭─⤙                     jump Z, .psd0
107  1D902 ││ │ │                       compare psd_or_reg, 02
108  3211C ││ │╭──⤙                     jump Z, .psd1
109  1D903 ││ │││                       compare psd_or_reg, 03
10A  3212C ││╭────⤙                     jump Z, .both
           ││││││                       ;
10B        ││││││                       ; Should never happen ... if it does then hang
10B        ││││││                       ; Both LEDs will be on and PicoBlaze will be
10B        ││││││                       ; non-responsive
           ││││││                       ;
10B  2210B ││││││╰▶               .err: jump .err
           ││││││
10C        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
10C        ││││││                       ;  Only PSD 0 needs attention
10C        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           ││││││
10C        ││││││                .psd0:
           ││││││
10C        ││││││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
10C        ││││││                       ; Notablly sel_ext_addr (bit 7) must be low!
10C        ││││││                       ; The other bits in port ALSO need to be low
10C        ││││││                       ; except for acq_clk (bit 3). It needs to be high.
10C        ││││││                       ; PSD chips put out new analog outputs when acq_clk goes high!
           ││││││                       ;
10C        ││││││                       ; BUG FIX on 15-Feb-2025
10C        ││││││                       ; Important that token_in go low before acq_clk rises
           ││││││
10C  01000 │││││╰─▶                     load op, 00
10D  2D005 │││││                        output op, PSD0_OPORT          ; Token in low!!!!
10E  05008 │││││                        or op, 08                      ; Set bit 3				; acq clk for PSD 0 high
10F  2D005 │││││                        output op, PSD0_OPORT
110  200AB ╰──────⤙                     call dly_us                    ; Give analog outputs chance to settle
           │││││                        ;
111        │││││                        ; Set up our masks
           │││││                        ;
111  01701 │││││                        load adc_clk_mask, 00000001'b
112  01804 │││││                        load adc_conv_mask, 00000100'b
           │││││
113        │││││                        ; Perform adc conversion
           │││││
113  200AF ╰──────⤙                     call adc_conv
           │││││
           │││││
114        │││││                        ; Read PSD address
           │││││
114  09D02 │││││                        input addr_reg, PSD0_IPORT
           │││││
115        │││││                        ; We need to send A, B, C, T off to FIFO
           │││││
115  200C5 ╰──────⤙                     call adc_to_fifo
           │││││
           │││││
116        │││││                        ; Bring acq_clk low (acq_clk is bit 3)
116        │││││                        ; Resets the hit and active registers
           │││││
116  030F7 │││││                        and op, f7                     ; Clear bit 3			 	; Bring acq clk low
117  2D005 │││││                        output op, PSD0_OPORT
           │││││
118        │││││                        ; Check token out from PSD 0 (token_out is bit 1)
118        │││││                        ; If token_out is HIGH then contine else we are done
           │││││
118  09102 │││││                        input ip, PSD0_IPORT
119  0D102 │││││                        test ip, 02                    ; Test bit 1
11A  360F9 │││╰───⤙                     jump NZ, .loop
11B  22143 │││ │╭─⤙                     jump .done
           │││ ││
11C        │││ ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
11C        │││ ││                       ;  Only PSD 1 needs attention
11C        │││ ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │││ ││
11C        │││ ││                .psd1:
           │││ ││
11C        │││ ││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
11C        │││ ││                       ; Notablly sel_ext_addr (bit 7) must be low!
11C        │││ ││                       ; The other bits in port ALSO need to be low
11C        │││ ││                       ; except for acq_clk (bit 3). It needs to be high.
           │││ ││
11C  01000 │││ ╰──▶                     load op, 00
11D  2D006 │││  │                       output op, PSD1_OPORT          ;	Token in low
11E  05008 │││  │                       or op, 08                      ; Set bit 3
11F  2D006 │││  │                       output op, PSD1_OPORT          ; 	Bring acq_clk high
120  200AB ╰──────⤙                     call dly_us
           │││  │
121        │││  │                       ; Set up our masks
           │││  │
121  01702 │││  │                       load adc_clk_mask, 00000010'b
122  01808 │││  │                       load adc_conv_mask, 00001000'b
           │││  │
123        │││  │                       ; Perform adc conversion
           │││  │
123  200AF ╰──────⤙                     call adc_conv
           │││  │
124        │││  │                       ; Read PSD address
           │││  │
124  09D03 │││  │                       input addr_reg, PSD1_IPORT     ; bugfix - prince Aug 27 - changed ip to adc_reg for PSD 1 address location.
           │││  │
125        │││  │                       ; We need to send A, B, C, T off to FIFO
           │││  │
125  200C5 ╰──────⤙                     call adc_to_fifo
           │││  │
126        │││  │                       ; Bring acq_clk low (acq_clk is bit 3)
126        │││  │                       ; Resets the hit and active registers
           │││  │
126  030F7 │││  │                       and op, f7                     ; Clear bit 3
127  2D006 │││  │                       output op, PSD1_OPORT
           │││  │
128        │││  │                       ; Check token out from PSD (token_out is bit 1)
128        │││  │                       ; If token_out is HIGH then contine else we are done
           │││  │
128  09103 │││  │                       input ip, PSD1_IPORT
129  0D102 │││  │                       test ip, 02                    ; Test bit 1
12A  360F9 │╰─────⤙                     jump NZ, .loop
12B  22143 │ │  │╭⤙                     jump .done
           │ │  ││
12C        │ │  ││                      ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
12C        │ │  ││                      ;  Both PSD chips needs attention
12C        │ │  ││                      ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │ │  ││
12C        │ │  ││               .both:
           │ │  ││
12C        │ │  ││                      ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
12C        │ │  ││                      ; Notablly sel_ext_addr (bit 7) must be low!
12C        │ │  ││                      ; The other bits in port ALSO need to be low
12C        │ │  ││                      ; except for acq_clk (bit 3). It needs to be high.
           │ │  ││
12C  01000 │ ╰────▶                     load op, 00
12D  2D005 │    ││                      output op, PSD0_OPORT          ; Token in low
12E  2D006 │    ││                      output op, PSD1_OPORT          ; Token in low
12F  05008 │    ││                      or op, 08                      ; Set bit 3
130  2D005 │    ││                      output op, PSD0_OPORT          ; acq_clk high
131  2D006 │    ││                      output op, PSD1_OPORT          ; acq_clk high
132  200AB ╰──────⤙                     call dly_us                    ; Wait for PSD analog outputs to settle
           │    ││
133        │    ││                      ; Set up our masks
           │    ││
133  01703 │    ││                      load adc_clk_mask, 00000011'b
134  0180C │    ││                      load adc_conv_mask, 00001100'b
           │    ││
135        │    ││                      ; Perform adc conversion
           │    ││
135  200AF ╰──────⤙                     call adc_conv
           │    ││
136        │    ││                      ; Read PSD 0 address
           │    ││
136  09602 │    ││                      input adc_reg, PSD0_IPORT
           │    ││
137        │    ││                      ; We need to send A, B, C, T off to FIFO
           │    ││
137  200C5 ╰──────⤙                     call adc_to_fifo
           │    ││
138        │    ││                      ; Read PSD 1 address
           │    ││
138  09603 │    ││                      input adc_reg, PSD1_IPORT
           │    ││
139        │    ││                      ; We need to send A, B, C, T off to FIFO
           │    ││
139  200C5 ╰──────⤙                     call adc_to_fifo
           │    ││
13A        │    ││                      ; Bring acq_clk low (acq_clk is bit 3)
13A        │    ││                      ; Resets the hit and active registers
           │    ││
13A  030F7 │    ││                      and op, f7                     ; Clear bit 3
13B  2D005 │    ││                      output op, PSD0_OPORT
13C  2D006 │    ││                      output op, PSD1_OPORT
           │    ││
13D        │    ││                      ; Check token out from PSD (token_out is bit 1)
13D        │    ││                      ; If token_out is HIGH then contine else we are done
           │    ││
13D  09102 │    ││                      input ip, PSD0_IPORT
13E  0D102 │    ││                      test ip, 02                    ; Test bit 1
13F  360F9 ╰──────⤙                     jump NZ, .loop
           │    ││
140  09103 │    ││                      input ip, PSD1_IPORT
141  0D102 │    ││                      test ip, 02                    ; Test bit 1
142  360F9 ╰──────⤙                     jump NZ, .loop
           │    ││
143        │    ││                      ; We are DONE!
           │    ││
143  05A10 ╰────┴┴▶              .done: or led_reg, 10                 ; Set bit 4  			;DEBUG FLAG 2 START
144  2DA00 │                            output led_reg, LED_PORT       ;DEBUG FLAG 2
           │
145        │                            ; Not required as of Mar 31 - Prince
145        │                            ;input		ip, STATUS_IPORT	; Tready  is bit 0 of STATUS_IPORT
145        │                            ;testbit(ip, 0)
145        │                            ;jump		Z,	.done
           │
145        │                            ; (1)
145        │                            ; Bring token_in (bit 6) high for bit PSD0 and PSD1
           │                            ;
145  05040 │                            or op, 40                      ; Set bit 6
146  2D005 │                            output op, PSD0_OPORT
147  2D006 │                            output op, PSD1_OPORT
           │
148        │                            ; (2)
148        │                            ; Get and send time data to the FIFO
           │                            ;
148  05A20 │                            or led_reg, 20                 ; Set bit 5  			;DEBUG FLAG 3 START
149  2DA00 │                            output led_reg, LED_PORT       ;DEBUG FLAG 3
14A  20075 ╰──────⤙                     call time_to_fifo
           │
14B  03AF7 │                            and led_reg, f7                ; Clear bit 3 			;DEBUG FLAG 1
14C  03AFB │                            and led_reg, fb                ; Clear bit 2 			;DEBUG FLAG 0
14D  03ADF │                            and led_reg, df                ; Clear bit 5 			;DEBUG FLAG 3
14E  03AEF │                            and led_reg, ef                ; Clear bit 4 			;DEBUG FLAG 2
14F  2DA00 │                            output led_reg, LED_PORT       ;DEBUG FLAG 0,2,3 STOP
150        │                            ; (3)
150        │                            ; Unset the busy flag (busy flag is same as LED 1)
           │                            ;
150  03AFD │                            and led_reg, fd                ; Clear bit 1
151  2DA00 │                            output led_reg, LED_PORT
           │
152  25000 │                            return
           │
153        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153        │                            ; ******* NUCLEAR PHYSICS PROGRAM *********
           │                            ;
153        │                            ; We sit in a tight loop waiting for take_event to go HIGH
153        │                            ; When posedge take_event comes along we call get_event routine.
           │                            ;
153        │                            ; We stay in get_event untill all PSD channels are read out and
153        │                            ; sent back to microblaze using the streaming FIFO.
           │                            ;
153        │                            ; We then wait for take_event to go LOW. We then go back and
153        │                            ; sit in tight loop waiting for next event!
           │                            ;
153        │                            ; led[1] is lit when we are actually in the get_event subroutine
153        │                            ; led[1] is also the busy bit i.e we are in get_event!
           │                            ;
153        │                            ; For time being let’s turn led[0] on whenever take_event is low
153        │                            ; i.e. we are just waiting for an event to come along
           │                            ;
153        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153        │                   nuclear:
           │
153        │                            ; Initialize registers, ports, etc
153        │                            ; If board id is 0 then also configure and start TDC7200
           │
153  20001 ╰──────▶                     call init
           │
154        │                            ; Enable the PSD chips (turn on global enable)
           │
154        │                            ; setbit(misc_oport_reg, 4)
154        │                            ; output		misc_oport_reg, MISC_OPORT
           │
154        │                            ; Turn led[0] on (On while we wait for take_event to go high!)
           │
154  05A01 │    ╭─▶              .loop: or led_reg, 01                 ; Set bit 0
155  2DA00 │    │                       output led_reg, LED_PORT
           │    │
156        │    │                       ; Wait for take_event to go HIGH
156        │    │                       ; Take event is bit 1 of the STATUS_IPORT
           │    │
156  09100 │    │╭▶             .wait0: input ip, STATUS_IPORT
157  0D102 │    ││                      test ip, 02                    ; Test bit 1
158  32156 │    │╰⤙                     jump Z, .wait0
           │    │
159        │    │                       ; First thing we need to do is bring veto_reset
159        │    │                       ; high on PSD chips before they auto_reset and
159        │    │                       ; disable (global enable low!) the PSD chips
           │    │
159  05C02 │    │                       or misc_oport_reg, 02          ; Set bit 1		; Assert veto_reset
15A  03CEF │    │                       and misc_oport_reg, ef         ; Clear bit 4		; Disable PSD
15B  2DC07 │    │                       output misc_oport_reg, MISC_OPORT
           │    │
15C        │    │                       ; Turn led[0] off since we are now processing an event!
           │    │
15C  03AFE │    │                       and led_reg, fe                ; Clear bit 0
15D  2DA00 │    │                       output led_reg, LED_PORT
           │    │
15E        │    │                       ; Call the get_event routine
15E        │    │                       ; Returns once all hit channels are read out!
15E        │    │                       ; While we are in get_event the busy bit is set
           │    │
15E        │    │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15E  200F4 ╰──────⤙                     call get_event
15F             │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                │
15F             │                       ; Wait for take_event to go INACTIVE (bit 1 of STATUS_IPORT)
                │
15F  09100      │╭▶             .wait1: input ip, STATUS_IPORT
160  0D102      ││                      test ip, 02                    ; Test bit 1
161  3615F      │╰⤙                     jump NZ, .wait1
                │
162             │                       ; De-assert veto_reset
                │
162  03CFD      │                       and misc_oport_reg, fd         ; Clear bit 1
163  2D007      │                       output op, MISC_OPORT
                │
164             │                       ; Force a reset (about 1 usec long)
164             │                       ; Shouldn’t be necessary but doesn’t hurt
164             │                       ; We want to be absolutely sure analog blocks
164             │                       ; are in reset when we enable psd chips!
                │
164  05C01      │                       or misc_oport_reg, 01          ; Set bit 0
165  2DC07      │                       output misc_oport_reg, MISC_OPORT
166  00EE0      │                       load se, se                    ; NOP
167  00EE0      │                       load se, se                    ; NOP
168  03CFE      │                       and misc_oport_reg, fe         ; Clear bit 0
169  2DC07      │                       output misc_oport_reg, MISC_OPORT
                │
16A             │                       ; Go back and wait for the next event
                │
16A  22154      ╰─⤙                     jump .loop                     ;

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/prince/Vivado_projects/Trenz-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CALIBRATION1       1b     pico_program.psm
    CALIBRATION2       1c     pico_program.psm
    CONFIG1            40     pico_program.psm
    CONFIG1_VAL        01     pico_program.psm
    CONFIG2            41     pico_program.psm
    CONFIG2_VAL        01     pico_program.psm
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    MISC_OPORT         07     pico_program.psm
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
    PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CAL1_TAG       d0     pico_program.psm
    TDC_CAL2_TAG       e0     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    TDC_TIME1_TAG      90     pico_program.psm
    TDC_TIME2_TAG      a0     pico_program.psm
    TIME1              10     pico_program.psm
    TIME2              11     pico_program.psm
    TSTAMP_LOWER_TAG   40     pico_program.psm
    TSTAMP_UPPER_TAG   50     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      1E
    datestamp_month    09
    datestamp_year     19
    timestamp_hours    0E
    timestamp_minutes  21
    timestamp_seconds  2B


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "30 Sep 2025"
    timestamp$       "14:33:43"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv               0AF   pico_program.psm
    adc_conv.clk_loop      0BA   pico_program.psm
    adc_to_fifo            0C5   pico_program.psm
    adc_to_fifo.loop       0D5   pico_program.psm
    adc_to_fifo.skip       0E5   pico_program.psm
    adc_to_fifo.wait_trdy  0E6   pico_program.psm
    clr_tdc_reg            02B   pico_program.psm
    config_tdc             051   pico_program.psm
    dly_us                 0AB   pico_program.psm
    dly_us.wait_us         0AC   pico_program.psm
    get_event              0F4   pico_program.psm
    get_event.both         12C   pico_program.psm
    get_event.done         143   pico_program.psm
    get_event.err          10B   pico_program.psm
    get_event.loop         0F9   pico_program.psm
    get_event.or0          0FF   pico_program.psm
    get_event.or1          103   pico_program.psm
    get_event.psd0         10C   pico_program.psm
    get_event.psd1         11C   pico_program.psm
    init                   001   pico_program.psm
    init.done              025   pico_program.psm
    my_isr                 380   pico_program.psm
    nuclear                153   pico_program.psm
    nuclear.loop           154   pico_program.psm
    nuclear.wait0          156   pico_program.psm
    nuclear.wait1          15F   pico_program.psm
 *  origin                 000   pico_program.psm
    read_tdc               069   pico_program.psm
    start_tdc              063   pico_program.psm
    start_tdc.done         068   pico_program.psm
    tdc_csb_high           04E   pico_program.psm
    tdc_csb_low            04B   pico_program.psm
    tdc_ena                031   pico_program.psm
    tdc_init               037   pico_program.psm
    tdc_reg_clk            026   pico_program.psm
    tdc_serial             03D   pico_program.psm
    tdc_serial.clk_loop    040   pico_program.psm
    time_to_fifo           075   pico_program.psm
    time_to_fifo.done      0A9   pico_program.psm
    time_to_fifo.wait0     07A   pico_program.psm
    time_to_fifo.wait1     082   pico_program.psm
    time_to_fifo.wait2     08E   pico_program.psm
    time_to_fifo.wait3     096   pico_program.psm
    time_to_fifo.wait4     09E   pico_program.psm
    time_to_fifo.wait5     0A6   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          5
   ADDCY        -
   AND          25
   CALL         40
   CALL@        -
   COMPARE      6
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        7
   HWBUILD      -
   INPUT        20
   JUMP         34
   JUMP@        -
   LOAD         59
   LOAD&RETURN  -
   OR           28
   OUTPUT       79
   OUTPUTK      -
   REGBANK      -
   RETURN       16
   RETURNI      1
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          3
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        5
   SUB          7
   SUBCY        -
   TEST         17
   TESTCY       -
   XOR          5
