Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2025-02-10T15:22:16
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 227
  Memory locations available: 3869
  Scratchpad size: 256


Assembly listing
----------------
                                        ;
000                                     ; Test program for our picoblaze
000                                     ; For starters just blink led connected to bit 0
000                                     ; of output port #0
                                        ;
000                                     ; Keep adding until is does everything we need!
                                        ;
000                                     ; 31-Oct-2024
                                        ;
000                                     ; Let’s replace the adc test program with our
000                                     ; actual nuclear program
000                                     ; 31-Jan-2025
000                                     ; Initially make it essentially just do the adc_test

000                                     ; ********************************************
000                                     ; Output ports (we have 8 real output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast signals
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED0
000                                     ; 1		LED1 (also the busy bit!)

000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Board id
000                                     ; type = 10 ---> TDC data (lower 24 bits)
000                                     ; type = 11 ---> TDC data (upper 24 bits)

000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6		tdc_csb
000                                     ; 7		tdc_enable

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     constant MISC_OPORT, 07

000                                     ; --------------------------------
000                                     ; PORT 7 (Misc outputs)
000                                     ; --------------------------------
                                        ;
000                                     ; 0 	force_psd_reset
000                                     ; 1		veto_reset

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2		tdc_intb (interrupt signal from TDC7200)

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; We can use s0 - sd, se and sf are special
000                                     ; Give more desciptive names to some of our registers
000                                     ; The scratch registers get used but not restored!
000                                     ; Other regs tend to be saved on the stack!
                                        ;
000                                     namereg s0, op                 ; Output port register (scratch)
000                                     namereg s1, ip                 ; Input port register (scratch)
000                                     namereg s2, scr0               ; Scratchpad register 0 (scratch)
000                                     namereg s3, scr1               ; Scratchpad register 1 (scratch)
000                                     namereg s4, scr2               ; Scratchpad register 2 (scratch)
000                                     namereg s5, cnt                ; Used for counting "things"
000                                     namereg s6, dly_reg            ; Used in delay_1us routine
000                                     namereg s7, adc_reg            ; Used by adc routine
000                                     namereg s8, adc_clk_mask       ; Defines which adc clocks are to be used
000                                     namereg s9, adc_conv_mask      ; Defines which adc conv signals are to be used
000                                     namereg sa, psd_or_reg         ; Lower 2 bits keep track of PSD1 and PSD0 ORs
000                                     namereg sb, led_reg            ; Global variable that constains state of LEDs
000                                     namereg sc, tdc_ctl_reg        ; Used in tdc_ser
000                                     namereg sd, addr_reg           ; Holds PSD channel address

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; Register se is also special
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Read the board id port and store it in scratchpad memory

000                                     constant BOARD_ID, 00


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ;********************************************
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ;********************************************
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000

000  220CE ╭──────⤙             origin: jump nuclear
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
           │                            ;
001        │                            ; Initialize the stack pointer, SP
001        │                            ; Initialize registers and ports
001        │                            ; Read board id and save
           │                            ;
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ; Read the board id from port and save it to scratchpad memory location 0
           │
002  09201 │                            input scr0, BOARD_ID_PORT
003  2F200 │                            store scr0, BOARD_ID
           │
004        │                            ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
004        │                            ; To retreive the board id from scratchpad memory
004        │                            ;			fetch		scr0, BOARD_ID
004        │                            ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │
004        │                            ; Clear the output port registers
           │
004  01200 │                            load scr0, 00
005  2D200 │                            output scr0, LED_PORT
006  2D202 │                            output scr0, DATA_TAG_PORT
007  2D203 │                            output scr0, TDC_DATA_PORT
008  2D204 │                            output scr0, TDC_CTL_PORT
           │
009        │                            ; Clear some registers
           │
009  01000 │                            load op, 00
00A  01100 │                            load ip, 00
00B  01500 │                            load cnt, 00
00C  01600 │                            load dly_reg, 00
00D  01700 │                            load adc_reg, 00
00E  01800 │                            load adc_clk_mask, 00
00F  01900 │                            load adc_conv_mask, 00
010  01C00 │                            load tdc_ctl_reg, 00
011  01B00 │                            load led_reg, 00
012  01A00 │                            load psd_or_reg, 00
           │
013        │                            ; Need bit 6 (tdc_csb) of TDC_CTL_PORT to be high (inactive)
013        │                            ; Also bit 7 (tdc_enable) should be high (active)
013        │                            ; Bit 5 serial clk should also be high
           │
013  05C20 │                            or tdc_ctl_reg, 20             ; Set bit 5
014  05C40 │                            or tdc_ctl_reg, 40             ; Set bit 6
015  05C80 │                            or tdc_ctl_reg, 80             ; Set bit 7
016  2D204 │                            output scr0, TDC_CTL_PORT
           │
017        │                            ; Reset the ADC shift registers
017        │                            ; Bring reset bit high in adc_reg and then back low
017        │                            ; Bit 7 of adc_reg is the reset adc registers bit
017        │                            ; Clock and conv signals low
017        │                            ; Mux selects (3’b000) choosing adc reg for PSD0 A integrator
017        │                            ; Pulse the adc reg reset line
           │
017  05780 │                            or adc_reg, 80                 ; Set bit 7
018  2D701 │                            output adc_reg, ADC_CTL_PORT
019  0377F │                            and adc_reg, 7f                ; Clear bit 7
01A  2D701 │                            output adc_reg, ADC_CTL_PORT
           │
01B        │                            ; Make sure that tokens into the PSD chips are HIGH (inactive)
01B        │                            ; token_in for the PSD ports is bit 6
           │
01B  01200 │                            load scr0, 00
01C  05240 │                            or scr0, 40                    ; Set bit 6
01D  2D205 │                            output scr0, PSD0_OPORT
01E  2D206 │                            output scr0, PSD1_OPORT
           │
01F        │                            ; Bring the force_reset and veto_reset pins low on both PSD chips
01F        │                            ; force_reset is bit 0
01F        │                            ; veto_reset is bit 1
           │
01F  01200 │                            load scr0, 00
020  2D207 │                            output scr0, MISC_OPORT
           │
021        │                            ; Done so return
           │
021  25000 │                            return
           │
022        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
022        │                            ; Subroutine Name: tdc_ser
           │                            ;
022        │                            ; Routine to send and receive serial dataa
022        │                            ; from TDC7200
           │                            ;
022        │                            ; When called cnt should contain the number
022        │                            ; serial clock pulses we want
           │                            ;
022        │                            ; --------------------------------
022        │                            ; PORT 4 (TDC register control)
022        │                            ; --------------------------------
022        │                            ; 0		tdc_reg_ld_0
022        │                            ; 1		tdc_reg_ld_1
022        │                            ; 2		tdc_reg_ld_2
022        │                            ; 3		tdc_reg_rst
022        │                            ; 4		tdc_reg_shift
022        │                            ; 5		tdc_reg_sclk
022        │                            ; 6		tdc_csb
022        │                            ; 7		tdc_enable
           │                            ;
022        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
022        │                   tdc_ser:
           │
022        │                            ; Need to bring the tdc_csb line low
           │
022  03CBF │                            and tdc_ctl_reg, bf            ; Clear bit 6
023  2DC04 │                            output tdc_ctl_reg, TDC_CTL_PORT
           │
024        │                            ; Apply the clock pulses
           │
024  03CDF │     ╭▶          .clk_loop: and tdc_ctl_reg, df            ; Clear bit 5
025  2DC04 │     │                      output tdc_ctl_reg, TDC_CTL_PORT
026  00EE0 │     │                      load se, se                    ; NOP
027  00EE0 │     │                      load se, se                    ; NOP
028  05C20 │     │                      or tdc_ctl_reg, 20             ; Set bit 5
029  2DC04 │     │                      output tdc_ctl_reg, TDC_CTL_PORT
02A  19501 │     │                      sub cnt, 01
02B  36024 │     ╰⤙                     jump NZ, .clk_loop
           │
02C        │                            ; Need to bring the tdc_csb line high
           │
02C  05C40 │                            or tdc_ctl_reg, 40             ; Set bit 6
02D  2DC04 │                            output tdc_ctl_reg, TDC_CTL_PORT
           │
02E  25000 │                            return
           │
02F        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
02F        │                            ; Subroutine Name: tdc_reg_ld
           │                            ;
02F        │                            ; Used to load a byte into the tdc_reg
           │                            ;
02F        │                            ; --------------------------------
02F        │                            ; PORT 4 (TDC register control)
02F        │                            ; --------------------------------
02F        │                            ; 0		tdc_reg_ld_0
02F        │                            ; 1		tdc_reg_ld_1
02F        │                            ; 2		tdc_reg_ld_2
02F        │                            ; 3		tdc_reg_rst
02F        │                            ; 4		tdc_reg_shift
02F        │                            ; 5		tdc_reg_sclk
02F        │                            ; 6		tdc_csb
02F        │                            ; 7		tdc_enable
           │                            ;
02F        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
02F        │                tdc_reg_ld:
           │
02F  25000 │                            return
           │
           │
030        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
030        │                            ; Subroutine Name: force_reset
           │                            ;
030        │                            ; This performs reset on PSD analog blocks
030        │                            ; Veto reset is made low
           │                            ;
030        │                            ; Apply a 1 usec long (approx) force_reset pulse
030        │                            ; Bit 0 of MISC_PORT
030        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
030  01000 ╭──────▶        force_reset: load op, 00
031  05001 │                            or op, 01                      ; Set bit 0
032  2D007 │                            output op, MISC_OPORT
033  20037 │     ╭⤙                     call dly_us
034  030FE │     │                      and op, fe                     ; Clear bit 0
035  2D007 │     │                      output op, MISC_OPORT
036  25000 │     │                      return
           │     │
037        │     │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
037        │     │                      ; Subroutine Name: dly_us
           │     │                      ;
037        │     │                      ; Delay of 1 usec
037        │     │                      ; Delay is [(4 * dly_reg) + 6] / Fclk
037        │     │                      ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │     │                      ;
037        │     │                      ; Routine uses dly_reg and does not restore it
           │     │                      ;
037        │     │                      ; 24 (i.e $18) assumes a 100 MHz clock
037        │     │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │     │
037        │     │              dly_us:
037  01618 ╭───┬┬┴▶                     load dly_reg, 24'd
038  19601 │   ││╭▶           .wait_us: sub dly_reg, 01
039  36038 │   ││╰⤙                     jump NZ, .wait_us
03A  25000 │   ││                       return
           │   ││
03B        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03B        │   ││                       ; Subroutine Name: adc_conv
           │   ││                       ;
03B        │   ││                       ; Pass in adc_clk_mask and adc_conv_mask
03B        │   ││                       ; clk_0 is bit 0 of adc_clk_mask
03B        │   ││                       ; clk_1 is bit 1 of adc_clk_mask
03B        │   ││                       ; conv_0 is bit 2 of adc_conv_mask
03B        │   ││                       ; conv_1 is bit 3 of adc_conv_maks
           │   ││                       ;
03B        │   ││                       ; Uses the cnt register to count clock pulses (16 bit ADC)
03B        │   ││                       ; but restores cnt register before returning!!!
03B        │   ││                       ; Use adc_reg but we don’t restore it
           │   ││                       ;
03B        │   ││                       ; ******
03B        │   ││                       ; Used by both the adc_test and the nuclear program
03B        │   ││                       ; ******
           │   ││                       ;
03B        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
03B        │   ││             adc_conv:
           │   ││
03B        │   ││                       ; Save cnt register
           │   ││
03B  2E5F0 ╭──────▶                     store cnt, (SP)                ; Push
03C  19F01 │   ││                       sub SP, 01
           │   ││
           │   ││
03D        │   ││                       ; Bring conv signals high (determined by adc_conv_mask)
03D        │   ││                       ; The AD7687 ADCs sample PSD analog outputs on the rising
03D        │   ││                       ; edge of CONV signal
           │   ││
03D  00790 │   ││                       load adc_reg, adc_conv_mask    ; Make CONV high
03E  2D701 │   ││                       output adc_reg, ADC_CTL_PORT
           │   ││
03F        │   ││                       ; Wait for 2 usec
           │   ││
03F  20037 │   │╰─⤙                     call dly_us
040  20037 │   ╰──⤙                     call dly_us
           │
041        │                            ; Bring conv signals low
           │
041  06790 │                            xor adc_reg, adc_conv_mask
042  2D701 │                            output adc_reg, ADC_CTL_PORT
           │
043        │                            ; Apply 16 clock pulses (takes about 2 usec)
043        │                            ; Reading serial data out of the ADCs
043        │                            ; Clocked into shift registers in our custom block
           │
043  01510 │                            load cnt, 16'd
044  06780 │     ╭▶          .clk_loop: xor adc_reg, adc_clk_mask
045  2D701 │     │                      output adc_reg, ADC_CTL_PORT
046  06780 │     │                      xor adc_reg, adc_clk_mask
047  00EE0 │     │                      load se, se                    ; NOP
048  00EE0 │     │                      load se, se                    ; NOP
049  2D701 │     │                      output adc_reg, ADC_CTL_PORT
04A  19501 │     │                      sub cnt, 01
04B  36044 │     ╰⤙                     jump NZ, .clk_loop
           │
04C        │                            ; Restore cnt register
           │
04C  11F01 │                            add SP, 01                     ; Pop
04D  0A5F0 │                            fetch cnt, (SP)
           │
           │
04E  25000 │                            return
           │
04F        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04F        │                            ; Name: adc_to_fifo
           │                            ;
04F        │                            ; Each time this routine is called, it sends the A, B, C, T
04F        │                            ; adc values to the microblaze FIFO
04F        │                            ; ip will be used ...should contain PSDx_IPORT (x = 0 or 1)
           │                            ;
04F        │                            ; Tag format:
           │                            ;
04F        │                            ; 0		psd addr bit 0
04F        │                            ; 1		psd addr bit 1
04F        │                            ; 2		psd addr bit 2
04F        │                            ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
04F        │                            ; 4		bit 0 of sc
04F        │                            ; 5		bit 1 of sc
04F        │                            ; 6		bit 0 of type
04F        │                            ; 7		bit 1 of type
           │
04F        │                            ; type = 00 ---> ADC data
04F        │                            ; type = 01 ---> Board id
04F        │                            ; type = 10 ---> TDC data (lower 24 bits)
04F        │                            ; type = 11 ---> TDC data (upper 24 bits)
           │
04F        │                            ; sc = 00 -----> integrator A
04F        │                            ; sc = 01 -----> integrator B
04F        │                            ; sc = 10 -----> integrator C
04F        │                            ; sc = 11 -----> time
04F        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
04F        │               adc_to_fifo:
           │                            ;
04F        │                            ; When we enter the routine, ip should contain PSD0 or PSD1 IPORT
04F        │                            ; addr_reg will be used ...should contain PSDx_IPORT (x = 0 or 1)
04F        │                            ; Here is the bit map
04F        │                            ; NOTE: bit 6 tells us if it is PSD 0 or PSD1
           │                            ;
04F        │                            ; 0		psd0_or
04F        │                            ; 1		psd0_token_out
04F        │                            ; 2		psd0_acq_ack
04F        │                            ; 3		psd0_addr_out0
04F        │                            ; 4		psd0_addr_out1
04F        │                            ; 5		psd0_addr_out2
04F        │                            ; 6     0 if PSD 0, 1 if PSD 1
04F        │                            ; 7     0
           │
04F        │                            ; Push some registers onto stack
           │
04F  2E5F0 ╭──────▶                     store cnt, (SP)                ; Push
050  19F01 │                            sub SP, 01
           │
051  2E0F0 │                            store op, (SP)                 ; Push
052  19F01 │                            sub SP, 01
           │
053  2E1F0 │                            store ip, (SP)                 ; Push
054  19F01 │                            sub SP, 01
           │
           │
055        │                            ; Shift right 3 places
055        │                            ; Lower nybble now contains the channel address (bit 3 is PSD ID)
055        │                            ; Upper nybble contains 4’b000
           │
055  14D0E │                            sr0 addr_reg
056  14D0E │                            sr0 addr_reg
057  14D0E │                            sr0 addr_reg
           │
           │
058        │                            ; Load cnt to keep track which output we are working on
058        │                            ; A, B, C, or T (00, 01, 10, 11)
           │
058  01500 │                            load cnt, 00
           │
059        │                            ; Use scr1 to keep track of which PSD chip (either 0 or 1)
059        │                            ; Inspect bit 3 of ip register to see if it is PSD 0 or PSD 1
           │
059  01300 │                            load scr1, 00                  ; PSD 0
05A  0DD08 │                            test addr_reg, 08              ; Test bit 3
05B  3205D │     ╭⤙                     jump Z, .loop
05C  01301 │     │                      load scr1, 01                  ; PSD 1
           │     │
05D        │     │                      ; We will write DATA_TAG_PORT first
05D        │     │                      ; Format of the data tag byte :
05D        │     │                      ; 	xxyyzzzz
05D        │     │                      ; 	xx is type (00 = adc, 01 = board id, 10 = lower TDC data, 11 = upper TDC data)
05D        │     │                      ; 	yy = sc (00 = A, 01 = B, 10 = C , 11 =T)
05D        │     │                      ; 	zz = 4-bit channel address
           │     │
05D  000D0 │    ╭┴▶              .loop: load op, addr_reg              ; Load channel address
05E  00450 │    │                       load scr2, cnt                 ; Copy cnt (i.e. which analog output) to scr2
05F  14406 │    │                       sl0 scr2
060  14406 │    │                       sl0 scr2
061  14406 │    │                       sl0 scr2
062  14406 │    │                       sl0 scr2
063        │    │                       ; Shift left 4 places
063  04040 │    │                       or op, scr2                    ; Combine with channel address
064  2D002 │    │                       output op, DATA_TAG_PORT       ; Put out our data tag (MSbyte of 32-bit word)
           │    │
065        │    │                       ; Now we will now write ADC_CTL_PORT
065        │    │                       ; We need to route out the appropriate ADC register to the FIFO using MUX (3 bits)
           │    │
065  00050 │    │                       load op, cnt                   ; cnt is either (00 = A, 01 = B, 10 = C, 11 = T)
066  14006 │    │                       sl0 op
067  14006 │    │                       sl0 op
068  14006 │    │                       sl0 op
069  14006 │    │                       sl0 op
06A        │    │                       ; Mux sel is bits 4, 5, 6 of the ADC_CTL_PORT
06A  0D301 │    │                       test scr1, 01                  ; Test bit 0				; Bit 6 is 0 if PSD 0
06B  3206D │    │╭⤙                     jump Z, .skip
06C  05040 │    ││                      or op, 40                      ; Set bit 6				; Bit 6 is a 1 if PSD 1
06D  2D001 │    │╰▶              .skip: output op, ADC_CTL_PORT
           │    │                       ;
06E        │    │                       ; Correct input is now sitting on FIFO input
06E        │    │                       ; Wait for ’tready’ signal to be active
           │    │                       ;
06E  09100 │    │╭▶         .wait_trdy: input ip, STATUS_IPORT
           │    ││
06F        │    ││                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │    ││
06F  0D101 │    ││                      test ip, 01                    ; Test bit 0
070  3206E │    │╰⤙                     jump Z, .wait_trdy
           │    │
071        │    │                       ; When FIFO is ready, send data (what we send to vaild port makes no diff)
           │    │
071  2D0FE │    │                       output op, VALID_PORT
           │    │
072        │    │                       ; Check to see if we are done sending A, B, C, T
072        │    │                       ; When cnt is equal to 4, we are done!
           │    │
072  11501 │    │                       add cnt, 01
073  1D504 │    │                       compare cnt, 04
074  3605D │    ╰─⤙                     jump NZ, .loop
           │
075        │                            ; Retrieve registers from stack
           │
075  11F01 │                            add SP, 01                     ; Pop
076  0A1F0 │                            fetch ip, (SP)
           │
077  11F01 │                            add SP, 01                     ; Pop
078  0A0F0 │                            fetch op, (SP)
           │
079  11F01 │                            add SP, 01                     ; Pop
07A  0A5F0 │                            fetch cnt, (SP)
           │
           │
07B  25000 │                            return
           │
07C        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
07C        │                            ; Name: get_event
           │                            ;
07C        │                            ; Routine to get a nuclear physics event
           │                            ;
07C        │                            ; Aquires data from the 4 ADCS (A, B, C, T) for all hit channels on
07C        │                            ; both PSD chips!
           │                            ;
07C        │                            ; We look at ORs and keep getting samples until both PSD0 and PSD1 ORs low!
07C        │                            ; Each time we get A, B, C, T samples, we send them to the FIFO
07C        │                            ; Each time send a word to the FIFO, we need to write to VALID_PORT
           │                            ;
07C        │                            ; Before we exit we need to send one more word, what we
07C        │                            ; send is not so important but when this word is sent
07C        │                            ; we need to do a write to LAST_PORT! This signals the end of packet!
           │                            ;
07C        │                            ; *** Used by nuclear program
           │                            ;
07C        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
07C        │                 get_event:
           │
07C        │                            ; Set the busy bit (also led[1])
07C        │                            ; Bit 1 of LED_PORT is led[1] which is also the busy bit!
           │
07C  05B02 ╭──────▶                     or led_reg, 02                 ; Set bit 1
07D  2DB00 │                            output led_reg, LED_PORT
           │
07E        │                            ; Check the ORs out of PSD chips
07E        │                            ; If both ORs low then we are done!
           │
07E  01A00 ╭┬─┬───▶              .loop: load psd_or_reg, 00
07F  01700 ││ │                         load adc_reg, 00
           ││ │
080  09102 ││ │                         input ip, PSD0_IPORT
081  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD0 OR
082  32084 ││ │  ╭⤙                     jump Z, .or0
083  05A01 ││ │  │                      or psd_or_reg, 01              ; Set bit 0			; Make note that PSD0 OR is high
084  09103 ││ │  ╰▶               .or0: input ip, PSD1_IPORT
085  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD1 OR
086  32088 ││ │  ╭⤙                     jump Z, .or1
087  05A02 ││ │  │                      or psd_or_reg, 02              ; Set bit 1			; Make note that PSD1 OR is high
           ││ │  │                      ;
088        ││ │  │                      ; Implement a case statement based on lower two bits of psd_or_reg
           ││ │  │                      ;
           ││ │  │
088  1DA00 ││ │  ╰▶               .or1: compare psd_or_reg, 00
089  320C4 ╭──────⤙                     jump Z, .done
08A  1DA01 ││ │                         compare psd_or_reg, 01
08B  32091 ││ │ ╭─⤙                     jump Z, .psd0
08C  1DA02 ││ │ │                       compare psd_or_reg, 02
08D  320A0 ││ │╭──⤙                     jump Z, .psd1
08E  1DA03 ││ │││                       compare psd_or_reg, 03
08F  320AF ││╭────⤙                     jump Z, .both
           ││││││                       ;
090        ││││││                       ; Should never happen ... if it does then hang
090        ││││││                       ; Both LEDs will be on and PicoBlaze will be
090        ││││││                       ; non-responsive
           ││││││                       ;
090  22090 ││││││╰▶               .err: jump .err
           ││││││
091        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
091        ││││││                       ;  Only PSD 0 needs attention
091        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           ││││││
091        ││││││                .psd0:
           ││││││
091        ││││││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
091        ││││││                       ; Notablly sel_ext_addr (bit 7) must be low!
091        ││││││                       ; The other bits in port ALSO need to be low
091        ││││││                       ; except for acq_clk (bit 3). It needs to be high.
091        ││││││                       ; PSD chips put out new analog outputs when acq_clk goes high!
           ││││││
091  01000 │││││╰─▶                     load op, 00
092  05008 │││││                        or op, 08                      ; Set bit 3				; acq clk for PSD 0 high
093  2D005 │││││                        output op, PSD0_OPORT
094  20037 ╰──────⤙                     call dly_us                    ; Give analog outputs chance to settle
           │││││                        ;
095        │││││                        ; Set up our masks
           │││││                        ;
095  01801 │││││                        load adc_clk_mask, 00000001'b
096  01904 │││││                        load adc_conv_mask, 00000100'b
           │││││
097        │││││                        ; Perform adc conversion
           │││││
097  2003B ╰──────⤙                     call adc_conv
           │││││
098        │││││                        ; Read PSD address
           │││││
098  09D02 │││││                        input addr_reg, PSD0_IPORT
           │││││
099        │││││                        ; We need to send A, B, C, T off to FIFO
           │││││
099  2004F ╰──────⤙                     call adc_to_fifo
           │││││
09A        │││││                        ; Bring acq_clk low (acq_clk is bit 3)
09A        │││││                        ; Resets the hit and active registers
           │││││
09A  030F7 │││││                        and op, f7                     ; Clear bit 3			 	; Bring acq clk low
09B  2D005 │││││                        output op, PSD0_OPORT
           │││││
09C        │││││                        ; Check token out from PSD 0 (token_out is bit 1)
09C        │││││                        ; If token_out is HIGH then contine else we are done
           │││││
09C  09102 │││││                        input ip, PSD0_IPORT
09D  0D102 │││││                        test ip, 02                    ; Test bit 1
09E  3607E │││╰───⤙                     jump NZ, .loop
09F  220C4 │││╭───⤙                     jump .done
           │││││
0A0        │││││                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
0A0        │││││                        ;  Only PSD 1 needs attention
0A0        │││││                        ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │││││
0A0        │││││                 .psd1:
           │││││
0A0        │││││                        ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
0A0        │││││                        ; Notablly sel_ext_addr (bit 7) must be low!
0A0        │││││                        ; The other bits in port ALSO need to be low
0A0        │││││                        ; except for acq_clk (bit 3). It needs to be high.
           │││││
0A0  01000 ││││╰──▶                     load op, 00
0A1  05008 ││││                         or op, 08                      ; Set bit 3
0A2  2D006 ││││                         output op, PSD1_OPORT
0A3  20037 ╰──────⤙                     call dly_us
           ││││
0A4        ││││                         ; Set up our masks
           ││││
0A4  01802 ││││                         load adc_clk_mask, 00000010'b
0A5  01908 ││││                         load adc_conv_mask, 00001000'b
           ││││
0A6        ││││                         ; Perform adc conversion
           ││││
0A6  2003B ╰──────⤙                     call adc_conv
           ││││
0A7        ││││                         ; Read PSD address
           ││││
0A7  09103 ││││                         input ip, PSD1_IPORT
           ││││
0A8        ││││                         ; We need to send A, B, C, T off to FIFO
           ││││
0A8  2004F ╰──────⤙                     call adc_to_fifo
           ││││
0A9        ││││                         ; Bring acq_clk low (acq_clk is bit 3)
0A9        ││││                         ; Resets the hit and active registers
           ││││
0A9  030F7 ││││                         and op, f7                     ; Clear bit 3
0AA  2D006 ││││                         output op, PSD1_OPORT
           ││││
0AB        ││││                         ; Check token out from PSD (token_out is bit 1)
0AB        ││││                         ; If token_out is HIGH then contine else we are done
           ││││
0AB  09103 ││││                         input ip, PSD1_IPORT
0AC  0D102 ││││                         test ip, 02                    ; Test bit 1
0AD  3607E │╰─────⤙                     jump NZ, .loop
0AE  220C4 │ ││ ╭─⤙                     jump .done
           │ ││ │
0AF        │ ││ │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
0AF        │ ││ │                       ;  Both PSD chips needs attention
0AF        │ ││ │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │ ││ │
0AF        │ ││ │                .both:
           │ ││ │
0AF        │ ││ │                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
0AF        │ ││ │                       ; Notablly sel_ext_addr (bit 7) must be low!
0AF        │ ││ │                       ; The other bits in port ALSO need to be low
0AF        │ ││ │                       ; except for acq_clk (bit 3). It needs to be high.
           │ ││ │
0AF  01000 │ ╰────▶                     load op, 00
0B0  05008 │  │ │                       or op, 08                      ; Set bit 3
0B1  2D005 │  │ │                       output op, PSD0_OPORT
0B2  2D006 │  │ │                       output op, PSD1_OPORT
0B3  20037 ╰──────⤙                     call dly_us                    ; Wait for PSD analog outputs to settle
           │  │ │
0B4        │  │ │                       ; Set up our masks
           │  │ │
0B4  01803 │  │ │                       load adc_clk_mask, 00000011'b
0B5  0190C │  │ │                       load adc_conv_mask, 00001100'b
           │  │ │
0B6        │  │ │                       ; Perform adc conversion
           │  │ │
0B6  2003B ╰──────⤙                     call adc_conv
           │  │ │
0B7        │  │ │                       ; Read PSD 0 address
           │  │ │
0B7  09702 │  │ │                       input adc_reg, PSD0_IPORT
           │  │ │
0B8        │  │ │                       ; We need to send A, B, C, T off to FIFO
           │  │ │
0B8  2004F ╰──────⤙                     call adc_to_fifo
           │  │ │
0B9        │  │ │                       ; Read PSD 1 address
           │  │ │
0B9  09703 │  │ │                       input adc_reg, PSD1_IPORT
           │  │ │
0BA        │  │ │                       ; We need to send A, B, C, T off to FIFO
           │  │ │
0BA  2004F ╰──────⤙                     call adc_to_fifo
           │  │ │
0BB        │  │ │                       ; Bring acq_clk low (acq_clk is bit 3)
0BB        │  │ │                       ; Resets the hit and active registers
           │  │ │
0BB  030F7 │  │ │                       and op, f7                     ; Clear bit 3
0BC  2D005 │  │ │                       output op, PSD0_OPORT
0BD  2D006 │  │ │                       output op, PSD1_OPORT
           │  │ │
0BE        │  │ │                       ; Check token out from PSD (token_out is bit 1)
0BE        │  │ │                       ; If token_out is HIGH then contine else we are done
           │  │ │
0BE  09102 │  │ │                       input ip, PSD0_IPORT
0BF  0D102 │  │ │                       test ip, 02                    ; Test bit 1
0C0  3607E ╰──────⤙                     jump NZ, .loop
           │  │ │
0C1  09103 │  │ │                       input ip, PSD1_IPORT
0C2  0D102 │  │ │                       test ip, 02                    ; Test bit 1
0C3  3607E ╰──────⤙                     jump NZ, .loop
           │  │ │
0C4        │  │ │                       ; We are DONE!
           │  │ │
0C4        │  │ │                .done:
           │  │ │
0C4        │  │ │                       ; (1) Need to send one more word to FIFO
0C4        │  │ │                       ; Bit 0 of STATUS_IPORT is the tready signal
0C4        │  │ │                       ; When we send this last word we need to write to the LAST_PORT
0C4        │  │ │                       ; So we can just ignore the last word sent on microblaze side of things
           │  │ │
0C4  09100 ╰──┴─┴┬▶                     input ip, STATUS_IPORT
0C5  0D101 │     │                      test ip, 01                    ; Test bit 0
0C6  320C4 │     ╰⤙                     jump Z, .done
           │
0C7        │                            ; What we write to LAST_PORT makes no difference
           │
0C7  2D2FF │                            output scr0, LAST_PORT
           │
0C8        │                            ; (2)
0C8        │                            ; Bring token_in (bit 6) high for bit PSD0 and PSD1
           │                            ;
0C8  05040 │                            or op, 40                      ; Set bit 6
0C9  2D005 │                            output op, PSD0_OPORT
0CA  2D006 │                            output op, PSD1_OPORT
0CB        │                            ; (3)
0CB        │                            ; Unset the busy flag (busy flag is same as LED 1)
           │                            ;
0CB  03BFD │                            and led_reg, fd                ; Clear bit 1
0CC  2DB00 │                            output led_reg, LED_PORT
           │
0CD  25000 │                            return
           │
0CE        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0CE        │                            ; ******* NUCLEAR PHYSICS PROGRAM *********
           │                            ;
0CE        │                            ; We sit in a tight loop waiting for take_event to go HIGH
0CE        │                            ; When posedge take_event comes along we call get_event routine.
           │                            ;
0CE        │                            ; We stay in get_event untill all PSD channels are read out and
0CE        │                            ; sent back to microblaze using the streamin FIFO.
           │                            ;
0CE        │                            ; We then wait for take_event to go LOW. We then go back and
0CE        │                            ; sit in tight loop waiting for next event!
           │                            ;
0CE        │                            ; led[0] is lit when take_event is high
0CE        │                            ; led[1] is lit when we are actually in the get_event subroutine
0CE        │                            ; led[1] is also the busy bit i.e we are in get_event!
           │                            ;
0CE        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0CE        │                   nuclear:
0CE  20001 ╰──────▶                     call init
           │
0CF        │                            ; Wait for take_event to go HIGH (Turn LED0 ON)
0CF        │                            ; Take event is bit 1 of the STATUS_IPORT
           │
0CF  09100 │    ╭┬▶             .wait0: input ip, STATUS_IPORT
0D0  0D102 │    ││                      test ip, 02                    ; Test bit 1
0D1  320CF │    │╰⤙                     jump Z, .wait0
           │    │
0D2        │    │                       ; First thing we need to do is bring veto_reset
0D2        │    │                       ; high on PSD chips before they auto_reset
0D2        │    │                       ; Keep force_reset low
           │    │
0D2  01000 │    │                       load op, 00
0D3  05002 │    │                       or op, 02                      ; Set bit 1
0D4  2D007 │    │                       output op, MISC_OPORT
           │    │
0D5        │    │                       ; Turn led[0] on (bit 0 of LED_PORT)
0D5        │    │                       ; led[0] is turned on only when we are in take event
           │    │
0D5  05B01 │    │                       or led_reg, 01                 ; Set bit 0
0D6  2DB00 │    │                       output led_reg, LED_PORT
           │    │
0D7        │    │                       ; Call the get_event routine
0D7        │    │                       ; Returns once all hit channels are read out!
0D7        │    │                       ; While we are in get_event the busy bit is set
           │    │
0D7        │    │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0D7  2007C ╰──────⤙                     call get_event
0D8        │    │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │    │
0D8        │    │                       ; De-assert veto_reset
0D8        │    │                       ; Keep force_reset low
           │    │
0D8  01000 │    │                       load op, 00
0D9  2D007 │    │                       output op, MISC_OPORT
           │    │
0DA        │    │                       ; Wait for take_event (bit 1 of STATUS_IPORT)
           │    │
0DA  09100 │    │╭▶             .wait1: input ip, STATUS_IPORT
0DB  0D102 │    ││                      test ip, 02                    ; Test bit 1
0DC  360DA │    │╰⤙                     jump NZ, .wait1
           │    │
0DD        │    │                       ; Force a reset (about 1 usec long)
0DD        │    │                       ; Shouldn’t be necessary but doesn’t hurt
           │    │
0DD  20030 ╰──────⤙                     call force_reset
                │
0DE             │                       ; Turn led[0] off!
                │
0DE  03BFE      │                       and led_reg, fe                ; Clear bit 0
0DF  2DB00      │                       output led_reg, LED_PORT
                │
0E0             │                       ; Go back and wait for the next event
                │
0E0  220CF      ╰─⤙                     jump .wait0

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/gengel/VIVADO_FPGA/Trenz-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    MISC_OPORT         07     pico_program.psm
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
    PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      0A
    datestamp_month    02
    datestamp_year     19
    timestamp_hours    0F
    timestamp_minutes  16
    timestamp_seconds  10


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "10 Feb 2025"
    timestamp$       "15:22:16"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv               03B   pico_program.psm
    adc_conv.clk_loop      044   pico_program.psm
    adc_to_fifo            04F   pico_program.psm
    adc_to_fifo.loop       05D   pico_program.psm
    adc_to_fifo.skip       06D   pico_program.psm
    adc_to_fifo.wait_trdy  06E   pico_program.psm
    dly_us                 037   pico_program.psm
    dly_us.wait_us         038   pico_program.psm
    force_reset            030   pico_program.psm
    get_event              07C   pico_program.psm
    get_event.both         0AF   pico_program.psm
    get_event.done         0C4   pico_program.psm
    get_event.err          090   pico_program.psm
    get_event.loop         07E   pico_program.psm
    get_event.or0          084   pico_program.psm
    get_event.or1          088   pico_program.psm
    get_event.psd0         091   pico_program.psm
    get_event.psd1         0A0   pico_program.psm
    init                   001   pico_program.psm
    my_isr                 380   pico_program.psm
    nuclear                0CE   pico_program.psm
    nuclear.wait0          0CF   pico_program.psm
    nuclear.wait1          0DA   pico_program.psm
 *  origin                 000   pico_program.psm
 *  tdc_reg_ld             02F   pico_program.psm
 *  tdc_ser                022   pico_program.psm
    tdc_ser.clk_loop       024   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          5
   ADDCY        -
   AND          9
   CALL         16
   CALL@        -
   COMPARE      5
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        4
   HWBUILD      -
   INPUT        15
   JUMP         26
   JUMP@        -
   LOAD         41
   LOAD&RETURN  -
   OR           19
   OUTPUT       40
   OUTPUTK      -
   REGBANK      -
   RETURN       8
   RETURNI      1
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          3
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        5
   SUB          7
   SUBCY        -
   TEST         12
   TESTCY       -
   XOR          3
