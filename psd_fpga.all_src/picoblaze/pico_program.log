Open PicoBlaze Assembler log for program "pico_program.psm"
Generated by opbasm v1.3.10
  Assembled on 2025-10-14T18:18:39
  Target architecture: PicoBlaze-6

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 4096
  Occupied memory locations: 358
  Memory locations available: 3738
  Scratchpad size: 256


Assembly listing
----------------
000                                     ; ################################################
000                                     ; NOTE:  All PicoBlaze instructions take 2 clock
000                                     ; cycles so 20 ns (100 MHz clock)
000                                     ; ################################################
                                        ;
000                                     ; GLE: 11-Feb-2025
000                                     ; Adding the support we need for TDC7200
                                        ;
000                                     ; GLE: 15-Feb-2025
000                                     ; Continuing to add TDC support
000                                     ; Fixed bug in get_event routine
000                                     ; Important that token_in go low before
000                                     ; acq_clk goes high!
                                        ;
000                                     ; GLE: 17-Feb-2025
000                                     ; Finished program BUT still needs to be tested!
000                                     ; Fixed a bug -> veto_reset should go low after take_event goes low
                                        ;
000                                     ; GLE: 19-Mar-2025
000                                     ; Reviewing to make sure everything is complete and working

000                                     ; ********************************************
000                                     ; Output ports (we have 8 "real" output ports)
000                                     ; There are also two pseudo ports used to
000                                     ; generate FIFO tvalid and tlast strobes
000                                     ; ********************************************

000                                     constant LED_PORT, 00

000                                     ; --------------------------------
000                                     ; PORT 0 (LED stuff)
000                                     ; -------------------------------
000                                     ; 0		LED 0
000                                     ; 1		LED 1 (also the busy bit!)
000                                     ; 2 		PICO Debug Flag 0
000                                     ; 3 		PICO Debug Flag 1
000                                     ; 	.
000                                     ; 	.
000                                     ; 	.
000                                     ; 7 		PICO Debug Flag 5
                                        ;
000                                     ; Prince - March 30: Used remaining bits to bring out 6 debug flag signals.



000                                     constant ADC_CTL_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (ADC control)
000                                     ; --------------------------------
000                                     ; 0		ADC sclk for PSD 0
000                                     ; 1		ADC sclk for PSD 1
000                                     ; 2		ADC conv for PSD 0
000                                     ; 3		ADC conv for PSD 1
000                                     ; 4		adc_mux_sel bit 0
000                                     ; 5		adc_mux_sel bit 1
000                                     ; 6		adc_mux_sel bit 2
000                                     ; 7		adc_reg_reset

000                                     constant DATA_TAG_PORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (Data identifier or tag)
000                                     ; --------------------------------
000                                     ; 0		psd addr bit 0
000                                     ; 1		psd addr bit 1
000                                     ; 2		psd addr bit 2
000                                     ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
000                                     ; 4		bit 0 of sc
000                                     ; 5		bit 1 of sc
000                                     ; 6		bit 0 of type
000                                     ; 7		bit 1 of type

000                                     ; type = 00 ---> ADC data
000                                     ; type = 01 ---> Timestamp Counter (upper and lower)
000                                     ; type = 10 ---> TDC TIME1 or TIME 2 value
000                                     ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
                                        ;
000                                     ; For type = 00
000                                     ; sc = 00 -----> integrator A
000                                     ; sc = 01 -----> integrator B
000                                     ; sc = 10 -----> integrator C
000                                     ; sc = 11 -----> time
                                        ;
000                                     ; For types 01, 10, 11
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TDC_DATA_PORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (TDC byte)
000                                     ; --------------------------------
000                                     ; 0		d0
000                                     ; 1		d1
000                                     ; 2		d2
000                                     ; 3		d3
000                                     ; 4		d4
000                                     ; 5		d5
000                                     ; 6		d6
000                                     ; 7		d7

000                                     constant TDC_CTL_PORT, 04

000                                     ; --------------------------------
000                                     ; PORT 4 (TDC register control)
000                                     ; --------------------------------
000                                     ; 0		tdc_reg_ld_0
000                                     ; 1		tdc_reg_ld_1
000                                     ; 2		tdc_reg_ld_2
000                                     ; 3		tdc_reg_rst
000                                     ; 4		tdc_reg_shift
000                                     ; 5		tdc_reg_sclk
000                                     ; 6		tdc_csb
000                                     ; 7		tdc_enable

000                                     constant PSD0_OPORT, 05

000                                     ; --------------------------------
000                                     ; PORT 5 (Outputs going to psd chip 0 )
000                                     ; --------------------------------
000                                     ; 0		psd0_addr_in_0
000                                     ; 1		psd0_addr_in_1
000                                     ; 2		psd0_addr_in_2
000                                     ; 3		psd0_acq_clk
000                                     ; 4		psd0_sc0
000                                     ; 5		psd0_sc1
000                                     ; 6		psd0_token_in
000                                     ; 7 	psd0_sel_ext_addr

000                                     constant PSD1_OPORT, 06

000                                     ; --------------------------------
000                                     ; PORT 6 (Outputs going to psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_addr_in_0
000                                     ; 1		psd1_addr_in_1
000                                     ; 2		psd1_addr_in_2
000                                     ; 3		psd1_acq_clk
000                                     ; 4		psd1_sc0
000                                     ; 5		psd1_sc1
000                                     ; 6 	psd1_token_in
000                                     ; 7 	psd1_sel_ext_addr

000                                     constant MISC_OPORT, 07

000                                     ; --------------------------------
000                                     ; PORT 7 (Misc outputs)
000                                     ; --------------------------------
                                        ;
000                                     ; 0 	force_psd_reset
000                                     ; 1		veto_reset
000                                     ; 2		fifo_mux_sel[0]
000                                     ; 3		fifo_mux_sel[1]
000                                     ; 4		psd_glob_ena
                                        ;
000                                     ; fifo_mux_sel = 00 -> adc_data (adc_reg)
000                                     ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
000                                     ; fifo_mux_sel = 10 -> tstamp counter (lower)
000                                     ; fifo_mux_sel = 11 -> tstamp counter (upper)

000                                     ; -------------------------------------------------------------
000                                     ; A write to "VALID" port asserts FIFO tvalid signal
000                                     ; A write to "LAST" port asserts FIFO tvalid and tlast signals
000                                     ; The value we write to port makes NO DIFFERENCE
000                                     ; -------------------------------------------------------------

000                                     constant VALID_PORT, fe

000                                     constant LAST_PORT, ff


000                                     ; **********************************
000                                     ; Input ports (We have 8 of them)
000                                     ; **********************************

000                                     constant STATUS_IPORT, 00

000                                     ; --------------------------------------------
000                                     ; PORT 0 (Status info)
000                                     ; --------------------------------------------
000                                     ; 0		tready signal from AXI Stream FIFO
000                                     ; 1		take_event signal from host
000                                     ; 2		tdc_intb (interrupt signal from TDC7200)
000                                     ; [3:7] 0

000                                     constant BOARD_ID_PORT, 01

000                                     ; --------------------------------
000                                     ; PORT 1 (board id)
000                                     ; --------------------------------
000                                     ; 0		board_id[0]
000                                     ; 1		board_id[1]
000                                     ; 2		board_id[2]
000                                     ; 3		board_id[3]
000                                     ; 4		board_id[4]
000                                     ; 5		board_id[5]
000                                     ; 6     0
000                                     ; 7     0

000                                     constant PSD0_IPORT, 02

000                                     ; --------------------------------
000                                     ; PORT 2 (inputs coming from psd chip 0)
000                                     ; --------------------------------
000                                     ; 0		psd0_or
000                                     ; 1		psd0_token_out
000                                     ; 2		psd0_acq_ack
000                                     ; 3		psd0_addr_out0
000                                     ; 4		psd0_addr_out1
000                                     ; 5		psd0_addr_out2
000                                     ; 6     0 (psd chip 0)
000                                     ; 7     0

000                                     constant PSD1_IPORT, 03

000                                     ; --------------------------------
000                                     ; PORT 3 (inputs coming from psd chip 1)
000                                     ; --------------------------------
000                                     ; 0		psd1_or
000                                     ; 1		psd1_token_out
000                                     ; 2		psd1_acq_ack
000                                     ; 3		psd1_addr_out0
000                                     ; 4		psd1_addr_out1
000                                     ; 5		psd1_addr_out2
000                                     ; 6		1 (psd chip 1)
000                                     ; 7     0

                                        ;
000                                     ; Picoblaze has 16 general purpose registers
000                                     ; We can use s0 - sd, se and sf are special
000                                     ; Give more desciptive names to some of our registers
000                                     ; The scratch registers get used but not restored!
000                                     ; Other regs tend to be saved on the stack!
                                        ;
000                                     namereg s0, op                 ; Output port register
000                                     namereg s1, ip                 ; Input port register
000                                     namereg s2, scr0               ; Scratchpad register 0 (scratch)
000                                     namereg s3, scr1               ; Scratchpad register 1 (scratch)
000                                     namereg s4, cnt                ; Used for counting "things"
000                                     namereg s5, dly_reg            ; Used in delay_1us routine
000                                     namereg s6, adc_reg            ; Used by adc routine
000                                     namereg s7, adc_clk_mask       ; Defines which adc clocks are to be used
000                                     namereg s8, adc_conv_mask      ; Defines which adc conv signals are to be used
000                                     namereg s9, psd_or_reg         ; Lower 2 bits keep track of PSD1 and PSD0 ORs
000                                     namereg sa, led_reg            ; State of LED_PORT
000                                     namereg sb, tdc_ctl_reg        ; State of TDC_CTL_PORT
000                                     namereg sc, misc_oport_reg     ; State of MISC_OPORT
000                                     namereg sd, addr_reg           ; Holds PSD channel address and TDC7200 addresses

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We’ll make sF special and use it for the stack pointer!
000                                     ; Start stack at end of 64-byte scratchpad (using macro!)
000                                     ; Stack grows down
000                                     ; Register se is also special
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     namereg sf, SP

000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; We will use macros but only sparingly!
000                                     ; A 16-bit register with scr1 (upper) and scr0 (lower)
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Scratchpad memory locations
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Read the board id port and store it in scratchpad memory

000                                     constant BOARD_ID, 00


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; TDC7200 address map (no auto-increment i.e. bit 7 is 0)
000                                     ; Read/Write control is bit 6 where set means WRITE!!!!
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Address of CONFIG1 register (with write bit set!)

000                                     constant CONFIG1, 40


000                                     ; Address of CONFIG2 register (with write bit set!)

000                                     constant CONFIG2, 41


000                                     ; Address of TIME1 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME1, 10


000                                     ; Address of TIME2 register (with write bit cleared!)
000                                     ; 24-bit values stored in this register tells us time
000                                     ; between start and first STOP

000                                     constant TIME2, 11


000                                     ; Address of CALIBRATION1 register (with write bit cleared!)

000                                     constant CALIBRATION1, 1b


000                                     ; Address of CALIBRATION2 register (with write bit cleared!)

000                                     constant CALIBRATION2, 1c


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Configuration values
                                        ;
000                                     ; We want Mode 1, 2 calibration cycles, 2 stops, ave cycles = 0
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

000                                     ; Value we want to load into CONFIG1 register
000                                     ; Bit 0 is set so it will start measurement when value written

000                                     constant CONFIG1_VAL, 01


000                                     ; Value we want to load into CONFIG2 register

000                                     constant CONFIG2_VAL, 01


000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Data id tag bytes when working with time data
000                                     ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
000                                     ; Here is the mapping
                                        ;
000                                     ; ---> 0100 0000 is lower 24 bits of tstamp_counter
000                                     ; ---> 0101 0000 is upper 24 bits of tstamp_counter
000                                     ; ---> 1001 0000 is TDC TIME1 value
000                                     ; ---> 1010 0000 is TDC TIME2 value
000                                     ; ---> 1101 0000 is TDC CALIBRATION1 value
000                                     ; ---> 1110 0000 is TDC CALIBRATION2 value

000                                     constant TSTAMP_LOWER_TAG, 40

000                                     constant TSTAMP_UPPER_TAG, 50

000                                     constant TDC_TIME1_TAG, 90

000                                     constant TDC_TIME2_TAG, a0

000                                     constant TDC_CAL1_TAG, d0

000                                     constant TDC_CAL2_TAG, e0


000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000                                     ; Our vector which points to main routineis stored at address 000
000                                     ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

000                                     address 000
000  2214C ╭──────⤙             origin: jump nuclear
           │
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
001        │                            ; Subroutine Name: init
           │                            ;
001        │                            ; Initialize the stack pointer, SP
001        │                            ; Initialize registers and ports
001        │                            ; Read board id and save
001        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
001        │                      init:
           │
001        │                            ; Initialize the stack pointer
           │
001  01F3F ╭──────▶                     load SP, 3f
           │
002        │                            ; Read the board id from port and save it to scratchpad memory location 0
           │
002  09201 │                            input scr0, BOARD_ID_PORT
003  2F200 │                            store scr0, BOARD_ID
           │
004        │                            ; Clear  registers
           │
004  01000 │                            load op, 00
005  01100 │                            load ip, 00
006  01200 │                            load scr0, 00
007  01300 │                            load scr1, 00
008  01400 │                            load cnt, 00
009  01500 │                            load dly_reg, 00
00A  01600 │                            load adc_reg, 00
00B  01700 │                            load adc_clk_mask, 00
00C  01800 │                            load adc_conv_mask, 00
00D  01900 │                            load psd_or_reg, 00
00E  01A00 │                            load led_reg, 00
00F  01B00 │                            load tdc_ctl_reg, 00
010  01C00 │                            load misc_oport_reg, 00
011  01D00 │                            load addr_reg, 00
           │
012        │                            ; Clear the output port registers
           │
012  2D200 │                            output scr0, LED_PORT          ; turn off LEDs
013  2D202 │                            output scr0, DATA_TAG_PORT
014  2D203 │                            output scr0, TDC_DATA_PORT
           │
015        │                            ; Bring tdc_csb (bit 6) high
015        │                            ; Rest of signals low
           │
015  05B40 │                            or tdc_ctl_reg, 40             ; Set bit 6
016  2DB04 │                            output tdc_ctl_reg, TDC_CTL_PORT
           │
017        │                            ; Need to reset the tdc_reg
017        │                            ; Synchronous reset (bit 3) so we need to apply a clock pulse
           │
017  2002B │   ╭──⤙                     call clr_tdc_reg
           │   │
018        │   │                        ; Reset the ADC shift registers
018        │   │                        ; Bring reset bit high in adc_reg and then back low
018        │   │                        ; Bit 7 of adc_reg is the reset adc registers bit
018        │   │                        ; Clock and conv signals low
018        │   │                        ; Mux selects (3’b000) choosing adc reg for PSD0 A integrator
018        │   │                        ; Pulse the adc reg reset line
           │   │
018  05680 │   │                        or adc_reg, 80                 ; Set bit 7
019  2D601 │   │                        output adc_reg, ADC_CTL_PORT
01A  0367F │   │                        and adc_reg, 7f                ; Clear bit 7
01B  2D601 │   │                        output adc_reg, ADC_CTL_PORT
           │   │
01C        │   │                        ; Make sure that tokens into the PSD chips are HIGH (inactive)
01C        │   │                        ; token_in for the PSD ports is bit 6
01C        │   │                        ; Others bit should be low
           │   │
01C  05040 │   │                        or op, 40                      ; Set bit 6
01D  2D005 │   │                        output op, PSD0_OPORT
01E  2D006 │   │                        output op, PSD1_OPORT
           │   │
01F        │   │                        ; Bring the force_reset and veto_reset pins low on both PSD chips
01F        │   │                        ; force_reset is bit 0
01F        │   │                        ; veto_reset is bit 1
01F        │   │                        ; fifo_mux_sel (bits 2 and 3) is 00 (i.e. selecting adc_reg)
01F        │   │                        ; Make psd_global_ena (bit 4) low
           │   │
01F  01C00 │   │                        load misc_oport_reg, 00
020  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
021        │   │                        ; We need to initialize the timestamp stuff if we are board 0
           │   │
021  0B200 │   │                        fetch scr0, BOARD_ID
022  1D200 │   │                        compare scr0, 00
023  36025 │   │ ╭⤙                     jump NZ, .done
           │   │ │
024        │   │ │                      ; If we are board 0, then we need to initialize the TDC7200 chip
           │   │ │
024  20037 │   │╭─⤙                     call tdc_init
           │   │││
025        │   │││                      ; Done so return
           │   │││
025  25000 │   ││╰▶              .done: return
           │   ││
026        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
026        │   ││                       ; Collection of support routines for timestamp creation.
           │   ││                       ;
026        │   ││                       ; We will used tdc_ctl_reg to keep state
026        │   ││                       ; of the TDC_CTL_PORT
           │   ││                       ;
026        │   ││                       ; --------------------------------
026        │   ││                       ; PORT 4 (TDC register control)
026        │   ││                       ; --------------------------------
026        │   ││                       ; 0		tdc_reg_ld_0
026        │   ││                       ; 1		tdc_reg_ld_1
026        │   ││                       ; 2		tdc_reg_ld_2
026        │   ││                       ; 3		tdc_reg_rst
026        │   ││                       ; 4		tdc_reg_shift
026        │   ││                       ; 5		tdc_reg_sclk
026        │   ││                       ; 6		tdc_csb
026        │   ││                       ; 7		tdc_enable
026        │   ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │   ││
026        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
026        │   ││                       ; Subroutine Name: tdc_reg_clk
           │   ││                       ;
026        │   ││                       ; Routine to apply a single clock pulse to tdc_reg
026        │   ││                       ; Doesn’t effect TDC7200 because tdc_csb should be high
026        │   ││                       ; when we apply the single clock pulse.  Pulse is needed
026        │   ││                       ; for synchronous reset and sychronous load of tdc_reg
026        │   ││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   ││
026  05B20 ╭─────┬▶        tdc_reg_clk: or tdc_ctl_reg, 20             ; Set bit 5
027  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk high
028  03BDF │   │││                      and tdc_ctl_reg, df            ; Clear bit 5
029  2DB04 │   │││                      output tdc_ctl_reg, TDC_CTL_PORT ; clk low
02A  25000 │   │││                      return
           │   │││
02B        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
02B        │   │││                      ; Subroutine Name: clr_tdc_reg
           │   │││                      ;
02B        │   │││                      ; Clears the tdc register in our timstamp_interface module
02B        │   │││                      ; The clear (bit 3) is synchronous so we need to apply a clock pulse
           │   │││                      ;
02B        │   │││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │││
02B  05B08 ╭┬──┴──▶        clr_tdc_reg: or tdc_ctl_reg, 08             ; Set bit 3
02C  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
02D  20026 ││   │╰⤙                     call tdc_reg_clk
02E  03BF7 ││   │                       and tdc_ctl_reg, f7            ; Clear bit 3
02F  2DB04 ││   │                       output tdc_ctl_reg, TDC_CTL_PORT
030  25000 ││   │                       return
           ││   │
031        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
031        ││   │                       ; Subroutine Name: tdc_ena
           ││   │                       ;
031        ││   │                       ; This routine will enable the TDC7200
031        ││   │                       ; We do this by bringing the tdc_enable (Bit 7) low
031        ││   │                       ; and then bring it high. Enable must be high
031        ││   │                       ; for TDC7200 to perform conversions.
031        ││   │                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   │
031  03B7F ││   │╭▶            tdc_ena: and tdc_ctl_reg, 7f            ; Clear bit 7
032  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
033  200AD ╭──────⤙                     call dly_us
034  05B80 ││   ││                      or tdc_ctl_reg, 80             ; Set bit 7
035  2DB04 ││   ││                      output tdc_ctl_reg, TDC_CTL_PORT
036  25000 ││   ││                      return
037        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
037        ││   ││                      ; Subroutine Name: tdc_init
           ││   ││                      ;
037        ││   ││                      ; Routine to initialize the TDC7200 and related circuits
037        ││   ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││   ││
037        ││   ││            tdc_init:
           ││   ││
037        ││   ││                      ; Enable the TDC7200
037        ││   ││                      ; This only needs to be done once
037        ││   ││                      ; Brings tdc_ena low and then high!
           ││   ││
037  20031 ││   ╰┴▶                     call tdc_ena
           ││
038        ││                           ; Load config data into CONFIG2 register
038        ││                           ; This only needs to be done once!!!!!
038        ││                           ; addr_reg needs to be loaded with address
038        ││                           ; op needs to be loaded with value to be stored at address
           ││
038  01D41 ││                           load addr_reg, CONFIG2
039  01001 ││                           load op, CONFIG2_VAL
03A  20051 ││ ╭───⤙                     call config_tdc
           ││ │
03B        ││ │                         ; Start a TDC7200 measurement!
           ││ │
03B  20063 ╭──────⤙                     call start_tdc
           ││ │
03C  25000 ││ │                         return
           ││ │
03D        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
03D        ││ │                         ; Subroutine Name: tdc_serial
           ││ │                         ;
03D        ││ │                         ; Routine to send and receive serial dataa
03D        ││ │                         ; from TDC7200. Used to send both internal
03D        ││ │                         ; register address and data to the TDC7200
           ││ │                         ;
03D        ││ │                         ; We should enter with cnt register containing
03D        ││ │                         ; number of clock pulses we want
           ││ │                         ;
03D        ││ │                         ; Make sure the tdc_csb is LOW when this routine
03D        ││ │                         ; is called!
           ││ │                         ;
03D        ││ │                         ; Minimum sclk period for the TDC7200 is 50 ns
           ││ │                         ;
03D        ││ │                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││ │
03D        ││ │             tdc_serial:
           ││ │
03D        ││ │                         ; Bring the shift control on tdc register high!
           ││ │
03D  05B10 ╭─┬────▶                     or tdc_ctl_reg, 10             ; Set bit 4
03E  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
03F        ││││                         ; Apply clock pulses (number in cnt register)
03F        ││││                         ; Use scr0 as a clock mask (tdc_sclk is bit 5)
           ││││
03F  01220 ││││                         load scr0, 00100000'b
040  06B20 ││││  ╭▶          .clk_loop: xor tdc_ctl_reg, scr0
041  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
042  00EE0 ││││  │                      load se, se                    ; NOP
043  00EE0 ││││  │                      load se, se                    ; NOP
044  06B20 ││││  │                      xor tdc_ctl_reg, scr0
045  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
046  19401 ││││  │                      sub cnt, 01
047  36040 ││││  ╰⤙                     jump NZ, .clk_loop
           ││││
048        ││││                         ; Bring the shift control on tdc register low!
           ││││
048  03BEF ││││                         and tdc_ctl_reg, ef            ; Clear bit 4
049  2DB04 ││││                         output tdc_ctl_reg, TDC_CTL_PORT
           ││││
04A  25000 ││││                         return
           ││││                         ;
04B        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04B        ││││                         ; Subroutine Name: tdc_csb_low
           ││││                         ;
04B        ││││                         ; Bring TDC7200 csb pin low (bit 6 of TDC_CTL_PORT)
04B        ││││                         ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││
04B  03BBF ╭─────┬▶        tdc_csb_low: and tdc_ctl_reg, bf            ; Clear bit 6
04C  2DB04 ││││  │                      output tdc_ctl_reg, TDC_CTL_PORT
04D  25000 ││││  │                      return
           ││││  │                      ;
04E        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
04E        ││││  │                      ; Subroutine Name: tdc_csb_high
           ││││  │                      ;
04E        ││││  │                      ; Bring TDC7200 CSB pin high (bit 6 of TDC_CTL_PORT)
04E        ││││  │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││  │
04E  05B40 ╭────┬─▶       tdc_csb_high: or tdc_ctl_reg, 40             ; Set bit 6
04F  2DB04 ││││ ││                      output tdc_ctl_reg, TDC_CTL_PORT
050  25000 ││││ ││                      return
           ││││ ││
051        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
051        ││││ ││                      ; Subroutine Name: config_tdc
           ││││ ││                      ;
051        ││││ ││                      ; When we enter, addr_reg should contain the configuration
051        ││││ ││                      ; register address we want to load, either CONFGI1 or CONFIG2
           ││││ ││                      ;
051        ││││ ││                      ; Also, when we enter, op register should contain the
051        ││││ ││                      ; configuration value, wither CONFIG1_VAL ore CONFIG2_VAL
           ││││ ││                      ;
051        ││││ ││                      ; Loads the TDC7200 CONFIG1 or CONFIG2 register
051        ││││ ││                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ││││ ││
051  2002B │╰─┴┬──⤙         config_tdc: call clr_tdc_reg
           │ │ │││
052        │ │ │││                      ; Load address information and write to TDC_DATA_PORT
052        │ │ │││                      ; addr_reg is passed into routine and contains address
052        │ │ │││                      ; of TDC7200 register we want to load!
           │ │ │││
052  2DD03 │ │ │││                      output addr_reg, TDC_DATA_PORT
           │ │ │││
053        │ │ │││                      ; Assert ld[2] control (most significant byte of tdc register)
053        │ │ │││                      ; Synchronous load so we need to apply a clock pulse!
053        │ │ │││                      ; ld[2] is bit 2 pf the TDC_CTL_PORT
           │ │ │││
053  05B04 │ │ │││                      or tdc_ctl_reg, 04             ; Set bit 2
054  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
055  20026 ╰──────⤙                     call tdc_reg_clk
056  03BFB │ │ │││                      and tdc_ctl_reg, fb            ; Clear bit 2
057  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
058        │ │ │││                      ; Write value to TDC_DATA_PORT
058        │ │ │││                      ; The op register is passed into routine and contains the data value
           │ │ │││
058  2D003 │ │ │││                      output op, TDC_DATA_PORT
           │ │ │││
059        │ │ │││                      ; Assert ld[1] control (middle byte of tdc register)
059        │ │ │││                      ; ld[1] is bit 1 of TDC_CTL_PORT
           │ │ │││
059  05B02 │ │ │││                      or tdc_ctl_reg, 02             ; Set bit 1
05A  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
05B  20026 ╰──────⤙                     call tdc_reg_clk
05C  03BFD │ │ │││                      and tdc_ctl_reg, fd            ; Clear bit 1
05D  2DB04 │ │ │││                      output tdc_ctl_reg, TDC_CTL_PORT
           │ │ │││
05E        │ │ │││                      ; Bring tdc_csb pin low (active)
           │ │ │││
05E  2004B │ │ ││╰⤙                     call tdc_csb_low
           │ │ ││
05F        │ │ ││                       ; Load cnt with the number of clock pulses we want i.e. 16
05F        │ │ ││                       ; We need 8 clocks to load register address and 8 to load the value
05F        │ │ ││                       ; Address goes in first followed by data
           │ │ ││
05F  01410 │ │ ││                       load cnt, 16'd
           │ │ ││
060        │ │ ││                       ; Call our TDC serial routine
           │ │ ││
060  2003D │ ╰────⤙                     call tdc_serial
           │   ││
061        │   ││                       ; Bring tdc_csb pin high (inactive)
           │   ││
061  2004E │   │╰─⤙                     call tdc_csb_high
           │   │
062  25000 │   │                        return
           │   │
063        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
063        │   │                        ; Subroutine Name: start_tdc
           │   │                        ;
063        │   │                        ; This routine will start a measurement on TDC7200
063        │   │                        ; if this board 0.
           │   │                        ;
063        │   │                        ; Measurements are started by writing to CONFIG1 with
063        │   │                        ; the least significant bit set!
           │   │                        ;
063        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
063        │   │             start_tdc:
           │   │
063        │   │                        ; Fetch the board id
           │   │
063  0B200 ╰──────▶                     fetch scr0, BOARD_ID
064  1D200 │   │                        compare scr0, 00
065  36069 │   │ ╭⤙                     jump NZ, .done
           │   │ │
066        │   │ │                      ; Start the TDC7200 since the board is 0
066        │   │ │                      ; We start the TDC7200 by writing to CONFIG1
           │   │ │
066  01D40 │   │ │                      load addr_reg, CONFIG1
067  01001 │   │ │                      load op, CONFIG1_VAL
068  20051 │   ╰──⤙                     call config_tdc
           │     │
069        │     │                      ; We are done, so return!
           │     │
069  25000 │     ╰▶              .done: return
           │
06A        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
06A        │                            ; Subroutine Name: read_tdc
           │                            ;
06A        │                            ; Reads a 24-bit register from the TDC7200
           │                            ;
06A        │                            ; When we enter, addr_reg should contain the register we
06A        │                            ; want to read from, either TIME1, TIME2, CALIBRATION1,
06A        │                            ; or CALIBRATION2
           │                            ;
06A        │                            ; Takes a total of 32 clock pulses to do the read
06A        │                            ; First 8 loads the register address and then last 24
06A        │                            ; clocks read out the data
06A        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
06A  2002B ╰───┬──⤙           read_tdc: call clr_tdc_reg               ; clears all 24-bits of tdc_reg
           │   │
06B        │   │                        ; Load address information and write to TDC_DATA_PORT
           │   │
06B  2DD03 │   │                        output addr_reg, TDC_DATA_PORT
           │   │
06C        │   │                        ; Assert ld[2] control (most significant byte of tdc register)
06C        │   │                        ; Load address of register into ms byte of tdc_reg
06C        │   │                        ; Synchronous load so we need to apply clock pulse
           │   │
06C  05B04 │   │                        or tdc_ctl_reg, 04             ; Set bit 2
06D  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
06E  20026 ╰──────⤙                     call tdc_reg_clk
06F  03BFB │   │                        and tdc_ctl_reg, fb            ; Clear bit 2
070  2DB04 │   │                        output tdc_ctl_reg, TDC_CTL_PORT
           │   │
071        │   │                        ; Bring tdc_csb pin low (active)
           │   │
071  2004B ╰──────⤙                     call tdc_csb_low
           │   │
072        │   │                        ; Load cnt register with the number of clock pulses we want i.e. 8
072        │   │                        ; It takes 8 clock pulses to load the register address (with write bit set)
072        │   │                        ; and then 24 clocks to read the data so a total of 32 clock pulse
           │   │
072  01420 │   │                        load cnt, 32'd
           │   │
073        │   │                        ; Call our TDC serial routine
           │   │
073  2003D ╰──────⤙                     call tdc_serial
           │   │
074        │   │                        ; Bring tdc_csb pin high (inactive)
           │   │
074  2004E ╰──────⤙                     call tdc_csb_high
           │   │
075  25000 │   │                        return
           │   │
076        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
076        │   │                        ; Subroutine Name: time_to_fifo
           │   │                        ;
076        │   │                        ; Routine sends time related data to the FIFO
           │   │                        ;
076        │   │                        ;	constant	TSTAMP_LOWER_TAG, 40
076        │   │                        ;	constant	TSTAMP_UPPER_TAG, 50
076        │   │                        ;	constant	TDC_TIME1_TAG, 90
076        │   │                        ;	constant	TDC_TIME2_TAG, a0
076        │   │                        ;	constant	TDC_CAL1_TAG, d0
076        │   │                        ;	constant	TDC_CAL2_TAG, e0
           │   │                        ;
076        │   │                        ; PORT 7 (MISC_OPORT)
           │   │                        ;
076        │   │                        ; 0 	force_psd_reset
076        │   │                        ; 1		veto_reset
076        │   │                        ; 2		fifo_mux_sel[0]
076        │   │                        ; 3		fifo_mux_sel[1]
076        │   │                        ; 4		psd_glob_ena
           │   │                        ;
076        │   │                        ; fifo_mux_sel = 00 -> adc_data (adc_reg)
076        │   │                        ; fifo_mux_sel = 01 -> tdc_data (tdc_reg)
076        │   │                        ; fifo_mux_sel = 10 -> tstamp counter (lower)
076        │   │                        ; fifo_mux_sel = 11 -> tstamp counter (upper)
           │   │                        ;
076        │   │                        ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │   │
076        │   │          time_to_fifo:
           │   │
076        │   │                        ; Send tstamp_counter (lower 24 bits)
076        │   │                        ; Start by writing out correct data tag
           │   │
076  01040 ╭──────▶                     load op, TSTAMP_LOWER_TAG
077  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
078        │   │                        ; Set the fifo_mux_sel to 10
           │   │
078  05C08 │   │                        or misc_oport_reg, 08          ; Set bit 3
079  03CFB │   │                        and misc_oport_reg, fb         ; Clear bit 2
07A  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
07B        │   │                        ; Wait for FIFO to be ready
07B        │   │                        ; Set the status bit LED[2] to high before starting to wait for tready
           │   │
07B        │   │                .wait0:
07B  09100 │   │ ╭▶                     input ip, STATUS_IPORT
           │   │ │
07C        │   │ │                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │   │ │
07C  0D101 │   │ │                      test ip, 01                    ; Test bit 0
07D  3207B │   │ ╰⤙                     jump Z, .wait0
           │   │
           │   │
07E        │   │                        ; When FIFO is ready, send data (what we send to vaild port makes no diff)
07E        │   │                        ; Writing to the VALID_port, strobes the tvalid control signal!
           │   │
07E  2D2FE │   │                        output scr0, VALID_PORT
           │   │
07F        │   │                        ; Send tstamp counter (upper 24 bits)
           │   │
07F  01050 │   │                        load op, TSTAMP_UPPER_TAG
080  2D002 │   │                        output op, DATA_TAG_PORT
           │   │
081        │   │                        ; Set the fifo_mux_sel to 11 (it was 10)
           │   │
081  05C04 │   │                        or misc_oport_reg, 04          ; Set bit 2
082  2DC07 │   │                        output misc_oport_reg, MISC_OPORT
           │   │
083        │   │                        ; Wait for FIFO to be ready
           │   │
083        │   │                .wait1:
083  09100 │   │ ╭▶                     input ip, STATUS_IPORT
084  0D101 │   │ │                      test ip, 01                    ; Test bit 0
085  32083 │   │ ╰⤙                     jump Z, .wait1
           │   │
           │   │
086        │   │                        ; Need to check if we are board 0 or not?
086        │   │                        ; The board ID is saved in scratchpad memory
086        │   │                        ; If not board 0, then got DONE!
           │   │
086  0B200 │   │                        fetch scr0, BOARD_ID
087  1D200 │   │                        compare scr0, 00
088  360AB │   │╭─⤙                     jump NZ, .done
           │   ││
089        │   ││                       ; This is board 0!
           │   ││
089  2D2FE │   ││                       output scr0, VALID_PORT
           │   ││
08A        │   ││                       ; Send tag to DATA_TAG_PORT
           │   ││
08A  01090 │   ││                       load op, TDC_TIME1_TAG
08B  2D002 │   ││                       output op, DATA_TAG_PORT
           │   ││
08C        │   ││                       ; Set the fifo_mux_sel to 01 (it was 11)
           │   ││
08C  03CF7 │   ││                       and misc_oport_reg, f7         ; Clear bit 3
08D  2DC07 │   ││                       output misc_oport_reg, MISC_OPORT
           │   ││
08E        │   ││                       ; Get and send TIME1 value
           │   ││
08E  01D10 │   ││                       load addr_reg, TIME1
08F  2006A │   ╰──⤙                     call read_tdc
           │    │
090        │    │                       ; Wait for the FIFO to be ready
           │    │
090        │    │               .wait2:
090  09100 │    │╭▶                     input ip, STATUS_IPORT
091  0D101 │    ││                      test ip, 01                    ; Test bit 0
092  32090 │    │╰⤙                     jump Z, .wait2
           │    │
           │    │
093        │    │                       ; Strobe TIME1 data into FIFO
           │    │
093  2D2FE │    │                       output scr0, VALID_PORT
           │    │
094        │    │                       ; Ready to handle TIME2 data!
094        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
094  010A0 │    │                       load op, TDC_TIME2_TAG
095  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
096        │    │                       ; Get TIME2 value
           │    │
096  01D11 │    │                       load addr_reg, TIME2
097  2006A ╰──────⤙                     call read_tdc
           │    │
098        │    │                       ; Wait for the FIFO to be ready
           │    │
098  09100 │    │╭▶             .wait3: input ip, STATUS_IPORT
099  0D101 │    ││                      test ip, 01                    ; Test bit 0
09A  32098 │    │╰⤙                     jump Z, .wait3
           │    │
09B        │    │                       ; Strobe data into FIFO
           │    │
09B  2D2FE │    │                       output scr0, VALID_PORT
           │    │
09C        │    │                       ; Ready to handle CALIBRATION1 value
09C        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
09C  010D0 │    │                       load op, TDC_CAL1_TAG
09D  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
09E        │    │                       ; Get CALIBRATION1 value
           │    │
09E  01D1B │    │                       load addr_reg, CALIBRATION1
09F  2006A ╰──────⤙                     call read_tdc
           │    │
0A0        │    │                       ; Wait for the FIFO to be ready
           │    │
0A0  09100 │    │╭▶             .wait4: input ip, STATUS_IPORT
0A1  0D101 │    ││                      test ip, 01                    ; Test bit 0
0A2  320A0 │    │╰⤙                     jump Z, .wait4
           │    │
           │    │
0A3        │    │                       ; Strobe data into FIFO
           │    │
0A3  2D2FE │    │                       output scr0, VALID_PORT
           │    │
0A4        │    │                       ; Ready to handle the CALIBRATION2 value
0A4        │    │                       ; Send tag to DATA_TAG_PORT
           │    │
0A4  010E0 │    │                       load op, TDC_CAL2_TAG
0A5  2D002 │    │                       output op, DATA_TAG_PORT
           │    │
0A6        │    │                       ; Get CALABRATION1 value
           │    │
0A6  01D1C │    │                       load addr_reg, CALIBRATION2
0A7  2006A ╰──────⤙                     call read_tdc
           │    │
0A8        │    │                       ; Wait for the FIFO to be ready
           │    │
0A8  09100 │    │╭▶             .wait5: input ip, STATUS_IPORT
0A9  0D101 │    ││                      test ip, 01                    ; Test bit 0
0AA  320A8 │    │╰⤙                     jump Z, .wait5
           │    │
           │    │
0AB        │    │                       ; DONE!
           │    │
0AB  2D2FF │    ╰─▶              .done: output scr0, LAST_PORT
0AC  25000 │                            return
           │
0AD        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0AD        │                            ; Subroutine Name: dly_us
           │                            ;
0AD        │                            ; Delay of 1 usec
0AD        │                            ; Delay is [(4 * dly_reg) + 6] / Fclk
0AD        │                            ; constant = (clock rate - 6) / 4 where clock rate is in MHz
           │                            ;
0AD        │                            ; Routine uses dly_reg and does not restore it
           │                            ;
0AD        │                            ; 24 (i.e $18) assumes a 100 MHz clock
0AD        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0AD        │                    dly_us:
0AD  01518 ╰─┬┬┬┬─▶                     load dly_reg, 24'd
0AE  19501 │ ││││╭▶           .wait_us: sub dly_reg, 01
0AF  360AE │ ││││╰⤙                     jump NZ, .wait_us
0B0  25000 │ ││││                       return
           │ ││││
0B1        │ ││││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0B1        │ ││││                       ; Subroutine Name: adc_conv
           │ ││││                       ;
0B1        │ ││││                       ; Pass in adc_clk_mask and adc_conv_mask
0B1        │ ││││                       ; clk_0 is bit 0 of adc_clk_mask
0B1        │ ││││                       ; clk_1 is bit 1 of adc_clk_mask
0B1        │ ││││                       ; conv_0 is bit 2 of adc_conv_mask
0B1        │ ││││                       ; conv_1 is bit 3 of adc_conv_maks
           │ ││││                       ;
0B1        │ ││││                       ; Uses the cnt register to count clock pulses (16 bit ADC)
0B1        │ ││││                       ; but restores cnt register before returning!!!
0B1        │ ││││                       ; Use adc_reg but we don’t restore it
           │ ││││                       ;
0B1        │ ││││                       ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │ ││││
0B1        │ ││││             adc_conv:
           │ ││││
0B1        │ ││││                       ; Save cnt register
           │ ││││
0B1  2E4F0 ╭──────▶                     store cnt, (SP)                ; Push
0B2  19F01 │ ││││                       sub SP, 01
           │ ││││
           │ ││││
0B3        │ ││││                       ; Bring conv signals high (determined by adc_conv_mask)
0B3        │ ││││                       ; The AD7687 ADCs sample PSD analog outputs on the rising
0B3        │ ││││                       ; edge of CONV signal
           │ ││││
0B3  200AD │ │││╰─⤙                     call dly_us                    ; DEBUG put in for ADC T Tail - Prince Sep 11
0B4  200AD │ ││╰──⤙                     call dly_us                    ;
0B5  00680 │ ││                         load adc_reg, adc_conv_mask    ; Make CONV high
0B6  2D601 │ ││                         output adc_reg, ADC_CTL_PORT
           │ ││
0B7        │ ││                         ; Wait for 2 usec
           │ ││
0B7  200AD │ │╰───⤙                     call dly_us
0B8  200AD │ ╰────⤙                     call dly_us
           │
0B9        │                            ; Bring conv signals low
           │
0B9  06680 │                            xor adc_reg, adc_conv_mask
0BA  2D601 │                            output adc_reg, ADC_CTL_PORT
           │
0BB        │                            ; Apply 16 clock pulses (takes about 2 usec)
0BB        │                            ; Reading serial data out of the ADCs
0BB        │                            ; Clocked into shift registers in our custom block
           │
0BB  01410 │                            load cnt, 16'd
0BC  06670 │     ╭▶          .clk_loop: xor adc_reg, adc_clk_mask
0BD  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0BE  06670 │     │                      xor adc_reg, adc_clk_mask
0BF  00EE0 │     │                      load se, se                    ; NOP
0C0  00EE0 │     │                      load se, se                    ; NOP
0C1  2D601 │     │                      output adc_reg, ADC_CTL_PORT
0C2  19401 │     │                      sub cnt, 01
0C3  360BC │     ╰⤙                     jump NZ, .clk_loop
           │
0C4        │                            ; Restore cnt register
           │
0C4  11F01 │                            add SP, 01                     ; Pop
0C5  0A4F0 │                            fetch cnt, (SP)
           │
           │
0C6  25000 │                            return
           │
0C7        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0C7        │                            ; Name: adc_to_fifo
           │                            ;
0C7        │                            ; Each time this routine is called, it sends the A, B, C, T
0C7        │                            ; adc values to the microblaze FIFO
0C7        │                            ; ip will be used ...should contain PSDx_IPORT (x = 0 or 1)
           │                            ;
0C7        │                            ; Tag format:
           │                            ;
0C7        │                            ; 0		psd addr bit 0
0C7        │                            ; 1		psd addr bit 1
0C7        │                            ; 2		psd addr bit 2
0C7        │                            ; 3		psd addr bit 3 n(0 = PSD 0, 1 = PSD 1)
0C7        │                            ; 4		bit 0 of sc
0C7        │                            ; 5		bit 1 of sc
0C7        │                            ; 6		bit 0 of type
0C7        │                            ; 7		bit 1 of type
           │
0C7        │                            ; type = 00 ---> ADC data
0C7        │                            ; type = 01 ---> Timestamp Counter
0C7        │                            ; type = 10 ---> TDC TIME1 or TIME 2 value
0C7        │                            ; type = 11 ---> TDC CALIBRATION1 or CALIBRATION2 value
           │
0C7        │                            ; sc = 00 -----> integrator A
0C7        │                            ; sc = 01 -----> integrator B
0C7        │                            ; sc = 10 -----> integrator C
0C7        │                            ; sc = 11 -----> time
0C7        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0C7        │               adc_to_fifo:
           │                            ;
0C7        │                            ; When we enter the routine, ip should contain PSD0 or PSD1 IPORT
0C7        │                            ; addr_reg will be used ...should contain PSDx_IPORT (x = 0 or 1)
0C7        │                            ; Here is the bit map
0C7        │                            ; NOTE: bit 6 tells us if it is PSD 0 or PSD1
           │                            ;
0C7        │                            ; 0		psd0_or
0C7        │                            ; 1		psd0_token_out
0C7        │                            ; 2		psd0_acq_ack
0C7        │                            ; 3		psd0_addr_out0
0C7        │                            ; 4		psd0_addr_out1
0C7        │                            ; 5		psd0_addr_out2
0C7        │                            ; 6     0 if PSD 0, 1 if PSD 1
0C7        │                            ; 7     0
           │
0C7        │                            ; Push some registers onto stack
           │
0C7  05A04 ╭──────▶                     or led_reg, 04                 ; Set bit 2  			;DEBUG FLAG 0 START
0C8  2DA00 │                            output led_reg, LED_PORT       ;DEBUG FLAG 0
           │
0C9  2E4F0 │                            store cnt, (SP)                ; Push
0CA  19F01 │                            sub SP, 01
           │
0CB  2E0F0 │                            store op, (SP)                 ; Push
0CC  19F01 │                            sub SP, 01
           │
0CD  2E1F0 │                            store ip, (SP)                 ; Push
0CE  19F01 │                            sub SP, 01
           │
           │
0CF        │                            ; Shift right 3 places
0CF        │                            ; Lower nybble now contains the channel address (bit 3 is PSD ID)
0CF        │                            ; Upper nybble contains 4’b000
           │
0CF  14D0E │                            sr0 addr_reg
0D0  14D0E │                            sr0 addr_reg
0D1  14D0E │                            sr0 addr_reg
           │
           │
0D2        │                            ; Load cnt to keep track which output we are working on
0D2        │                            ; A, B, C, or T (00, 01, 10, 11)
           │
0D2  01400 │                            load cnt, 00
           │
0D3        │                            ; Use scr1 to keep track of which PSD chip (either 0 or 1)
0D3        │                            ; Inspect bit 3 of ip register to see if it is PSD 0 or PSD 1
           │
0D3  01300 │                            load scr1, 00                  ; PSD 0
0D4  0DD08 │                            test addr_reg, 08              ; Test bit 3
0D5  320D7 │     ╭⤙                     jump Z, .loop
0D6  01301 │     │                      load scr1, 01                  ; PSD 1
           │     │
0D7        │     │                      ; We will write DATA_TAG_PORT first
0D7        │     │                      ; Format of the data tag byte :
0D7        │     │                      ; 	xxyyzzzz
0D7        │     │                      ; 	xx is type (00 = adc, 01 = tstamp, 10 = tdc time, 11 = tdc cal)
0D7        │     │                      ; 	For ADC, yy = sc (00 = A, 01 = B, 10 = C , 11 =T)
0D7        │     │                      ;	For tstamp_counter, yy -> 00 = lower 24 bits, 01 = upper 24 bits
0D7        │     │                      ;	For tdc time, yy = 01 -> TIME1, yy = 10 -> TIME2
0D7        │     │                      ;	For tdc calibration, yy = 01 = CALIBRATION1, yy = 10 -> CALIBRATION2
0D7        │     │                      ; 	zz = 4-bit channel address
           │     │
0D7  000D0 │    ╭┴▶              .loop: load op, addr_reg              ; Load channel address
0D8  00240 │    │                       load scr0, cnt                 ; Copy cnt (i.e. which analog output) to scr0
0D9  14206 │    │                       sl0 scr0
0DA  14206 │    │                       sl0 scr0
0DB  14206 │    │                       sl0 scr0
0DC  14206 │    │                       sl0 scr0
0DD        │    │                       ; Shift left 4 places
0DD  04020 │    │                       or op, scr0                    ; Combine with channel address
0DE  2D002 │    │                       output op, DATA_TAG_PORT       ; Put out our data tag (MSbyte of 32-bit word)
           │    │
0DF        │    │                       ; Now we will now write ADC_CTL_PORT
0DF        │    │                       ; We need to route out the appropriate ADC register to the FIFO using MUX (3 bits)
           │    │
0DF  00040 │    │                       load op, cnt                   ; cnt is either (00 = A, 01 = B, 10 = C, 11 = T)
0E0  14006 │    │                       sl0 op
0E1  14006 │    │                       sl0 op
0E2  14006 │    │                       sl0 op
0E3  14006 │    │                       sl0 op
0E4        │    │                       ; Mux sel is bits 4, 5, 6 of the ADC_CTL_PORT
           │    │
           │    │
0E4  0D301 │    │                       test scr1, 01                  ; Test bit 0				; Bit 6 is 0 if PSD 0
0E5  320E7 │    │╭⤙                     jump Z, .skip
0E6  05040 │    ││                      or op, 40                      ; Set bit 6				; Bit 6 is a 1 if PSD 1
           │    ││
           │    ││
0E7  2D001 │    │╰▶              .skip: output op, ADC_CTL_PORT
           │    │                       ;
0E8        │    │                       ; Correct input is now sitting on FIFO input
0E8        │    │                       ; Wait for ’tready’ signal to be active
           │    │                       ;
           │    │
0E8  09100 │    │╭▶         .wait_trdy: input ip, STATUS_IPORT
           │    ││
0E9        │    ││                      ; Test bit 0 of STATUS_PORT (i.e. tready) ... if zero we should wait
           │    ││
0E9  0D101 │    ││                      test ip, 01                    ; Test bit 0
0EA  320E8 │    │╰⤙                     jump Z, .wait_trdy
           │    │
           │    │
0EB        │    │                       ; When FIFO is ready, send data (what we send to vaild port makes no diff) --Prince: How do we know that the data is ready and stable?
           │    │
0EB  2D0FE │    │                       output op, VALID_PORT
           │    │
0EC        │    │                       ; Check to see if we are done sending A, B, C, T
0EC        │    │                       ; When cnt is equal to 4, we are done!
           │    │
0EC  11401 │    │                       add cnt, 01
0ED  1D404 │    │                       compare cnt, 04
0EE  360D7 │    ╰─⤙                     jump NZ, .loop
           │
0EF        │                            ; Retrieve registers from stack
           │
0EF  11F01 │                            add SP, 01                     ; Pop
0F0  0A1F0 │                            fetch ip, (SP)
           │
0F1  11F01 │                            add SP, 01                     ; Pop
0F2  0A0F0 │                            fetch op, (SP)
           │
0F3  11F01 │                            add SP, 01                     ; Pop
0F4  0A4F0 │                            fetch cnt, (SP)
           │
           │
           │
0F5  25000 │                            return
           │
0F6        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
0F6        │                            ; Name: get_event
           │                            ;
0F6        │                            ; Routine to get a nuclear physics event
           │                            ;
0F6        │                            ; Aquires data from the 4 ADCS (A, B, C, T) for all hit channels on
0F6        │                            ; both PSD chips!
           │                            ;
0F6        │                            ; We look at ORs and keep getting samples until both PSD0 and PSD1 ORs low!
0F6        │                            ; Each time we get A, B, C, T samples, we send them to the FIFO
0F6        │                            ; Each time send a word to the FIFO, we need to write to VALID_PORT (or LAST_PORT)
           │                            ;
0F6        │                            ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           │
0F6        │                 get_event:
           │
0F6        │                            ; Set the busy bit (also led[1])
0F6        │                            ; Bit 1 of LED_PORT is led[1] which is also the busy bit!
           │
0F6  05A02 ╭──────▶                     or led_reg, 02                 ; Set bit 1
0F7  2DA00 │                            output led_reg, LED_PORT
           │
0F8        │                            ; We need to set the FIFO mux to select the output of ADC mux
0F8        │                            ; fifo_mux_sel = 00 (bits 2 and 3 of the MISC_IPORT
           │
0F8  03CFB │                            and misc_oport_reg, fb         ; Clear bit 2
0F9  03CF7 │                            and misc_oport_reg, f7         ; Clear bit 3
0FA  2DC07 │                            output misc_oport_reg, MISC_OPORT
           │
0FB        │                            ; Check the ORs out of PSD chips
0FB        │                            ; If both ORs low then we are done!
           │
0FB  01900 ╭┬─┬───▶              .loop: load psd_or_reg, 00
0FC  01600 ││ │                         load adc_reg, 00
           ││ │
0FD  09102 ││ │                         input ip, PSD0_IPORT
0FE  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD0 OR
0FF  32101 ││ │  ╭⤙                     jump Z, .or0
100  05901 ││ │  │                      or psd_or_reg, 01              ; Set bit 0			; Make note that PSD0 OR is high
101  09103 ││ │  ╰▶               .or0: input ip, PSD1_IPORT
102  0D101 ││ │                         test ip, 01                    ; Test bit 0					; Testing PSD1 OR
103  32105 ││ │  ╭⤙                     jump Z, .or1
104  05902 ││ │  │                      or psd_or_reg, 02              ; Set bit 1			; Make note that PSD1 OR is high
           ││ │  │                      ;
105        ││ │  │                      ; Implement a case statement based on lower two bits of psd_or_reg
           ││ │  │                      ;
           ││ │  │
105  1D900 ││ │  ╰▶               .or1: compare psd_or_reg, 00
106  32145 ╭──────⤙                     jump Z, .done
107  1D901 ││ │                         compare psd_or_reg, 01
108  3210E ││ │ ╭─⤙                     jump Z, .psd0
109  1D902 ││ │ │                       compare psd_or_reg, 02
10A  3211E ││ │╭──⤙                     jump Z, .psd1
10B  1D903 ││ │││                       compare psd_or_reg, 03
10C  3212E ││╭────⤙                     jump Z, .both
           ││││││                       ;
10D        ││││││                       ; Should never happen ... if it does then hang
10D        ││││││                       ; Both LEDs will be on and PicoBlaze will be
10D        ││││││                       ; non-responsive
           ││││││                       ;
10D  2210D ││││││╰▶               .err: jump .err
           ││││││
10E        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
10E        ││││││                       ;  Only PSD 0 needs attention
10E        ││││││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           ││││││
10E        ││││││                .psd0:
           ││││││
10E        ││││││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
10E        ││││││                       ; Notablly sel_ext_addr (bit 7) must be low!
10E        ││││││                       ; The other bits in port ALSO need to be low
10E        ││││││                       ; except for acq_clk (bit 3). It needs to be high.
10E        ││││││                       ; PSD chips put out new analog outputs when acq_clk goes high!
           ││││││                       ;
10E        ││││││                       ; BUG FIX on 15-Feb-2025
10E        ││││││                       ; Important that token_in go low before acq_clk rises
           ││││││
10E  01000 │││││╰─▶                     load op, 00
10F  2D005 │││││                        output op, PSD0_OPORT          ; Token in low!!!!
110  05008 │││││                        or op, 08                      ; Set bit 3				; acq clk for PSD 0 high
111  2D005 │││││                        output op, PSD0_OPORT
112  200AD ╰──────⤙                     call dly_us                    ; Give analog outputs chance to settle
           │││││                        ;
113        │││││                        ; Set up our masks
           │││││                        ;
113  01701 │││││                        load adc_clk_mask, 00000001'b
114  01804 │││││                        load adc_conv_mask, 00000100'b
           │││││
115        │││││                        ; Perform adc conversion
           │││││
115  200B1 ╰──────⤙                     call adc_conv
           │││││
           │││││
116        │││││                        ; Read PSD address
           │││││
116  09D02 │││││                        input addr_reg, PSD0_IPORT
           │││││
117        │││││                        ; We need to send A, B, C, T off to FIFO
           │││││
117  200C7 ╰──────⤙                     call adc_to_fifo
           │││││
           │││││
118        │││││                        ; Bring acq_clk low (acq_clk is bit 3)
118        │││││                        ; Resets the hit and active registers
           │││││
118  030F7 │││││                        and op, f7                     ; Clear bit 3			 	; Bring acq clk low
119  2D005 │││││                        output op, PSD0_OPORT
           │││││
11A        │││││                        ; Check token out from PSD 0 (token_out is bit 1)
11A        │││││                        ; If token_out is HIGH then contine else we are done
           │││││
11A  09102 │││││                        input ip, PSD0_IPORT
11B  0D102 │││││                        test ip, 02                    ; Test bit 1
11C  360FB │││╰───⤙                     jump NZ, .loop
11D  22145 │││ │╭─⤙                     jump .done
           │││ ││
11E        │││ ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
11E        │││ ││                       ;  Only PSD 1 needs attention
11E        │││ ││                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │││ ││
11E        │││ ││                .psd1:
           │││ ││
11E        │││ ││                       ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
11E        │││ ││                       ; Notablly sel_ext_addr (bit 7) must be low!
11E        │││ ││                       ; The other bits in port ALSO need to be low
11E        │││ ││                       ; except for acq_clk (bit 3). It needs to be high.
           │││ ││
11E  01000 │││ ╰──▶                     load op, 00
11F  2D006 │││  │                       output op, PSD1_OPORT          ;	Token in low
120  05008 │││  │                       or op, 08                      ; Set bit 3
121  2D006 │││  │                       output op, PSD1_OPORT          ; 	Bring acq_clk high
122  200AD ╰──────⤙                     call dly_us
           │││  │
123        │││  │                       ; Set up our masks
           │││  │
123  01702 │││  │                       load adc_clk_mask, 00000010'b
124  01808 │││  │                       load adc_conv_mask, 00001000'b
           │││  │
125        │││  │                       ; Perform adc conversion
           │││  │
125  200B1 ╰──────⤙                     call adc_conv
           │││  │
126        │││  │                       ; Read PSD address
           │││  │
126  09D03 │││  │                       input addr_reg, PSD1_IPORT     ; bugfix - prince Aug 27 - changed ip to adc_reg for PSD 1 address location.
           │││  │
127        │││  │                       ; We need to send A, B, C, T off to FIFO
           │││  │
127  200C7 ╰──────⤙                     call adc_to_fifo
           │││  │
128        │││  │                       ; Bring acq_clk low (acq_clk is bit 3)
128        │││  │                       ; Resets the hit and active registers
           │││  │
128  030F7 │││  │                       and op, f7                     ; Clear bit 3
129  2D006 │││  │                       output op, PSD1_OPORT
           │││  │
12A        │││  │                       ; Check token out from PSD (token_out is bit 1)
12A        │││  │                       ; If token_out is HIGH then contine else we are done
           │││  │
12A  09103 │││  │                       input ip, PSD1_IPORT
12B  0D102 │││  │                       test ip, 02                    ; Test bit 1
12C  360FB │╰─────⤙                     jump NZ, .loop
12D  22145 │ │  │╭⤙                     jump .done
           │ │  ││
12E        │ │  ││                      ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
12E        │ │  ││                      ;  Both PSD chips needs attention
12E        │ │  ││                      ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$
           │ │  ││
12E        │ │  ││               .both:
           │ │  ││
12E        │ │  ││                      ; Bring token_in (bit 6 of PSD0_PORT) low i.e. active!!!!
12E        │ │  ││                      ; Notablly sel_ext_addr (bit 7) must be low!
12E        │ │  ││                      ; The other bits in port ALSO need to be low
12E        │ │  ││                      ; except for acq_clk (bit 3). It needs to be high.
           │ │  ││
12E  01000 │ ╰────▶                     load op, 00
12F  2D005 │    ││                      output op, PSD0_OPORT          ; Token in low
130  2D006 │    ││                      output op, PSD1_OPORT          ; Token in low
131  05008 │    ││                      or op, 08                      ; Set bit 3
132  2D005 │    ││                      output op, PSD0_OPORT          ; acq_clk high
133  2D006 │    ││                      output op, PSD1_OPORT          ; acq_clk high
134  200AD ╰──────⤙                     call dly_us                    ; Wait for PSD analog outputs to settle
           │    ││
135        │    ││                      ; Set up our masks
           │    ││
135  01703 │    ││                      load adc_clk_mask, 00000011'b
136  0180C │    ││                      load adc_conv_mask, 00001100'b
           │    ││
137        │    ││                      ; Perform adc conversion
           │    ││
137  200B1 ╰──────⤙                     call adc_conv
           │    ││
138        │    ││                      ; Read PSD 0 address
           │    ││
138  09602 │    ││                      input adc_reg, PSD0_IPORT
           │    ││
139        │    ││                      ; We need to send A, B, C, T off to FIFO
           │    ││
139  200C7 ╰──────⤙                     call adc_to_fifo
           │    ││
13A        │    ││                      ; Read PSD 1 address
           │    ││
13A  09603 │    ││                      input adc_reg, PSD1_IPORT
           │    ││
13B        │    ││                      ; We need to send A, B, C, T off to FIFO
           │    ││
13B  200C7 ╰──────⤙                     call adc_to_fifo
           │    ││
13C        │    ││                      ; Bring acq_clk low (acq_clk is bit 3)
13C        │    ││                      ; Resets the hit and active registers
           │    ││
13C  030F7 │    ││                      and op, f7                     ; Clear bit 3
13D  2D005 │    ││                      output op, PSD0_OPORT
13E  2D006 │    ││                      output op, PSD1_OPORT
           │    ││
13F        │    ││                      ; Check token out from PSD (token_out is bit 1)
13F        │    ││                      ; If token_out is HIGH then contine else we are done
           │    ││
13F  09102 │    ││                      input ip, PSD0_IPORT
140  0D102 │    ││                      test ip, 02                    ; Test bit 1
141  360FB ╰──────⤙                     jump NZ, .loop
           │    ││
142  09103 │    ││                      input ip, PSD1_IPORT
143  0D102 │    ││                      test ip, 02                    ; Test bit 1
144  360FB ╰──────⤙                     jump NZ, .loop
           │    ││
145        │    ││                      ; We are DONE!
           │    ││
145        │    ││               .done:
           │    ││
145        │    ││                      ; Not required as of Mar 31 - Prince
145        │    ││                      ;input		ip, STATUS_IPORT	; Tready  is bit 0 of STATUS_IPORT
145        │    ││                      ;testbit(ip, 0)
145        │    ││                      ;jump		Z,	.done
           │    ││
145        │    ││                      ; (1)
145        │    ││                      ; Bring token_in (bit 6) high for bit PSD0 and PSD1
           │    ││                      ;
145  05040 ╰────┴┴▶                     or op, 40                      ; Set bit 6
146  2D005 │                            output op, PSD0_OPORT
147  2D006 │                            output op, PSD1_OPORT
           │
148        │                            ; (2)
148        │                            ; Get and send time data to the FIFO
           │                            ;
148        │                            ;output		scr0, LAST_PORT		; temp DEBUG -prince - sep 30
148  20076 ╰──────⤙                     call time_to_fifo
           │
149        │                            ;clearbit(led_reg, 3) 			;DEBUG FLAG 1
149        │                            ;clearbit(led_reg, 2) 			;DEBUG FLAG 0
149        │                            ;clearbit(led_reg, 5) 			;DEBUG FLAG 3
149        │                            ;clearbit(led_reg, 4) 			;DEBUG FLAG 2
149        │                            ;output		led_reg, LED_PORT	;DEBUG FLAG 0,2,3 STOP
149        │                            ; (3)
149        │                            ; Unset the busy flag (busy flag is same as LED 1)
           │                            ;
149  03AFD │                            and led_reg, fd                ; Clear bit 1
14A  2DA00 │                            output led_reg, LED_PORT
           │
14B  25000 │                            return
           │
14C        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14C        │                            ; ******* NUCLEAR PHYSICS PROGRAM *********
           │                            ;
14C        │                            ; We sit in a tight loop waiting for take_event to go HIGH
14C        │                            ; When posedge take_event comes along we call get_event routine.
           │                            ;
14C        │                            ; We stay in get_event untill all PSD channels are read out and
14C        │                            ; sent back to microblaze using the streaming FIFO.
           │                            ;
14C        │                            ; We then wait for take_event to go LOW. We then go back and
14C        │                            ; sit in tight loop waiting for next event!
           │                            ;
14C        │                            ; led[1] is lit when we are actually in the get_event subroutine
14C        │                            ; led[1] is also the busy bit i.e we are in get_event!
           │                            ;
14C        │                            ; For time being let’s turn led[0] on whenever take_event is low
14C        │                            ; i.e. we are just waiting for an event to come along
           │                            ;
14C        │                            ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14C        │                   nuclear:
           │
14C        │                            ; Initialize registers, ports, etc
14C        │                            ; If board id is 0 then also configure and start TDC7200
           │
14C  20001 ╰──────▶                     call init
           │
14D        │                            ; Enable the PSD chips (turn on global enable)
           │
14D        │                            ; setbit(misc_oport_reg, 4)
14D        │                            ; output		misc_oport_reg, MISC_OPORT
           │
14D        │                            ; Turn led[0] on (On while we wait for take_event to go high!)
           │
14D  05A01 │    ╭─▶              .loop: or led_reg, 01                 ; Set bit 0
14E  2DA00 │    │                       output led_reg, LED_PORT
           │    │
14F        │    │                       ; Wait for take_event to go HIGH
14F        │    │                       ; Take event is bit 1 of the STATUS_IPORT
           │    │
14F  09100 │    │╭▶             .wait0: input ip, STATUS_IPORT
150  0D102 │    ││                      test ip, 02                    ; Test bit 1
151  3214F │    │╰⤙                     jump Z, .wait0
           │    │
152        │    │                       ; First thing we need to do is bring veto_reset
152        │    │                       ; high on PSD chips before they auto_reset and
152        │    │                       ; disable (global enable low!) the PSD chips
           │    │
152  05C02 │    │                       or misc_oport_reg, 02          ; Set bit 1		; Assert veto_reset
153  03CEF │    │                       and misc_oport_reg, ef         ; Clear bit 4		; Disable PSD
154  2DC07 │    │                       output misc_oport_reg, MISC_OPORT
           │    │
155        │    │                       ; Turn led[0] off since we are now processing an event!
           │    │
155  03AFE │    │                       and led_reg, fe                ; Clear bit 0
156  2DA00 │    │                       output led_reg, LED_PORT
           │    │
157        │    │                       ; Call the get_event routine
157        │    │                       ; Returns once all hit channels are read out!
157        │    │                       ; While we are in get_event the busy bit is set
           │    │
157        │    │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
157  200F6 ╰──────⤙                     call get_event
158             │                       ; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                │
158             │                       ; Wait for take_event to go INACTIVE (bit 1 of STATUS_IPORT)
                │
158  09100      │╭▶             .wait1: input ip, STATUS_IPORT
159  0D102      ││                      test ip, 02                    ; Test bit 1
15A  36158      │╰⤙                     jump NZ, .wait1
                │
15B             │                       ; De-assert veto_reset
                │
15B  03CFD      │                       and misc_oport_reg, fd         ; Clear bit 1
15C  2D007      │                       output op, MISC_OPORT
                │
15D             │                       ; Force a reset (about 1 usec long)
15D             │                       ; Shouldn’t be necessary but doesn’t hurt
15D             │                       ; We want to be absolutely sure analog blocks
15D             │                       ; are in reset when we enable psd chips!
                │
15D  05C01      │                       or misc_oport_reg, 01          ; Set bit 0
15E  2DC07      │                       output misc_oport_reg, MISC_OPORT
15F  00EE0      │                       load se, se                    ; NOP
160  00EE0      │                       load se, se                    ; NOP
161  03CFE      │                       and misc_oport_reg, fe         ; Clear bit 0
162  2DC07      │                       output misc_oport_reg, MISC_OPORT
                │
163             │                       ; Go back and wait for the next event
                │
163  2214D      ╰─⤙                     jump .loop                     ;

380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
380                                     ; Interrupt service routine
380                                     ; Currently not using interrupts so just return
                                        ;
380                                     ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

380                                     address 380
380                             my_isr:
380  29000       ╭▶                     returni disable
                 │                      ;
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3FF              │                      ; Interrupt vector is stored at location $3FF
3FF              │                      ; We will jump to our ISR routine
3FF              │                      ; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 │
3FF              │                      address 3FF
3FF  22380       ╰⤙                     jump my_isr



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/prince/Vivado_projects/Trenz-Projects/cfd-psd-fpga/psd_fpga.all_src/picoblaze/pico_program.psm


List of defined constants
-------------------------
    CONSTANT name      Value  Source PSM file 
 ----------------      -----  --------------- 
    ADC_CTL_PORT       01     pico_program.psm
    BEL                07
    BOARD_ID           00     pico_program.psm
    BOARD_ID_PORT      01     pico_program.psm
    BS                 08
    CALIBRATION1       1b     pico_program.psm
    CALIBRATION2       1c     pico_program.psm
    CONFIG1            40     pico_program.psm
    CONFIG1_VAL        01     pico_program.psm
    CONFIG2            41     pico_program.psm
    CONFIG2_VAL        01     pico_program.psm
    CR                 0D
    DATA_TAG_PORT      02     pico_program.psm
    DCS                90
    DEL                7F
    ESC                1B
    HT                 09
    LAST_PORT          ff     pico_program.psm
    LED_PORT           00     pico_program.psm
    LF                 0A
    MISC_OPORT         07     pico_program.psm
    NUL                00
    PSD0_IPORT         02     pico_program.psm
    PSD0_OPORT         05     pico_program.psm
    PSD1_IPORT         03     pico_program.psm
    PSD1_OPORT         06     pico_program.psm
    ST                 9C
    STATUS_IPORT       00     pico_program.psm
    TDC_CAL1_TAG       d0     pico_program.psm
    TDC_CAL2_TAG       e0     pico_program.psm
    TDC_CTL_PORT       04     pico_program.psm
    TDC_DATA_PORT      03     pico_program.psm
    TDC_TIME1_TAG      90     pico_program.psm
    TDC_TIME2_TAG      a0     pico_program.psm
    TIME1              10     pico_program.psm
    TIME2              11     pico_program.psm
    TSTAMP_LOWER_TAG   40     pico_program.psm
    TSTAMP_UPPER_TAG   50     pico_program.psm
    VALID_PORT         fe     pico_program.psm
    VT                 0B
    datestamp_day      0E
    datestamp_month    0A
    datestamp_year     19
    timestamp_hours    12
    timestamp_minutes  12
    timestamp_seconds  27


  No tables defined


List of text strings
--------------------
    STRING name      Value          Source PSM file
 --------------      -----          ---------------
    Opbasm_version$  "1.3.10"
    datestamp$       "14 Oct 2025"
    timestamp$       "18:18:39"


List of line labels
-------------------
    Label                  Addr  Source PSM file 
 --------                  ----  --------------- 
    adc_conv               0B1   pico_program.psm
    adc_conv.clk_loop      0BC   pico_program.psm
    adc_to_fifo            0C7   pico_program.psm
    adc_to_fifo.loop       0D7   pico_program.psm
    adc_to_fifo.skip       0E7   pico_program.psm
    adc_to_fifo.wait_trdy  0E8   pico_program.psm
    clr_tdc_reg            02B   pico_program.psm
    config_tdc             051   pico_program.psm
    dly_us                 0AD   pico_program.psm
    dly_us.wait_us         0AE   pico_program.psm
    get_event              0F6   pico_program.psm
    get_event.both         12E   pico_program.psm
    get_event.done         145   pico_program.psm
    get_event.err          10D   pico_program.psm
    get_event.loop         0FB   pico_program.psm
    get_event.or0          101   pico_program.psm
    get_event.or1          105   pico_program.psm
    get_event.psd0         10E   pico_program.psm
    get_event.psd1         11E   pico_program.psm
    init                   001   pico_program.psm
    init.done              025   pico_program.psm
    my_isr                 380   pico_program.psm
    nuclear                14C   pico_program.psm
    nuclear.loop           14D   pico_program.psm
    nuclear.wait0          14F   pico_program.psm
    nuclear.wait1          158   pico_program.psm
 *  origin                 000   pico_program.psm
    read_tdc               06A   pico_program.psm
    start_tdc              063   pico_program.psm
    start_tdc.done         069   pico_program.psm
    tdc_csb_high           04E   pico_program.psm
    tdc_csb_low            04B   pico_program.psm
    tdc_ena                031   pico_program.psm
    tdc_init               037   pico_program.psm
    tdc_reg_clk            026   pico_program.psm
    tdc_serial             03D   pico_program.psm
    tdc_serial.clk_loop    040   pico_program.psm
    time_to_fifo           076   pico_program.psm
    time_to_fifo.done      0AB   pico_program.psm
    time_to_fifo.wait0     07B   pico_program.psm
    time_to_fifo.wait1     083   pico_program.psm
    time_to_fifo.wait2     090   pico_program.psm
    time_to_fifo.wait3     098   pico_program.psm
    time_to_fifo.wait4     0A0   pico_program.psm
    time_to_fifo.wait5     0A8   pico_program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          5
   ADDCY        -
   AND          21
   CALL         40
   CALL@        -
   COMPARE      8
   COMPARECY    -
   DISABLE      -
   ENABLE       -
   FETCH        7
   HWBUILD      -
   INPUT        20
   JUMP         34
   JUMP@        -
   LOAD         59
   LOAD&RETURN  -
   OR           26
   OUTPUT       76
   OUTPUTK      -
   REGBANK      -
   RETURN       16
   RETURNI      1
   RL           -
   RR           -
   SL0          8
   SL1          -
   SLA          -
   SLX          -
   SR0          3
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        5
   SUB          7
   SUBCY        -
   TEST         17
   TESTCY       -
   XOR          5
